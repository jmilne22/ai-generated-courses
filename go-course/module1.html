<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1: Go Fundamentals | Go From Python</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="scanlines"></div>
    <div class="container">
        <nav>
            <a href="module0.html">â† Module 0</a>
            <a href="module2.html">Module 2 â†’</a>
        </nav>

        <div class="module-header">
            <div class="module-tag">// MODULE 01</div>
            <h1>Go Fundamentals</h1>
            <p class="module-desc">Variables, types, functions, and control flow. Every concept mapped from Python.</p>
        </div>

        <div class="lesson">
            <h2>Your First Go Program</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="func">print</span>(<span class="string">"Hello, World!"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="func">main</span>() {
    fmt.<span class="func">Println</span>(<span class="string">"Hello, World!"</span>)
}</pre>
                </div>
            </div>
            <ul>
                <li><strong>package main</strong> â€” Entry point package</li>
                <li><strong>import "fmt"</strong> â€” Import formatting package</li>
                <li><strong>func main()</strong> â€” Entry point function</li>
            </ul>
            <div class="tip">
                <div class="tip-title">Run it</div>
                <p>Save as <span class="inline-code">main.go</span>, run with <span class="inline-code">go run main.go</span></p>
            </div>
        </div>

        <div class="lesson">
            <h2>Variables & Types</h2>
            <p>Python is dynamically typed. Go is statically typed. This is the biggest shift.</p>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre>name = <span class="string">"Alice"</span>
age = <span class="number">30</span>
height = <span class="number">5.9</span>
is_cool = <span class="keyword">True</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="comment">// Explicit types</span>
<span class="keyword">var</span> name <span class="type">string</span> = <span class="string">"Alice"</span>
<span class="keyword">var</span> age <span class="type">int</span> = <span class="number">30</span>

<span class="comment">// Type inference with :=</span>
name := <span class="string">"Alice"</span>
age := <span class="number">30</span>
height := <span class="number">5.9</span>
isCool := <span class="keyword">true</span></pre>
                </div>
            </div>
            <div class="warning">
                <div class="warning-title">Gotcha</div>
                <p><span class="inline-code">:=</span> only works inside functions. At package level, use <span class="inline-code">var</span>.</p>
            </div>
            <h3>Common Types</h3>
            <div class="code-block">
                <div class="code-header go">Types</div>
                <pre><span class="type">string</span>   <span class="comment">// "hello"</span>
<span class="type">int</span>      <span class="comment">// 42 (platform-dependent size)</span>
<span class="type">int64</span>    <span class="comment">// 64-bit integer</span>
<span class="type">float64</span>  <span class="comment">// 3.14</span>
<span class="type">bool</span>     <span class="comment">// true, false</span>
<span class="type">byte</span>     <span class="comment">// alias for uint8</span>
<span class="type">rune</span>     <span class="comment">// alias for int32 (Unicode code point)</span></pre>
            </div>
            <div class="tip">
                <div class="tip-title">Zero Values</div>
                <p>Uninitialized variables get zero values: <span class="inline-code">""</span> for string, <span class="inline-code">0</span> for numbers, <span class="inline-code">false</span> for bool.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Functions</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">def</span> <span class="func">add</span>(a, b):
    <span class="keyword">return</span> a + b

<span class="keyword">def</span> <span class="func">greet</span>(name):
    <span class="keyword">return</span> <span class="string">f"Hello, </span>{name}<span class="string">!"</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">func</span> <span class="func">add</span>(a <span class="type">int</span>, b <span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> a + b
}

<span class="keyword">func</span> <span class="func">greet</span>(name <span class="type">string</span>) <span class="type">string</span> {
    <span class="keyword">return</span> fmt.<span class="func">Sprintf</span>(<span class="string">"Hello, %s!"</span>, name)
}</pre>
                </div>
            </div>
            <h3>Multiple Return Values</h3>
            <div class="code-block">
                <div class="code-header go">Multiple returns</div>
                <pre><span class="keyword">func</span> <span class="func">divide</span>(a, b <span class="type">float64</span>) (<span class="type">float64</span>, <span class="type">error</span>) {
    <span class="keyword">if</span> b == <span class="number">0</span> {
        <span class="keyword">return</span> <span class="number">0</span>, errors.<span class="func">New</span>(<span class="string">"division by zero"</span>)
    }
    <span class="keyword">return</span> a / b, <span class="keyword">nil</span>
}

result, err := divide(<span class="number">10</span>, <span class="number">2</span>)
<span class="keyword">if</span> err != <span class="keyword">nil</span> {
    fmt.<span class="func">Println</span>(err)
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Control Flow</h2>
            <h3 id="lesson-if">If Statements</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span>:
    <span class="func">print</span>(<span class="string">"Can drink"</span>)
<span class="keyword">elif</span> age >= <span class="number">18</span>:
    <span class="func">print</span>(<span class="string">"Can vote"</span>)
<span class="keyword">else</span>:
    <span class="func">print</span>(<span class="string">"Too young"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can drink"</span>)
} <span class="keyword">else if</span> age >= <span class="number">18</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can vote"</span>)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Too young"</span>)
}</pre>
                </div>
            </div>
            <h3 id="lesson-loops">For Loops (The Only Loop)</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">for</span> i <span class="keyword">in</span> <span class="func">range</span>(<span class="number">5</span>):
    <span class="func">print</span>(i)

<span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="func">enumerate</span>(items):
    <span class="func">print</span>(i, item)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">5</span>; i++ {
    fmt.<span class="func">Println</span>(i)
}

<span class="keyword">for</span> i, item := <span class="keyword">range</span> items {
    fmt.<span class="func">Println</span>(i, item)
}</pre>
                </div>
            </div>
        </div>

        <div class="lesson">
            <h2>Slices & Maps</h2>
            <h3 id="lesson-slices">Slices (Dynamic Arrays)</h3>
            <div class="code-block">
                <div class="code-header go">Slices</div>
                <pre>nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}
nums = <span class="func">append</span>(nums, <span class="number">4</span>)
fmt.<span class="func">Println</span>(nums[<span class="number">0</span>])     <span class="comment">// 1</span>
fmt.<span class="func">Println</span>(<span class="func">len</span>(nums))  <span class="comment">// 4</span>
fmt.<span class="func">Println</span>(nums[<span class="number">1</span>:<span class="number">3</span>])   <span class="comment">// [2 3]</span></pre>
            </div>
            <h3 id="lesson-maps">Maps (Dictionaries)</h3>
            <div class="code-block">
                <div class="code-header go">Creating and using maps</div>
                <pre>ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{
    <span class="string">"alice"</span>: <span class="number">30</span>,
    <span class="string">"bob"</span>:   <span class="number">25</span>,
}
ages[<span class="string">"charlie"</span>] = <span class="number">35</span>  <span class="comment">// Add new key</span>

fmt.<span class="func">Println</span>(ages[<span class="string">"alice"</span>])  <span class="comment">// 30</span></pre>
            </div>
            <div class="warning" id="lesson-comma-ok">
                <div class="warning-title">The Missing Key Problem</div>
                <p>In Python, accessing a missing key raises <span class="inline-code">KeyError</span>. In Go, it returns the <strong>zero value</strong> (0 for int, "" for string, etc). This means you can't tell if a key is missing or just has a zero value!</p>
            </div>
            <div class="code-block">
                <div class="code-header go">The "comma ok" idiom - checking if a key exists</div>
                <pre><span class="comment">// Wrong: Can't tell if dave is missing or age is 0</span>
age := ages[<span class="string">"dave"</span>]  <span class="comment">// Returns 0 (zero value)</span>

<span class="comment">// Right: Use the "comma ok" pattern</span>
<span class="comment">// ORDER: value, exists := map[key]</span>
<span class="comment">//        â†‘      â†‘</span>
<span class="comment">//        â”‚      â””â”€â”€ boolean: true if found, false if not</span>
<span class="comment">//        â””â”€â”€ the actual value (or zero value)</span>

age, ok := ages[<span class="string">"dave"</span>]
<span class="comment">// age = 0 (zero value for int)</span>
<span class="comment">// ok = false (key doesn't exist)</span>

<span class="keyword">if</span> ok {
    fmt.<span class="func">Println</span>(<span class="string">"Found:"</span>, age)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Not found"</span>)  <span class="comment">// This prints</span>
}

<span class="comment">// Common shorthand: declare inside if statement</span>
<span class="keyword">if</span> age, ok := ages[<span class="string">"alice"</span>]; ok {
    <span class="comment">//   â†‘    â†‘</span>
    <span class="comment">//   30  true</span>
    fmt.<span class="func">Println</span>(<span class="string">"Alice is"</span>, age)  <span class="comment">// Prints: Alice is 30</span>
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header python">Python equivalent</div>
                <pre><span class="comment"># In Python, you might do:</span>
age = ages.get(<span class="string">"dave"</span>)  <span class="comment"># Returns None if missing</span>
<span class="keyword">if</span> age <span class="keyword">is not None</span>:
    <span class="func">print</span>(<span class="string">f"Found: </span>{age}<span class="string">"</span>)

<span class="comment"># Or check with 'in':</span>
<span class="keyword">if</span> <span class="string">"dave"</span> <span class="keyword">in</span> ages:
    <span class="func">print</span>(<span class="string">f"Found: </span>{ages[<span class="string">'dave'</span>]}<span class="string">"</span>)</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Remember the order!</div>
                <p><strong>First variable</strong> = the value you're looking for<br>
                <strong>Second variable</strong> = boolean (did we find it?)<br><br>
                Pattern: <span class="inline-code">value, found := map[key]</span><br>
                You can name them anything, but <span class="inline-code">ok</span> is conventional for the boolean.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            <p>Progress through each section in order, or jump to where you need practice.</p>

            <!-- Table of Contents -->
            <div style="background: var(--bg-card); border-radius: 8px; padding: 1rem 1.5rem; margin: 1rem 0 2rem 0;">
                <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text);">Jump to section:</div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; font-size: 0.9rem;">
                    <a href="#warmups" style="color: var(--green-bright);">ğŸ”¥ Warmups</a>
                    <a href="#intermediate" style="color: var(--cyan);">âš¡ Intermediate</a>
                    <a href="#challenges" style="color: var(--orange);">ğŸ’ª Challenges</a>
                    <a href="#advanced" style="color: var(--purple);">ğŸš€ Advanced</a>
                </div>
            </div>

            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1.5rem;">
                <h3 id="warmups" style="color: var(--green-bright); margin: 0;">ğŸ”¥ Warmups</h3>
                <button id="shuffle-warmups-btn" onclick="shuffleWarmups()" style="background: var(--bg-card); border: 2px solid var(--green-bright); color: var(--green-bright); padding: 0.4rem 0.9rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; transition: all 0.3s;">ğŸ² Shuffle</button>
            </div>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice individual concepts you just learned.</p>

            <div id="warmups-container">
            <noscript>
            <div class="exercise">
                <h4>Warmup 1: Print 1 to 10</h4>
                <p>Write a program that prints the numbers 1 to 10, one per line.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content">Use <code>for i := 1; i <= 10; i++</code></div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>for i := 1; i <= 10; i++ {
    fmt.Println(i)
}</pre></div></details>
            </div>
            <div class="exercise">
                <h4>Warmup 2: Check Number Sign</h4>
                <p>Write <code>func checkSign(n int) string</code> that returns "positive", "negative", or "zero".</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content">Use <code>if n > 0</code>, then <code>else if n < 0</code>, then <code>else</code></div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>func checkSign(n int) string {
    if n > 0 {
        return "positive"
    } else if n < 0 {
        return "negative"
    }
    return "zero"
}</pre></div></details>
            </div>
            <div class="exercise">
                <h4>Warmup 3: Iterate Numbers</h4>
                <p>Create a slice with three numbers, then print each using <code>for range</code>.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content">Create: <code>nums := []int{7, 42, 99}</code><br>Loop: <code>for _, num := range nums</code></div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>nums := []int{7, 42, 99}
for _, num := range nums {
    fmt.Println(num)
}</pre></div></details>
            </div>
            <div class="exercise">
                <h4>Warmup 4: Ages Map</h4>
                <p>Create a map of names to ages, then print each person's name and age.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content">Map syntax: <code>map[string]int{"alice": 30}</code><br>Loop: <code>for name, age := range ages</code></div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>ages := map[string]int{
    "alice": 30,
    "bob":   25,
}
for name, age := range ages {
    fmt.Printf("%s is %d\n", name, age)
}</pre></div></details>
            </div>
            </noscript>
            </div>

            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 2rem;">
                <h3 id="intermediate" style="color: var(--cyan); margin: 0;">âš¡ Intermediate</h3>
                <button id="shuffle-intermediate-btn" onclick="shuffleIntermediate()" style="background: var(--bg-card); border: 2px solid var(--cyan); color: var(--cyan); padding: 0.4rem 0.9rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; transition: all 0.3s;">ğŸ² Shuffle</button>
            </div>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Each exercise introduces ONE new concept. Build your toolkit!</p>

            <div id="intermediate-container">
            <noscript>
            <div class="exercise">
                <h4>Intermediate 1: Make and Append to Slice</h4>
                <p>Create an empty slice using <code>make([]int, 0)</code>, add three numbers with <code>append</code>, then print its length.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content"><code>make([]int, 0)</code> creates an empty int slice<br><code>nums = append(nums, value)</code> adds to the slice</div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>nums := make([]int, 0)
nums = append(nums, 10)
nums = append(nums, 20)
nums = append(nums, 30)
fmt.Println(len(nums))  // 3</pre></div></details>
                <div class="expected"><div class="expected-title">Expected Output</div><pre>3</pre></div>
            </div>
            <div class="exercise">
                <h4>Intermediate 2: Check Map Key Exists</h4>
                <p>Create a map of fruit prices. Check if "banana" exists using the <code>value, ok := map[key]</code> pattern.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content"><code>price, ok := prices["banana"]</code><br><code>ok</code> is true if key exists, false otherwise</div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>prices := map[string]float64{
    "apple":  1.50,
    "orange": 2.00,
}

if price, ok := prices["banana"]; ok {
    fmt.Printf("Banana: $%.2f\n", price)
} else {
    fmt.Println("Banana not found")
}</pre></div></details>
                <div class="expected"><div class="expected-title">Expected Output</div><pre>Banana not found</pre></div>
            </div>
            <div class="exercise">
                <h4>Intermediate 3: Print Index and Value</h4>
                <p>Create a slice of your favorite foods. Loop through and print both index and value: "0: pizza", "1: tacos", etc.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content"><code>for i, food := range foods</code> gives you both index and value</div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>foods := []string{"pizza", "tacos", "sushi"}
for i, food := range foods {
    fmt.Printf("%d: %s\n", i, food)
}</pre></div></details>
                <div class="expected"><div class="expected-title">Expected Output</div><pre>0: pizza
1: tacos
2: sushi</pre></div>
            </div>
            <div class="exercise">
                <h4>Intermediate 4: Collect Even Numbers</h4>
                <p>Create an empty slice, then loop 1-10 and append only even numbers. Print the result.</p>
                <details><summary>ğŸ’¡ Hint</summary><div class="hint-content">Check <code>if i%2 == 0</code><br>Use <code>append</code> inside the if block</div></details>
                <details><summary>âœ… Solution</summary><div class="hint-content"><pre>evens := []int{}
for i := 1; i <= 10; i++ {
    if i%2 == 0 {
        evens = append(evens, i)
    }
}
fmt.Println(evens)</pre></div></details>
                <div class="expected"><div class="expected-title">Expected Output</div><pre>[2 4 6 8 10]</pre></div>
            </div>
            </noscript>
            </div>

            <h3 id="challenges" style="color: var(--orange); margin-top: 2rem;">ğŸ’ª Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">Practice combining concepts. Skip to Advanced if you're comfortable with the basics.</p>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-challenges-btn" onclick="shuffleChallenges()" style="background: var(--bg-card); border: 1px solid var(--orange); color: var(--orange); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    ğŸ² Shuffle Challenges
                </button>
            </div>

            <!-- Challenges will be dynamically loaded -->
            <div id="challenges-container">

            <!-- Fallback for no JS -->
            <noscript>
            <p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block 1: Core Patterns</p>

            <div class="exercise">
                <h4>Challenge 1: Sum of Slice</h4>
                <p>Write a function <code>func sum(numbers []int) int</code> that returns the sum of all numbers in a slice.</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Create accumulator</summary>
                    <div class="hint-content">
<pre>total := 0</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Loop and accumulate</summary>
                    <div class="hint-content">
<pre>for _, num := range numbers {
    total += num
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func sum(numbers []int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>sum([]int{1, 2, 3, 4, 5}) â†’ 15
sum([]int{10, 20}) â†’ 30</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 2: Count Evens</h4>
                <p>Write a function <code>func countEvens(nums []int) int</code> that returns how many even numbers are in the slice.</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Create counter</summary>
                    <div class="hint-content">
<pre>count := 0</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Check if even with modulo</summary>
                    <div class="hint-content">
<pre>for _, num := range nums {
    if num%2 == 0 {
        count++
    }
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func countEvens(nums []int) int {
    count := 0
    for _, num := range nums {
        if num%2 == 0 {
            count++
        }
    }
    return count
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>countEvens([]int{1, 2, 3, 4, 5, 6}) â†’ 3
countEvens([]int{1, 3, 5}) â†’ 0
countEvens([]int{2, 4, 6}) â†’ 3</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 3: FizzBuzz</h4>
                <p>Print numbers 1-20. For multiples of 3 print "Fizz", multiples of 5 print "Buzz", multiples of both print "FizzBuzz".</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Loop 1 to 20</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 20; i++ {
    // check conditions here
}</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Check divisibility (order matters!)</summary>
                    <div class="hint-content">
<pre>if i%15 == 0 {       // Check 15 first (or 3 AND 5)
    fmt.Println("FizzBuzz")
} else if i%3 == 0 {
    fmt.Println("Fizz")
} else if i%5 == 0 {
    fmt.Println("Buzz")
} else {
    fmt.Println(i)
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 20; i++ {
    if i%15 == 0 {
        fmt.Println("FizzBuzz")
    } else if i%3 == 0 {
        fmt.Println("Fizz")
    } else if i%5 == 0 {
        fmt.Println("Buzz")
    } else {
        fmt.Println(i)
    }
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output (partial)</div>
                    <pre>1
2
Fizz
4
Buzz
Fizz
7
...
FizzBuzz</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 4: Find Maximum</h4>
                <p>Write a function <code>func max(nums []int) int</code> that returns the largest number in a slice.</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Start with first element</summary>
                    <div class="hint-content">
<pre>maxNum := nums[0]</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Update if bigger found</summary>
                    <div class="hint-content">
<pre>for _, num := range nums {
    if num > maxNum {
        maxNum = num
    }
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func max(nums []int) int {
    maxNum := nums[0]
    for _, num := range nums {
        if num > maxNum {
            maxNum = num
        }
    }
    return maxNum
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>max([]int{3, 7, 2, 9, 1}) â†’ 9
max([]int{-5, -2, -10}) â†’ -2</pre>
                </div>
            </div>

            <!-- Block 2: Building & Filtering (5-7) -->
            <p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block 2: Building & Filtering</p>

            <div class="exercise">
                <h4>Challenge 5: Filter Positives</h4>
                <p>Write a function <code>func filterPositives(nums []int) []int</code> that returns a new slice containing only the positive numbers (greater than 0).</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Create empty result slice</summary>
                    <div class="hint-content">
<pre>result := []int{}</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Append if positive</summary>
                    <div class="hint-content">
<pre>for _, num := range nums {
    if num > 0 {
        result = append(result, num)
    }
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func filterPositives(nums []int) []int {
    result := []int{}
    for _, num := range nums {
        if num > 0 {
            result = append(result, num)
        }
    }
    return result
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>filterPositives([]int{-2, 3, -1, 5, 0}) â†’ [3, 5]
filterPositives([]int{1, 2, 3}) â†’ [1, 2, 3]
filterPositives([]int{-1, -2}) â†’ []</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 6: Find Index</h4>
                <p>Write a function <code>func findIndex(nums []int, target int) int</code> that returns the index of target in the slice, or -1 if not found.</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Loop with index</summary>
                    <div class="hint-content">
<pre>for i, num := range nums {
    // check and return index
}</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Return index when found</summary>
                    <div class="hint-content">
<pre>if num == target {
    return i  // Return the INDEX, not true!
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func findIndex(nums []int, target int) int {
    for i, num := range nums {
        if num == target {
            return i
        }
    }
    return -1
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>findIndex([]int{10, 20, 30, 40}, 30) â†’ 2
findIndex([]int{10, 20, 30, 40}, 50) â†’ -1
findIndex([]int{5, 5, 5}, 5) â†’ 0</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 7: Count Occurrences</h4>
                <p>Write a function <code>func countOccurrences(nums []int) map[int]int</code> that returns a map where each key is a number from the slice and each value is how many times it appears.</p>

                <details>
                    <summary>ğŸ“– Why this matters</summary>
                    <div class="hint-content">
                        This "counting with maps" pattern is <strong>fundamental</strong> for the Advanced section!<br>
                        You'll use this exact pattern in:<br>
                        â€¢ <strong>Advanced 1:</strong> Contains Duplicate (map as set)<br>
                        â€¢ <strong>Advanced 4:</strong> Word Counter (count words)<br>
                        â€¢ <strong>Advanced 5:</strong> Two Sum (map for lookup)<br><br>
                        Master this pattern now - it's worth the investment!
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 1: Create the map</summary>
                    <div class="hint-content">
<pre>counts := make(map[int]int)</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Loop and increment</summary>
                    <div class="hint-content">
<pre>for _, num := range nums {
    counts[num]++  // This works even for new keys!
}</pre>
                        When a key doesn't exist, Go returns 0 (the zero value for int), then <code>++</code> increments it to 1.
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func countOccurrences(nums []int) map[int]int {
    counts := make(map[int]int)
    for _, num := range nums {
        counts[num]++
    }
    return counts
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>countOccurrences([]int{1, 2, 2, 3, 3, 3}) â†’ map[1:1 2:2 3:3]
countOccurrences([]int{5, 5, 5, 5}) â†’ map[5:4]
countOccurrences([]int{1, 2, 3}) â†’ map[1:1 2:1 3:1]</pre>
                </div>
            </div>

            <!-- Block 3: Two-Pointer Foundation (8-9) -->
            <p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block 3: Two-Pointer Foundation</p>

            <div class="exercise">
                <h4>Challenge 8: Swap Elements</h4>
                <p>Write a function <code>func swapElements(nums []int, i int, j int)</code> that swaps the elements at positions i and j in the slice.</p>

                <details>
                    <summary>ğŸ’¡ New Concept: Simultaneous Assignment</summary>
                    <div class="hint-content">
                        Go lets you swap two variables in one line without a temp variable:<br><br>
                        <code>a, b = b, a</code><br><br>
                        This works because Go evaluates the right side first, then assigns to the left side.<br><br>
                        For arrays: <code>nums[i], nums[j] = nums[j], nums[i]</code>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ The one-liner</summary>
                    <div class="hint-content">
<pre>nums[i], nums[j] = nums[j], nums[i]</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func swapElements(nums []int, i int, j int) {
    nums[i], nums[j] = nums[j], nums[i]
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Behavior</div>
                    <pre>nums := []int{1, 2, 3, 4, 5}
swapElements(nums, 0, 4)
fmt.Println(nums) â†’ [5, 2, 3, 4, 1]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 9: Palindrome Checker</h4>
                <p>Write a function <code>func isPalindrome(nums []int) bool</code> that checks if a slice reads the same forwards and backwards using two pointers.</p>

                <details>
                    <summary>ğŸ“– What's a palindrome?</summary>
                    <div class="hint-content">
                        A <strong>palindrome</strong> reads the same forwards and backwards:<br>
                        â€¢ [1, 2, 3, 2, 1] â†’ palindrome âœ…<br>
                        â€¢ [5, 5] â†’ palindrome âœ…<br>
                        â€¢ [1, 2, 3] â†’ reads [3, 2, 1] backwards âŒ
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 1: Two-pointer loop structure</summary>
                    <div class="hint-content">
<pre>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
    // compare elements
}</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Compare and return early if mismatch</summary>
                    <div class="hint-content">
<pre>if nums[i] != nums[j] {
    return false  // Not a palindrome!
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func isPalindrome(nums []int) bool {
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        if nums[i] != nums[j] {
            return false
        }
    }
    return true
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>isPalindrome([]int{1, 2, 3, 2, 1}) â†’ true
isPalindrome([]int{1, 2, 3, 4, 5}) â†’ false
isPalindrome([]int{5, 5}) â†’ true</pre>
                </div>
            </div>

            <!-- Block 4: Two-Pointer Application (10-11) -->
            <p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block 4: Two-Pointer Application</p>

            <div class="exercise">
                <h4>Challenge 10: Reverse a Slice</h4>
                <p>Write a function <code>func reverseSlice(nums []int) []int</code> that reverses a slice in place. Combines swap (Challenge 8) + two-pointer loop (Challenge 9)!</p>

                <details>
                    <summary>ğŸ’¡ Combine the patterns</summary>
                    <div class="hint-content">
                        Use the two-pointer loop from Challenge 9:<br>
                        <code>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1</code><br><br>
                        But instead of comparing, <strong>swap</strong> like Challenge 8:<br>
                        <code>nums[i], nums[j] = nums[j], nums[i]</code>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func reverseSlice(nums []int) []int {
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        nums[i], nums[j] = nums[j], nums[i]
    }
    return nums
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverseSlice([]int{1, 2, 3, 4, 5}) â†’ [5, 4, 3, 2, 1]
reverseSlice([]int{10, 20}) â†’ [20, 10]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 11: First Duplicate Index</h4>
                <p>Write a function <code>func firstDuplicateIndex(nums []int) int</code> that returns the index of the first number that has appeared before, or -1 if all are unique.</p>

                <details>
                    <summary>ğŸ“– Why this matters</summary>
                    <div class="hint-content">
                        This is the <strong>critical bridge</strong> to Advanced exercises!<br><br>
                        Pattern: Map lookup + early return with index<br>
                        â€¢ <strong>Advanced 1:</strong> Same pattern, returns bool<br>
                        â€¢ <strong>Advanced 5:</strong> Same pattern, looking for complement
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 1: Create map to track seen numbers</summary>
                    <div class="hint-content">
<pre>seen := make(map[int]bool)</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Loop with index, check then add</summary>
                    <div class="hint-content">
<pre>for i, num := range nums {
    if seen[num] {
        return i  // Found duplicate, return its index!
    }
    seen[num] = true
}</pre>
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func firstDuplicateIndex(nums []int) int {
    seen := make(map[int]bool)
    for i, num := range nums {
        if seen[num] {
            return i
        }
        seen[num] = true
    }
    return -1
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>firstDuplicateIndex([]int{1, 2, 3, 2}) â†’ 3
firstDuplicateIndex([]int{1, 1, 2, 3}) â†’ 1
firstDuplicateIndex([]int{1, 2, 3}) â†’ -1</pre>
                </div>
            </div>
            </noscript>
            </div><!-- end challenges-container -->

            <h3 id="advanced" style="color: var(--purple); margin-top: 2rem;">ğŸš€ Advanced</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">These combine many concepts and introduce new Go features. Complete challenges first!</p>
            <div class="tip" style="margin-bottom: 1rem; padding: 0.75rem 1rem;">
                <strong>How to use this section:</strong> Each Advanced exercise has warm-up exercises above it. Do the warm-ups first (they teach the building blocks), then attempt the full exercise.
            </div>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-btn" onclick="shuffleVariants()" style="background: var(--bg-card); border: 1px solid var(--purple); color: var(--purple); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    ğŸ² Shuffle Variants
                </button>
            </div>

            <!-- Pre-exercises for Advanced 1 -->
            <div id="pre-exercises-container"></div>

            <!-- Advanced exercises will be dynamically loaded -->
            <div id="advanced-exercises-container">

            <!-- Fallback: Static exercise shown if JS fails -->
            <noscript>
            <div class="exercise">
                <h4>Advanced 1: Contains Duplicate</h4>
                <p>Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.</p>
                
                <details>
                    <summary>ğŸ“– Pre-reading: The "Have I Seen This?" Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                        
                        <strong>Naive approach (slow):</strong><br>
                        For each number, check every other number to see if it matches â†’ O(nÂ²)<br>
                        For 1000 numbers, that's 1,000,000 comparisons! ğŸŒ<br><br>
                        
                        <strong>Smart approach (fast):</strong><br>
                        Use a map to remember what you've seen â†’ O(n)<br>
                        For 1000 numbers, that's just 1000 operations! ğŸš€<br><br>
                        
                        <strong>The Pattern:</strong><br>
                        1. Create an empty map to track what you've seen<br>
                        2. For each element, check: "Have I seen this before?"<br>
                        3. If yes â†’ found a duplicate!<br>
                        4. If no â†’ remember it and continue
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 1: What to track</summary>
                    <div class="hint-content">
                        You need a map to remember which numbers you've already seen.<br><br>
                        
                        What should the map store?<br>
                        â€¢ <strong>Key:</strong> the number itself (<code>int</code>)<br>
                        â€¢ <strong>Value:</strong> we just need to know it exists... so <code>bool</code> works!<br><br>
                        
                        Create it with: <code>seen := make(map[int]bool)</code>
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 2: Checking if you've seen it</summary>
                    <div class="hint-content">
                        For each number in the slice:<br>
                        â€¢ Check: <code>if seen[num]</code> - is it in the map?<br>
                        â€¢ If <code>true</code>, you've seen it before â†’ return <code>true</code> (found duplicate!)<br>
                        â€¢ If <code>false</code>, mark it as seen: <code>seen[num] = true</code><br><br>
                        
                        This works because when a key doesn't exist in a map, Go returns the zero value for that type. For <code>bool</code>, the zero value is <code>false</code>.
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 3: What to return</summary>
                    <div class="hint-content">
                        If you make it through the entire loop without finding a duplicate, what does that mean?<br><br>
                        
                        All numbers are unique! Return <code>false</code> at the end.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func containsDuplicate(nums []int) bool {
    // Map to track what we've seen
    seen := make(map[int]bool)
    
    // Check each number
    for _, num := range nums {
        // Have we seen this before?
        if seen[num] {
            // Yes! Found a duplicate
            return true
        }
        // No, remember it for later
        seen[num] = true
    }
    
    // Made it through - no duplicates
    return false
}</pre>
                        <strong>Why this works:</strong><br>
                        The map acts as our "memory". Each time we see a number, we check our memory. If it's already there, we found a duplicate!<br><br>
                        
                        <strong>Note:</strong> We can simplify <code>if seen[num]</code> instead of <code>if _, ok := seen[num]; ok</code> because:<br>
                        â€¢ If the key exists, <code>seen[num]</code> returns <code>true</code><br>
                        â€¢ If the key doesn't exist, <code>seen[num]</code> returns <code>false</code> (the zero value for bool)<br>
                        â€¢ This works perfectly for our use case!<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - we only loop through once<br>
                        <strong>Space complexity:</strong> O(n) - worst case, store all unique numbers in map
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>containsDuplicate([]int{1, 2, 3, 1}) â†’ true
containsDuplicate([]int{1, 2, 3, 4}) â†’ false
containsDuplicate([]int{1, 1, 1, 1}) â†’ true</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 2: Remove Duplicates from Sorted Array</h4>
                <p>Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first part of the slice should contain the unique elements.</p>
                
                <details>
                    <summary>ğŸ“– Pre-reading: The Slow/Fast Pointer Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> Given <code>[1,1,2,2,3]</code>, modify it to <code>[1,2,3,_,_]</code> and return <code>3</code><br><br>
                        
                        <strong>Key insight:</strong> The array is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                        
                        <strong>The Slow/Fast Pattern:</strong><br>
                        This is a NEW variant of two-pointers you haven't seen yet:<br>
                        â€¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                        â€¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                        â€¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                        
                        <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(nums); fast++ {  // Initialize IN loop (read position)
    // Compare nums[fast] with nums[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>
                        
                        <strong>Why this structure?</strong><br>
                        â€¢ <code>slow</code> only moves when we find something to write (conditional)<br>
                        â€¢ <code>fast</code> always moves to keep reading (automatic)<br>
                        â€¢ This is different from <code>i, j</code> in challenges where both moved together!<br><br>
                        
                        <strong>Example walkthrough:</strong> [1,1,2,2,3]<br>
                        â€¢ Start: slow=0, fast=1<br>
                        â€¢ nums[1]=1 same as nums[0]=1? Yes â†’ skip (only fast moves)<br>
                        â€¢ fast=2: nums[2]=2 different from nums[0]=1? Yes â†’ slow++, write nums[2] to nums[1]<br>
                        â€¢ fast=3: nums[3]=2 same as nums[1]=2? Yes â†’ skip<br>
                        â€¢ fast=4: nums[4]=3 different from nums[1]=2? Yes â†’ slow++, write nums[4] to nums[2]<br>
                        â€¢ Result: [1,2,3,2,3], return slow+1 = 3
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 1: Edge cases and setup</summary>
                    <div class="hint-content">
                        <strong>Handle edge cases first:</strong><br>
                        What if the array is empty? Add this at the start:<br>
                        <code>if len(nums) == 0 { return 0 }</code><br><br>
                        
                        <strong>Setup:</strong><br>
                        Initialize <code>slow := 0</code> before the loop (first element is always unique)<br>
                        Start your loop with <code>fast := 1</code> (compare from second element onward)
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 2: When to write</summary>
                    <div class="hint-content">
                        Loop while <code>fast < len(nums)</code><br><br>
                        
                        At each step, compare <code>nums[fast]</code> with <code>nums[slow]</code>:<br>
                        â€¢ If they're <strong>different</strong>: found a new unique value!<br>
                          - Increment <code>slow</code><br>
                          - Write <code>nums[fast]</code> to <code>nums[slow]</code><br>
                        â€¢ If they're the <strong>same</strong>: it's a duplicate, skip it<br>
                        â€¢ Always increment <code>fast</code> to keep reading
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint 3: What to return</summary>
                    <div class="hint-content">
                        After the loop, <code>slow</code> points to the last unique element's index.<br><br>
                        
                        How many unique elements are there?<br>
                        Return <code>slow + 1</code> (because indices start at 0!)
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func removeDuplicates(nums []int) int {
    // Handle edge cases
    if len(nums) == 0 {
        return 0
    }
    
    // slow tracks where to write next unique value
    slow := 0
    
    // fast reads through the array
    for fast := 1; fast < len(nums); fast++ {
        // Found a new unique value?
        if nums[fast] != nums[slow] {
            slow++                    // Move write position
            nums[slow] = nums[fast]   // Write the unique value
        }
        // If same, just skip (fast++ happens automatically)
    }
    
    // slow points to last unique element
    // Number of unique elements is slow + 1
    return slow + 1
}</pre>
                        <strong>Visual walkthrough for [1,1,2,2,3]:</strong><br><br>
                        
                        <strong>Start:</strong> slow=0, fast=1<br>
                        Array: [<strong>1</strong>,1,2,2,3]<br><br>
                        
                        <strong>Step 1:</strong> nums[1]=1, nums[0]=1 â†’ same, skip<br>
                        slow=0, fast=2<br><br>
                        
                        <strong>Step 2:</strong> nums[2]=2, nums[0]=1 â†’ different!<br>
                        slow++ â†’ slow=1<br>
                        nums[1] = nums[2] â†’ nums[1] = 2<br>
                        Array: [1,<strong>2</strong>,2,2,3]<br>
                        fast=3<br><br>
                        
                        <strong>Step 3:</strong> nums[3]=2, nums[1]=2 â†’ same, skip<br>
                        slow=1, fast=4<br><br>
                        
                        <strong>Step 4:</strong> nums[4]=3, nums[1]=2 â†’ different!<br>
                        slow++ â†’ slow=2<br>
                        nums[2] = nums[4] â†’ nums[2] = 3<br>
                        Array: [1,2,<strong>3</strong>,2,3]<br><br>
                        
                        <strong>Done:</strong> return slow+1 = 3<br>
                        First 3 elements are unique: [1,2,3]<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - one pass through array<br>
                        <strong>Space complexity:</strong> O(1) - only use two pointers
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>removeDuplicates([]int{1, 1, 2}) â†’ 2 (array becomes [1, 2, _])
removeDuplicates([]int{0, 0, 1, 1, 2, 2, 3}) â†’ 4 (array becomes [0, 1, 2, 3, _, _, _])
removeDuplicates([]int{1, 2, 3}) â†’ 3 (no duplicates)</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 3: Reverse a String</h4>
                <p>Now write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.</p>
                
                <details>
                    <summary>ğŸ“– Pre-reading: Strings vs Runes in Go</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                        
                        For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                        But for Unicode (emoji ğŸ‰, Chinese ä¸–ç•Œ, Arabic, etc.), one character can be 2-4 bytes.<br><br>
                        
                        <strong>Example:</strong><br>
                        <code>"Hello"</code> = 5 bytes = 5 characters âœ…<br>
                        <code>"ä¸–ç•Œ"</code> = 6 bytes but only 2 characters! âš ï¸<br>
                        <code>"ğŸ‰"</code> = 4 bytes but only 1 character! âš ï¸<br><br>
                        
                        <strong>The Solution: Runes</strong><br>
                        A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                        Converting to <code>[]rune</code> splits the string into actual characters, not bytes.<br><br>
                        
                        <strong>Why you can't just reverse bytes:</strong><br>
                        "HiğŸ‰" as bytes = [72, 105, 240, 159, 142, 137]<br>
                        Reverse bytes = [137, 142, 159, 240, 105, 72] = gibberish! âŒ<br>
                        Must reverse as runes = ['ğŸ‰', 'i', 'H'] = "ğŸ‰iH" âœ…<br><br>
                        
                        ğŸ“š <strong>Learn more:</strong><br>
                        â€¢ <a href="https://go.dev/blog/strings" target="_blank" style="color: var(--green-bright);">Strings, bytes, runes (Go blog)</a>
                    </div>
                </details>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Combine what you learned:<br>
                        1. Convert string to <code>[]rune</code> with <code>[]rune(s)</code> - this handles Unicode properly<br>
                        2. Use the two-pointer reversal technique from Challenge 7: <code>for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1</code><br>
                        3. Swap elements: <code>runes[i], runes[j] = runes[j], runes[i]</code><br>
                        4. Convert back to string with <code>string(runes)</code>
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution with Step-by-Step Explanation</summary>
                    <div class="hint-content">
<pre>func reverse(s string) string {
    // Step 1: Convert to runes (handles Unicode properly)
    runes := []rune(s)
    
    // Step 2: Two-pointer reversal
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        // Swap characters at positions i and j
        runes[i], runes[j] = runes[j], runes[i]
    }
    
    // Step 3: Convert back to string
    return string(runes)
}</pre>
                        <strong>Visual walkthrough for "Go":</strong><br>
                        Start: <code>['G', 'o']</code>, i=0, j=1<br>
                        Swap: <code>['o', 'G']</code><br>
                        Update: i=1, j=0 â†’ i < j is false, stop âœ…<br><br>
                        
                        <strong>Visual walkthrough for "HiğŸ‰":</strong><br>
                        Start: <code>['H', 'i', 'ğŸ‰']</code>, i=0, j=2<br>
                        Iteration 1: Swap positions 0,2 â†’ <code>['ğŸ‰', 'i', 'H']</code><br>
                        Update: i=1, j=1 â†’ i < j is false, stop âœ…<br><br>
                        
                        <strong>Key Go syntax:</strong><br>
                        â€¢ <code>for a, b := x, y</code> - declare multiple variables<br>
                        â€¢ <code>a, b = b, a</code> - simultaneous swap (no temp variable needed!)<br>
                        â€¢ <code>string(runes)</code> - convert []rune back to string<br><br>
                        
                        ğŸ“š <strong>Learn more:</strong><br>
                        â€¢ <a href="https://go.dev/ref/spec#For_statements" target="_blank" style="color: var(--green-bright);">For loop syntax (Go spec)</a><br>
                        â€¢ <a href="https://go.dev/ref/spec#Assignments" target="_blank" style="color: var(--green-bright);">Assignment statements</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverse("hello") â†’ "olleh"
reverse("ä¸–ç•Œ") â†’ "ç•Œä¸–"
reverse("GoğŸš€") â†’ "ğŸš€oG"</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 4: Word Counter</h4>
                <p>Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.</p>

                <details>
                    <summary>ğŸ’¡ Step 1: Import and create map</summary>
                    <div class="hint-content">
<pre>import "strings"

counts := make(map[string]int)</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Split string into words</summary>
                    <div class="hint-content">
<pre>words := strings.Fields(s)
// "hello world" â†’ ["hello", "world"]</pre>
                        <code>strings.Fields</code> splits on any whitespace and handles multiple spaces.
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 3: Loop and count</summary>
                    <div class="hint-content">
<pre>for _, word := range words {
    counts[word]++  // Increment count for this word
}</pre>
                        The <code>++</code> works even for new keys (Go returns 0, then increments to 1).
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>import "strings"

func wordCount(s string) map[string]int {
    counts := make(map[string]int)
    for _, word := range strings.Fields(s) {
        counts[word]++
    }
    return counts
}</pre>
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>wordCount("the quick brown fox jumps over the lazy dog")
â†’ map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 5: Two Sum</h4>
                <p>Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code></p>

                <details>
                    <summary>ğŸ“– Pre-reading: The Complement Pattern</summary>
                    <div class="hint-content">
                        <strong>The Key Insight:</strong><br>
                        If target = 9 and current number = 2, we need to find 7 (the <em>complement</em>).<br>
                        Instead of searching the whole array for 7, just ask: "Have I seen 7 before?"<br>
                        Maps make this lookup instant!<br><br>

                        <strong>Why O(n) instead of O(nÂ²):</strong><br>
                        â€¢ Naive: For each number, check every other number â†’ n Ã— n comparisons<br>
                        â€¢ Smart: For each number, check map once â†’ n lookups
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 1: Create the map</summary>
                    <div class="hint-content">
<pre>seen := make(map[int]int)  // value â†’ index</pre>
                        We store valueâ†’index because we need to return the INDEX, not just the value.
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Loop with index</summary>
                    <div class="hint-content">
<pre>for i, num := range nums {
    complement := target - num
    // check and store here
}</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 3: Check then store (order matters!)</summary>
                    <div class="hint-content">
<pre>// Check FIRST: have we seen the complement?
if j, ok := seen[complement]; ok {
    return []int{j, i}  // Found it!
}
// Store AFTER: remember this number
seen[num] = i</pre>
                        Check before storing to avoid matching a number with itself.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution with Visual Walkthrough</summary>
                    <div class="hint-content">
<pre>func twoSum(nums []int, target int) []int {
    // Map to remember: number â†’ its index
    seen := make(map[int]int)
    
    // Loop through each number
    for i, num := range nums {
        // What number would complete the sum?
        complement := target - num
        
        // Have we seen that number before?
        if j, ok := seen[complement]; ok {
            // Yes! Return both indices
            return []int{j, i}
        }
        
        // No, remember this number for later
        seen[num] = i
    }
    
    // No solution found
    return nil
}</pre>
                        <strong>Visual walkthrough:</strong><br>
                        Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code><br><br>
                        
                        <strong>Iteration 1:</strong> i=0, num=2<br>
                        â€¢ complement = 9 - 2 = 7<br>
                        â€¢ Is 7 in seen? No<br>
                        â€¢ Add to map: seen = {2: 0}<br><br>
                        
                        <strong>Iteration 2:</strong> i=1, num=7<br>
                        â€¢ complement = 9 - 7 = 2<br>
                        â€¢ Is 2 in seen? Yes! (at index 0) âœ…<br>
                        â€¢ Return [0, 1]<br><br>
                        
                        <strong>Why this works:</strong><br>
                        When we're at 7, we look back and say "I've seen 2 before at index 0"<br>
                        2 + 7 = 9, so we return indices [0, 1]!<br><br>
                        
                        <strong>Key concepts used:</strong><br>
                        â€¢ <code>make(map[int]int)</code> - create empty map<br>
                        â€¢ <code>if j, ok := map[key]; ok</code> - check if key exists<br>
                        â€¢ <code>map[key] = value</code> - store in map<br>
                        â€¢ <code>[]int{a, b}</code> - create slice literal<br><br>
                        
                        ğŸ“š <strong>Learn more:</strong><br>
                        â€¢ <a href="https://go.dev/blog/maps" target="_blank" style="color: var(--green-bright);">Go maps in action</a><br>
                        â€¢ <a href="https://pkg.go.dev/builtin#make" target="_blank" style="color: var(--green-bright);">The make function</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>twoSum([]int{2, 7, 11, 15}, 9) â†’ [0, 1]
twoSum([]int{3, 2, 4}, 6) â†’ [1, 2]
twoSum([]int{3, 3}, 6) â†’ [0, 1]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 6: Sliding Window Maximum</h4>
                <p>Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code></p>

                <details>
                    <summary>ğŸ“– Pre-reading: The Sliding Window Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>
                        <strong>Naive approach (slow):</strong><br>
                        Check every possible subarray - O(nÂ²) or worse ğŸŒ<br><br>
                        <strong>Smart approach (fast):</strong><br>
                        Use a "window" that slides through the array - O(n) ğŸš€<br><br>
                        <strong>Two Types:</strong><br>
                        â€¢ <strong>Fixed-size:</strong> Window size k stays constant (add new, remove old)<br>
                        â€¢ <strong>Variable-size:</strong> Window grows and shrinks based on conditions
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 1: Calculate first window</summary>
                    <div class="hint-content">
<pre>// Sum the first k elements
windowSum := 0
for i := 0; i < k; i++ {
    windowSum += nums[i]
}
maxSum := windowSum</pre>
                    </div>
                </details>

                <details>
                    <summary>ğŸ’¡ Step 2: Slide the window</summary>
                    <div class="hint-content">
<pre>// For each new position, add the new element and remove the old
for i := k; i < len(nums); i++ {
    windowSum += nums[i] - nums[i-k]  // Add new, remove old
    if windowSum > maxSum {
        maxSum = windowSum
    }
}</pre>
                        The key insight: we don't re-sum the whole window, just adjust it!
                    </div>
                </details>

                <details>
                    <summary>âœ… Solution with Visual Walkthrough</summary>
                    <div class="hint-content">
<pre>func maxSumSubarray(nums []int, k int) int {
    if len(nums) < k {
        return 0
    }

    // Calculate sum of first window
    windowSum := 0
    for i := 0; i < k; i++ {
        windowSum += nums[i]
    }
    maxSum := windowSum

    // Slide the window
    for i := k; i < len(nums); i++ {
        windowSum += nums[i] - nums[i-k]  // Add new, remove old
        if windowSum > maxSum {
            maxSum = windowSum
        }
    }
    return maxSum
}</pre>
                        <strong>Visual walkthrough:</strong><br>
                        Input: <code>nums = [2, 1, 5, 1, 3, 2]</code>, <code>k = 3</code><br><br>

                        <strong>Initial window [0:3]:</strong> [2, 1, 5] â†’ sum = 8<br>
                        <strong>Slide to [1:4]:</strong> [1, 5, 1] â†’ 8 + 1 - 2 = 7<br>
                        <strong>Slide to [2:5]:</strong> [5, 1, 3] â†’ 7 + 3 - 1 = 9 â† max!<br>
                        <strong>Slide to [3:6]:</strong> [1, 3, 2] â†’ 9 + 2 - 5 = 6<br><br>

                        <strong>Why O(n)?</strong><br>
                        Each element is added once and removed once = 2n operations = O(n)
                    </div>
                </details>

                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>maxSumSubarray([]int{2, 1, 5, 1, 3, 2}, 3) â†’ 9 (subarray [5,1,3])
maxSumSubarray([]int{2, 3, 4, 1, 5}, 2) â†’ 7 (subarray [3,4])
maxSumSubarray([]int{1, 1, 1, 1}, 2) â†’ 2</pre>
                </div>
            </div>
            </noscript>
            </div><!-- end advanced-exercises-container -->

            <div class="tip">
                <div class="tip-title">Learning Path</div>
                <p><strong>Warmups</strong> â†’ master basic syntax<br>
                <strong>Intermediate</strong> â†’ learn one new concept at a time<br>
                <strong>Challenges</strong> â†’ 11 exercises in 4 blocks that build toward Advanced<br>
                <strong>Advanced</strong> â†’ 6 algorithm patterns with pre-exercises for scaffolding<br><br>
                <strong>Key bridges:</strong><br>
                â€¢ Challenge 7 (Count Occurrences) teaches the map pattern used in Advanced 1, 4, 5<br>
                â€¢ Challenge 11 (First Duplicate Index) directly prepares you for Advanced 1 & 5<br>
                â€¢ Challenges 8-10 build two-pointer skills for Advanced 2 & 3<br>
                â€¢ Advanced 6 (Sliding Window) is a critical interview pattern - common in LeetCode mediums!<br><br>
                Stuck? Check the tactical hints - they show you the code step by step!</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 1 Summary</h2>
            <h3>Core Concepts</h3>
            <ul>
                <li><strong>:=</strong> for declaration + assignment inside functions</li>
                <li><strong>Types:</strong> string, int, float64, bool (statically typed!)</li>
                <li><strong>Functions:</strong> <span class="inline-code">func name(params) returnType { }</span></li>
                <li><strong>Multiple returns:</strong> <span class="inline-code">func f() (int, error)</span></li>
                <li><strong>Slices:</strong> <span class="inline-code">[]Type{}</span> - dynamic arrays</li>
                <li><strong>Maps:</strong> <span class="inline-code">map[KeyType]ValueType{}</span> - like dictionaries</li>
            </ul>
            
            <h3>Key Patterns You Learned</h3>
            <ul>
                <li><strong>The "comma ok" idiom:</strong> <span class="inline-code">value, ok := map[key]</span> - check if a map key exists</li>
                <li><strong>Simultaneous assignment:</strong> <span class="inline-code">a, b = b, a</span> - swap without temp variable</li>
            </ul>
            
            <h3>Algorithm Patterns & When to Use Them</h3>
            <ul>
                <li><strong>Two-pointer (opposite ends):</strong> When you need to work from both ends toward the middle
                    <ul style="margin-top: 0.5rem;">
                        <li>Palindrome checking</li>
                        <li>Reversing arrays/strings</li>
                        <li>Pattern: <span class="inline-code">for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1</span></li>
                    </ul>
                </li>
                <li><strong>Slow/fast pointers:</strong> When one pointer reads and another writes, moving at different speeds
                    <ul style="margin-top: 0.5rem;">
                        <li>Removing duplicates from sorted arrays</li>
                        <li>In-place array modifications</li>
                        <li>Pattern: <span class="inline-code">slow := 0</span> outside, <span class="inline-code">for fast := 1; ...</span> inside</li>
                    </ul>
                </li>
                <li><strong>Map for tracking:</strong> When you need to remember "have I seen this before?"
                    <ul style="margin-top: 0.5rem;">
                        <li>Finding duplicates</li>
                        <li>Counting occurrences</li>
                        <li>Two Sum (storing complements)</li>
                        <li>Pattern: Check map first, then add to map if not found</li>
                    </ul>
                </li>
                <li><strong>Building slices with append:</strong> When you need to filter or transform data
                    <ul style="margin-top: 0.5rem;">
                        <li>Filtering even numbers</li>
                        <li>Collecting results dynamically</li>
                        <li>Pattern: Start with <span class="inline-code">result := []Type{}</span>, then <span class="inline-code">result = append(result, item)</span></li>
                    </ul>
                </li>
                <li><strong>Sliding window:</strong> When you need to find something optimal in a contiguous subarray
                    <ul style="margin-top: 0.5rem;">
                        <li>Max sum subarray of size k (fixed window)</li>
                        <li>Longest substring without repeating chars (variable window)</li>
                        <li>Pattern (fixed): Calculate first window, then slide by adding new element and subtracting old</li>
                        <li>Pattern (variable): Expand right pointer, shrink left when condition met/violated</li>
                    </ul>
                </li>
            </ul>
            
            <h3>Common Gotchas</h3>
            <ul>
                <li><strong>Missing map keys return zero values</strong> - use "comma ok" to check if key exists</li>
                <li><strong>Strings are bytes, not characters</strong> - use <span class="inline-code">[]rune(s)</span> for Unicode</li>
                <li><strong>Slices are references</strong> - modifying a slice modifies the original</li>
                <li><strong>:= only works inside functions</strong> - use <span class="inline-code">var</span> at package level</li>
            </ul>
            
            <h3>Next Steps</h3>
            <p style="color: var(--text-dim);">You now have the fundamentals to solve many LeetCode Easy problems! Module 2 will cover pointers, structs, and methods - the building blocks for more complex programs.</p>
        </div>

        <div class="nav-buttons">
            <a href="module0.html" class="nav-btn">â† Module 0</a>
            <a href="module2.html" class="nav-btn primary">Module 2: Pointers â†’</a>
        </div>
    </div>

    <script>
    // Variant system for exercises
    let variantsData = null;
    let currentVariants = {};  // For advanced exercises
    let currentChallengeVariants = {};  // For challenges
    let currentWarmupVariants = {};  // For warmups
    let currentIntermediateVariants = {};  // For intermediate

    // Links from concept names to lesson sections
    const conceptLinks = {
        "For Loops": "#lesson-loops",
        "If/Else": "#lesson-if",
        "Slices & Range": "#lesson-slices",
        "Maps": "#lesson-maps",
        "make() Function": "#lesson-slices",
        "Comma-Ok Pattern": "#lesson-comma-ok",
        "Range with Index": "#lesson-loops",
        "Building Slices": "#lesson-slices"
    };

    // Shared hints/pre-reading for each exercise type (these are the same across variants)
    const sharedContent = {
        advanced_1: {
            preReading: {
                title: 'ğŸ“– Pre-reading: The "Have I Seen This?" Pattern',
                content: `<strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                    <strong>Naive approach (slow):</strong><br>
                    For each element, check every other element to see if it matches â†’ O(nÂ²)<br>
                    For 1000 elements, that's 1,000,000 comparisons! ğŸŒ<br><br>
                    <strong>Smart approach (fast):</strong><br>
                    Use a map to remember what you've seen â†’ O(n)<br>
                    For 1000 elements, that's just 1000 operations! ğŸš€<br><br>
                    <strong>The Pattern:</strong><br>
                    1. Create an empty map to track what you've seen<br>
                    2. For each element, check: "Have I seen this before?"<br>
                    3. If yes â†’ found a duplicate!<br>
                    4. If no â†’ remember it and continue`
            },
            hints: [
                {
                    title: 'ğŸ’¡ Hint 1: What to track',
                    content: `You need a map to remember which elements you've already seen.<br><br>
                        What should the map store?<br>
                        â€¢ <strong>Key:</strong> the element itself<br>
                        â€¢ <strong>Value:</strong> we just need to know it exists... so <code>bool</code> works!<br><br>
                        Create it with: <code>seen := make(map[T]bool)</code> where T is your element type`
                },
                {
                    title: 'ğŸ’¡ Hint 2: Checking if you\'ve seen it',
                    content: `For each element in the collection:<br>
                        â€¢ Check: <code>if seen[element]</code> - is it in the map?<br>
                        â€¢ If <code>true</code>, you've seen it before â†’ found duplicate!<br>
                        â€¢ If <code>false</code>, mark it as seen: <code>seen[element] = true</code><br><br>
                        This works because when a key doesn't exist in a map, Go returns the zero value. For <code>bool</code>, that's <code>false</code>.`
                },
                {
                    title: 'ğŸ’¡ Hint 3: What to return',
                    content: `If you make it through the entire loop without finding a duplicate, what does that mean?<br><br>
                        All elements are unique! Return the appropriate boolean based on what the function asks.`
                }
            ]
        },
        advanced_2: {
            preReading: {
                title: 'ğŸ“– Pre-reading: The Slow/Fast Pointer Pattern',
                content: `<strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>
                    <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                    <strong>The Slow/Fast Pattern:</strong><br>
                    â€¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                    â€¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                    â€¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                    <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)
    // Compare items[fast] with items[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>`
            },
            hints: [
                {
                    title: 'ğŸ’¡ Hint 1: Edge cases and setup',
                    content: `<strong>Handle edge cases first:</strong><br>
                        What if the collection is empty? Return 0<br><br>
                        <strong>Setup:</strong><br>
                        Initialize <code>slow := 0</code> before the loop (first element is always unique)<br>
                        Start your loop with <code>fast := 1</code> (compare from second element onward)`
                },
                {
                    title: 'ğŸ’¡ Hint 2: When to write',
                    content: `At each step, compare the element at <code>fast</code> with element at <code>slow</code>:<br>
                        â€¢ If they're <strong>different</strong>: found a new unique value!<br>
                          - Increment <code>slow</code><br>
                          - Write element at <code>fast</code> to position <code>slow</code><br>
                        â€¢ If they're the <strong>same</strong>: it's a duplicate, skip it`
                },
                {
                    title: 'ğŸ’¡ Hint 3: What to return',
                    content: `After the loop, <code>slow</code> points to the last unique element's index.<br><br>
                        How many unique elements are there?<br>
                        Return <code>slow + 1</code> (because indices start at 0!)`
                }
            ]
        },
        advanced_3: {
            preReading: {
                title: 'ğŸ“– Pre-reading: Strings vs Runes in Go',
                content: `<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                    For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                    But for Unicode (emoji ğŸ‰, Chinese ä¸–ç•Œ, etc.), one character can be 2-4 bytes.<br><br>
                    <strong>Example:</strong><br>
                    <code>"Hello"</code> = 5 bytes = 5 characters âœ…<br>
                    <code>"ä¸–ç•Œ"</code> = 6 bytes but only 2 characters! âš ï¸<br>
                    <code>"ğŸ‰"</code> = 4 bytes but only 1 character! âš ï¸<br><br>
                    <strong>The Solution: Runes</strong><br>
                    A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                    Converting to <code>[]rune</code> splits the string into actual characters, not bytes.`
            },
            hints: [
                {
                    title: 'ğŸ’¡ Hint',
                    content: `Combine what you learned:<br>
                        1. Convert string to <code>[]rune</code> with <code>[]rune(s)</code> - this handles Unicode properly<br>
                        2. Use the two-pointer reversal technique: <code>for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1</code><br>
                        3. Swap elements: <code>runes[i], runes[j] = runes[j], runes[i]</code><br>
                        4. Convert back to string with <code>string(runes)</code>`
                }
            ]
        },
        advanced_4: {
            hints: [
                {
                    title: 'ğŸ’¡ New Concept: strings.Fields()',
                    content: `Go's <code>strings</code> package has useful functions. You need to import it:<br>
                        <code>import "strings"</code><br><br>
                        <code>strings.Fields(s)</code> splits a string on any whitespace and returns <code>[]string</code><br>
                        Example: <code>strings.Fields("hello world")</code> â†’ <code>["hello", "world"]</code>`
                },
                {
                    title: 'ğŸ’¡ Hint',
                    content: `1. Create a map with the appropriate types<br>
                        2. Loop through your collection<br>
                        3. Increment the count: <code>counts[item]++</code>`
                }
            ]
        },
        advanced_5: {
            preReading: {
                title: 'ğŸ“– Pre-reading: The Hash Map Complement Pattern',
                content: `<strong>The Naive Approach (slow):</strong><br>
                    Check every pair of numbers - requires nested loops O(nÂ²)<br><br>
                    <strong>The Smart Approach (fast):</strong><br>
                    Use a map to remember what you've seen - only one loop O(n)<br><br>
                    <strong>The Key Insight:</strong><br>
                    If target = 9 and current number = 2, we need to find 7.<br>
                    Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                    Maps make this lookup instant!`
            },
            hints: [
                {
                    title: 'ğŸ’¡ Strategy: The Map Lookup Pattern',
                    content: `For each element, ask: "Have I seen the element that would complete this sum?"<br>
                        If target is 9 and current element is 2, look for 7 in your map.<br>
                        If found â†’ return both indices!<br>
                        If not â†’ remember this element and its index for later`
                },
                {
                    title: 'ğŸ’¡ Hint',
                    content: `1. Create a map: <code>seen := make(map[int]int)</code> (element â†’ index)<br>
                        2. For each element, calculate: <code>complement := target - element</code><br>
                        3. Check: <code>if j, ok := seen[complement]; ok { return []int{j, i} }</code><br>
                        4. Store current: <code>seen[element] = i</code>`
                }
            ]
        },
        advanced_6: {
            preReading: {
                title: 'ğŸ“– Pre-reading: The Sliding Window Pattern',
                content: `<strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>
                    <strong>Naive approach (slow):</strong><br>
                    Check every possible subarray - O(nÂ²) or worse ğŸŒ<br><br>
                    <strong>Smart approach (fast):</strong><br>
                    Use a "window" that slides through the array - O(n) ğŸš€<br><br>
                    <strong>Two Types of Sliding Windows:</strong><br>
                    <strong>1. Fixed-size window:</strong> Window size k stays constant<br>
                    â€¢ Add the new element entering on the right<br>
                    â€¢ Subtract the element leaving on the left<br><br>
                    <strong>2. Variable-size window:</strong> Window grows and shrinks<br>
                    â€¢ Expand (move right pointer) to include more elements<br>
                    â€¢ Shrink (move left pointer) when condition is violated or met`
            },
            hints: [
                {
                    title: 'ğŸ’¡ Fixed Window Pattern',
                    content: `<strong>Step 1:</strong> Calculate initial window sum/state<br>
<pre>for i := 0; i < k; i++ {
    windowSum += nums[i]
}</pre>
                        <strong>Step 2:</strong> Slide the window<br>
<pre>for i := k; i < len(nums); i++ {
    windowSum += nums[i] - nums[i-k]  // Add new, remove old
    // Update max/min as needed
}</pre>`
                },
                {
                    title: 'ğŸ’¡ Variable Window Pattern',
                    content: `<strong>Template:</strong><br>
<pre>left := 0
for right := 0; right < len(nums); right++ {
    // Expand: add nums[right] to window state

    // Shrink: while condition violated
    for /* condition */ {
        // Remove nums[left] from window state
        left++
    }

    // Update answer (window is now valid)
}</pre>`
                }
            ]
        }
    };

    // Embedded variants data (works with file:// protocol)
    // These are DIFFERENT problems that test the same concepts, not just renamed variables
    const variantsDataEmbedded = {
      "intermediate": [
        { "id": "intermediate_1", "concept": "make() Function", "variants": [
          { "id": "v1", "title": "Make and Append to Slice", "description": "Create an empty slice using <code>make([]int, 0)</code>, add three numbers with <code>append</code>, then print its length.", "hints": ["<code>make([]int, 0)</code> creates an empty int slice", "<code>nums = append(nums, value)</code> adds to the slice"], "solution": "nums := make([]int, 0)\nnums = append(nums, 10)\nnums = append(nums, 20)\nnums = append(nums, 30)\nfmt.Println(len(nums))  // 3", "expected": "3" },
          { "id": "v2", "title": "Make an Empty Map", "description": "Create an empty map using <code>make(map[string]int)</code>, add three key-value pairs, then print its length.", "hints": ["<code>make(map[string]int)</code> creates an empty map", "<code>scores[\"alice\"] = 100</code> adds a key-value pair"], "solution": "scores := make(map[string]int)\nscores[\"alice\"] = 100\nscores[\"bob\"] = 85\nscores[\"carol\"] = 92\nfmt.Println(len(scores))  // 3", "expected": "3" },
          { "id": "v3", "title": "Append Multiple Values", "description": "Create an empty string slice, then use <code>append</code> to add multiple values at once. Print the slice.", "hints": ["<code>append</code> can take multiple values: <code>append(slice, a, b, c)</code>"], "solution": "words := make([]string, 0)\nwords = append(words, \"go\", \"is\", \"fun\")\nfmt.Println(words)  // [go is fun]", "expected": "[go is fun]" }
        ]},
        { "id": "intermediate_2", "concept": "Comma-Ok Pattern", "variants": [
          { "id": "v1", "title": "Check Map Key Exists", "description": "Create a map of fruit prices. Check if \"banana\" exists using the <code>value, ok := map[key]</code> pattern.", "hints": ["<code>price, ok := prices[\"banana\"]</code>", "<code>ok</code> is true if key exists, false otherwise"], "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"orange\": 2.00,\n}\n\nif price, ok := prices[\"banana\"]; ok {\n    fmt.Printf(\"Banana: $%.2f\\n\", price)\n} else {\n    fmt.Println(\"Banana not found\")\n}", "expected": "Banana not found" },
          { "id": "v2", "title": "Safe Map Lookup", "description": "Create a map of user ages. Safely look up a user that exists AND one that doesn't, printing appropriate messages.", "hints": ["Use <code>if age, ok := ages[name]; ok { ... } else { ... }</code>"], "solution": "ages := map[string]int{\"alice\": 30, \"bob\": 25}\n\nif age, ok := ages[\"alice\"]; ok {\n    fmt.Printf(\"Alice is %d\\n\", age)\n}\n\nif age, ok := ages[\"charlie\"]; ok {\n    fmt.Printf(\"Charlie is %d\\n\", age)\n} else {\n    fmt.Println(\"Charlie not found\")\n}", "expected": "Alice is 30\nCharlie not found" },
          { "id": "v3", "title": "Default Value Pattern", "description": "Create a map of stock counts. If an item doesn't exist, print \"Out of stock\" instead of 0.", "hints": ["Check with comma-ok before using the value"], "solution": "stock := map[string]int{\"apple\": 5, \"banana\": 0}\n\nitem := \"orange\"\nif count, ok := stock[item]; ok {\n    fmt.Printf(\"%s: %d in stock\\n\", item, count)\n} else {\n    fmt.Printf(\"%s: Out of stock\\n\", item)\n}", "expected": "orange: Out of stock" }
        ]},
        { "id": "intermediate_3", "concept": "Range with Index", "variants": [
          { "id": "v1", "title": "Print Index and Value", "description": "Create a slice of your favorite foods. Loop through and print both index and value: \"0: pizza\", \"1: tacos\", etc.", "hints": ["<code>for i, food := range foods</code> gives you both index and value"], "solution": "foods := []string{\"pizza\", \"tacos\", \"sushi\"}\nfor i, food := range foods {\n    fmt.Printf(\"%d: %s\\n\", i, food)\n}", "expected": "0: pizza\n1: tacos\n2: sushi" },
          { "id": "v2", "title": "Numbered List", "description": "Create a slice of task names. Print them as a numbered list starting from 1: \"1. Buy milk\", \"2. Walk dog\", etc.", "hints": ["Use <code>i+1</code> to start numbering from 1 instead of 0"], "solution": "tasks := []string{\"Buy milk\", \"Walk dog\", \"Code\"}\nfor i, task := range tasks {\n    fmt.Printf(\"%d. %s\\n\", i+1, task)\n}", "expected": "1. Buy milk\n2. Walk dog\n3. Code" },
          { "id": "v3", "title": "Find Element Index", "description": "Create a slice of colors. Find and print the index of \"green\" (or -1 if not found).", "hints": ["Loop with index, check if element matches"], "solution": "colors := []string{\"red\", \"blue\", \"green\", \"yellow\"}\ntarget := \"green\"\nresult := -1\n\nfor i, color := range colors {\n    if color == target {\n        result = i\n        break\n    }\n}\nfmt.Printf(\"Index of %s: %d\\n\", target, result)", "expected": "Index of green: 2" }
        ]},
        { "id": "intermediate_4", "concept": "Building Slices", "variants": [
          { "id": "v1", "title": "Collect Even Numbers", "description": "Create an empty slice, then loop 1-10 and append only even numbers. Print the result.", "hints": ["Check <code>if i%2 == 0</code>", "Use <code>append</code> inside the if block"], "solution": "evens := []int{}\nfor i := 1; i <= 10; i++ {\n    if i%2 == 0 {\n        evens = append(evens, i)\n    }\n}\nfmt.Println(evens)", "expected": "[2 4 6 8 10]" },
          { "id": "v2", "title": "Filter Long Words", "description": "Given <code>[]string{\"go\", \"python\", \"js\", \"rust\"}</code>, collect only words with 3+ characters into a new slice.", "hints": ["Check <code>if len(word) >= 3</code>"], "solution": "words := []string{\"go\", \"python\", \"js\", \"rust\"}\nlong := []string{}\nfor _, word := range words {\n    if len(word) >= 3 {\n        long = append(long, word)\n    }\n}\nfmt.Println(long)", "expected": "[python rust]" },
          { "id": "v3", "title": "Collect Multiples of 3", "description": "Create an empty slice, loop 1-15, and append only numbers divisible by 3. Print the result.", "hints": ["Check <code>if i%3 == 0</code>"], "solution": "multiples := []int{}\nfor i := 1; i <= 15; i++ {\n    if i%3 == 0 {\n        multiples = append(multiples, i)\n    }\n}\nfmt.Println(multiples)", "expected": "[3 6 9 12 15]" }
        ]}
      ],
      "warmups": [
        { "id": "warmup_1", "concept": "For Loops", "variants": [
          { "id": "v1", "title": "Print 1 to 10", "description": "Write a program that prints the numbers 1 to 10, one per line.", "hints": ["Use <code>for i := 1; i <= 10; i++</code>"], "solution": "for i := 1; i <= 10; i++ {\n    fmt.Println(i)\n}" },
          { "id": "v2", "title": "Countdown from 5", "description": "Write a program that counts down from 5 to 1, then prints \"Go!\"", "hints": ["Use <code>for i := 5; i >= 1; i--</code>", "Print \"Go!\" after the loop"], "solution": "for i := 5; i >= 1; i-- {\n    fmt.Println(i)\n}\nfmt.Println(\"Go!\")" },
          { "id": "v3", "title": "Print Even Numbers", "description": "Write a program that prints even numbers from 2 to 10.", "hints": ["Use <code>for i := 2; i <= 10; i += 2</code>"], "solution": "for i := 2; i <= 10; i += 2 {\n    fmt.Println(i)\n}" }
        ]},
        { "id": "warmup_2", "concept": "If/Else", "variants": [
          { "id": "v1", "title": "Check Number Sign", "description": "Write <code>func checkSign(n int) string</code> that returns \"positive\", \"negative\", or \"zero\".", "hints": ["Use <code>if n > 0</code>, then <code>else if n < 0</code>, then <code>else</code>"], "solution": "func checkSign(n int) string {\n    if n > 0 {\n        return \"positive\"\n    } else if n < 0 {\n        return \"negative\"\n    }\n    return \"zero\"\n}" },
          { "id": "v2", "title": "Pass or Fail", "description": "Write <code>func passOrFail(score int) string</code> that returns \"pass\" if score >= 60, else \"fail\".", "hints": ["Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"], "solution": "func passOrFail(score int) string {\n    if score >= 60 {\n        return \"pass\"\n    }\n    return \"fail\"\n}" },
          { "id": "v3", "title": "Age Category", "description": "Write <code>func ageCategory(age int) string</code> that returns \"child\" (< 13), \"teen\" (13-19), or \"adult\" (20+).", "hints": ["Chain if/else if/else based on age ranges"], "solution": "func ageCategory(age int) string {\n    if age < 13 {\n        return \"child\"\n    } else if age < 20 {\n        return \"teen\"\n    }\n    return \"adult\"\n}" }
        ]},
        { "id": "warmup_3", "concept": "Slices & Range", "variants": [
          { "id": "v1", "title": "Iterate Numbers", "description": "Create a slice with three numbers, then print each using <code>for range</code>.", "hints": ["Create: <code>nums := []int{7, 42, 99}</code>", "Loop: <code>for _, num := range nums</code>"], "solution": "nums := []int{7, 42, 99}\nfor _, num := range nums {\n    fmt.Println(num)\n}" },
          { "id": "v2", "title": "Iterate with Index", "description": "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc.", "hints": ["Loop with index: <code>for i, color := range colors</code>", "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"], "solution": "colors := []string{\"red\", \"blue\", \"green\"}\nfor i, color := range colors {\n    fmt.Printf(\"%d: %s\\n\", i, color)\n}" },
          { "id": "v3", "title": "Iterate Strings", "description": "Create a slice of your favorite foods, print each on its own line.", "hints": ["Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"], "solution": "foods := []string{\"pizza\", \"sushi\", \"tacos\"}\nfor _, food := range foods {\n    fmt.Println(food)\n}" }
        ]},
        { "id": "warmup_4", "concept": "Maps", "variants": [
          { "id": "v1", "title": "Ages Map", "description": "Create a map of names to ages, then print each person's name and age.", "hints": ["Map syntax: <code>map[string]int{\"alice\": 30}</code>", "Loop: <code>for name, age := range ages</code>"], "solution": "ages := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d\\n\", name, age)\n}" },
          { "id": "v2", "title": "Prices Map", "description": "Create a map of items to prices (float64), then print each item and price.", "hints": ["Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"], "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"banana\": 0.75,\n}\nfor item, price := range prices {\n    fmt.Printf(\"%s: $%.2f\\n\", item, price)\n}" },
          { "id": "v3", "title": "Capitals Map", "description": "Create a map of countries to their capitals, then print each pair.", "hints": ["Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"], "solution": "capitals := map[string]string{\n    \"France\": \"Paris\",\n    \"Japan\":  \"Tokyo\",\n}\nfor country, capital := range capitals {\n    fmt.Printf(\"%s: %s\\n\", country, capital)\n}" }
        ]}
      ],
      "challenges": [
        {
          "id": "challenge_1", "block": 1, "concept": "Accumulator Pattern",
          "variants": [
            { "id": "v1", "title": "Sum of Slice", "description": "Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.", "functionSignature": "func sum(numbers []int) int", "testCases": [{ "input": "[]int{1, 2, 3, 4, 5}", "output": "15" }], "hints": ["Create accumulator: <code>total := 0</code>", "Loop: <code>total += num</code>"], "solution": "func sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}" },
            { "id": "v2", "title": "Join Words", "description": "Write <code>func joinWords(words []string) string</code> that joins all words with spaces.", "functionSignature": "func joinWords(words []string) string", "testCases": [{ "input": "[]string{\"go\", \"is\", \"fun\"}", "output": "\"go is fun\"" }], "hints": ["String accumulator: <code>result := \"\"</code>", "Handle spacing: first word has no leading space"], "solution": "func joinWords(words []string) string {\n    result := \"\"\n    for i, word := range words {\n        if i > 0 {\n            result += \" \"\n        }\n        result += word\n    }\n    return result\n}" },
            { "id": "v3", "title": "Total String Length", "description": "Write <code>func totalLength(words []string) int</code> that returns total length of all strings.", "functionSignature": "func totalLength(words []string) int", "testCases": [{ "input": "[]string{\"go\", \"is\", \"fun\"}", "output": "7" }], "hints": ["Loop: <code>total += len(word)</code>"], "solution": "func totalLength(words []string) int {\n    total := 0\n    for _, word := range words {\n        total += len(word)\n    }\n    return total\n}" }
          ]
        },
        {
          "id": "challenge_2", "block": 1, "concept": "Counting with Condition",
          "variants": [
            { "id": "v1", "title": "Count Evens", "description": "Write <code>func countEvens(nums []int) int</code> that counts even numbers.", "functionSignature": "func countEvens(nums []int) int", "testCases": [{ "input": "[]int{1, 2, 3, 4, 5, 6}", "output": "3" }], "hints": ["Check: <code>if num%2 == 0 { count++ }</code>"], "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num%2 == 0 {\n            count++\n        }\n    }\n    return count\n}" },
            { "id": "v2", "title": "Count Negatives", "description": "Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.", "functionSignature": "func countNegatives(nums []int) int", "testCases": [{ "input": "[]int{-1, 2, -3, 4}", "output": "2" }], "hints": ["Check: <code>if num < 0 { count++ }</code>"], "solution": "func countNegatives(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num < 0 {\n            count++\n        }\n    }\n    return count\n}" },
            { "id": "v3", "title": "Count Long Words", "description": "Write <code>func countLong(words []string, minLen int) int</code> that counts words >= minLen.", "functionSignature": "func countLong(words []string, minLen int) int", "testCases": [{ "input": "[]string{\"go\", \"python\", \"js\"}, 3", "output": "1" }], "hints": ["Check: <code>if len(word) >= minLen</code>"], "solution": "func countLong(words []string, minLen int) int {\n    count := 0\n    for _, word := range words {\n        if len(word) >= minLen {\n            count++\n        }\n    }\n    return count\n}" }
          ]
        },
        {
          "id": "challenge_3", "block": 1, "concept": "Multiple Conditionals",
          "variants": [
            { "id": "v1", "title": "FizzBuzz", "description": "Print 1-20. Multiples of 3: \"Fizz\", 5: \"Buzz\", both: \"FizzBuzz\".", "functionSignature": "// loop", "testCases": [{ "input": "15", "output": "FizzBuzz" }], "hints": ["Check 15 first, then 3, then 5"], "solution": "for i := 1; i <= 20; i++ {\n    if i%15 == 0 {\n        fmt.Println(\"FizzBuzz\")\n    } else if i%3 == 0 {\n        fmt.Println(\"Fizz\")\n    } else if i%5 == 0 {\n        fmt.Println(\"Buzz\")\n    } else {\n        fmt.Println(i)\n    }\n}" },
            { "id": "v2", "title": "Grade Classifier", "description": "Write <code>func grade(score int) string</code> returning A/B/C/D/F.", "functionSignature": "func grade(score int) string", "testCases": [{ "input": "85", "output": "\"B\"" }], "hints": ["Check >= 90 first, then >= 80, etc."], "solution": "func grade(score int) string {\n    if score >= 90 { return \"A\" }\n    if score >= 80 { return \"B\" }\n    if score >= 70 { return \"C\" }\n    if score >= 60 { return \"D\" }\n    return \"F\"\n}" },
            { "id": "v3", "title": "Number Sign", "description": "Write <code>func sign(n int) string</code> returning positive/negative/zero.", "functionSignature": "func sign(n int) string", "testCases": [{ "input": "-5", "output": "\"negative\"" }], "hints": ["Three cases: > 0, < 0, == 0"], "solution": "func sign(n int) string {\n    if n > 0 { return \"positive\" }\n    if n < 0 { return \"negative\" }\n    return \"zero\"\n}" }
          ]
        },
        {
          "id": "challenge_4", "block": 1, "concept": "Finding Extrema",
          "variants": [
            { "id": "v1", "title": "Find Maximum", "description": "Write <code>func max(nums []int) int</code> that returns the largest number.", "functionSignature": "func max(nums []int) int", "testCases": [{ "input": "[]int{3, 7, 2, 9}", "output": "9" }], "hints": ["Start with nums[0], update if bigger"], "solution": "func max(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n > m { m = n }\n    }\n    return m\n}" },
            { "id": "v2", "title": "Find Minimum", "description": "Write <code>func min(nums []int) int</code> that returns the smallest number.", "functionSignature": "func min(nums []int) int", "testCases": [{ "input": "[]int{3, 7, 2, 9}", "output": "2" }], "hints": ["Start with nums[0], update if smaller"], "solution": "func min(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n < m { m = n }\n    }\n    return m\n}" },
            { "id": "v3", "title": "Longest String", "description": "Write <code>func longest(words []string) string</code> that returns the longest word.", "functionSignature": "func longest(words []string) string", "testCases": [{ "input": "[]string{\"go\", \"python\"}", "output": "\"python\"" }], "hints": ["Compare len(word) > len(result)"], "solution": "func longest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) > len(r) { r = w }\n    }\n    return r\n}" }
          ]
        },
        {
          "id": "challenge_5", "block": 2, "concept": "Filter with Append",
          "variants": [
            { "id": "v1", "title": "Filter Positives", "description": "Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.", "functionSignature": "func filterPositives(nums []int) []int", "testCases": [{ "input": "[]int{-2, 3, -1, 5}", "output": "[3, 5]" }], "hints": ["if num > 0 { result = append(result, num) }"], "solution": "func filterPositives(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > 0 { r = append(r, n) }\n    }\n    return r\n}" },
            { "id": "v2", "title": "Filter Evens", "description": "Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.", "functionSignature": "func filterEvens(nums []int) []int", "testCases": [{ "input": "[]int{1, 2, 3, 4}", "output": "[2, 4]" }], "hints": ["if num%2 == 0 { append }"], "solution": "func filterEvens(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n%2 == 0 { r = append(r, n) }\n    }\n    return r\n}" },
            { "id": "v3", "title": "Filter Short Words", "description": "Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.", "functionSignature": "func filterShort(words []string, max int) []string", "testCases": [{ "input": "[]string{\"go\", \"python\"}, 3", "output": "[\"go\"]" }], "hints": ["if len(word) <= max { append }"], "solution": "func filterShort(words []string, max int) []string {\n    r := []string{}\n    for _, w := range words {\n        if len(w) <= max { r = append(r, w) }\n    }\n    return r\n}" }
          ]
        },
        {
          "id": "challenge_6", "block": 2, "concept": "Find Index",
          "variants": [
            { "id": "v1", "title": "Find Index", "description": "Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.", "functionSignature": "func findIndex(nums []int, target int) int", "testCases": [{ "input": "[]int{10, 20, 30}, 20", "output": "1" }], "hints": ["for i, num := range nums { if num == target { return i } }"], "solution": "func findIndex(nums []int, target int) int {\n    for i, n := range nums {\n        if n == target { return i }\n    }\n    return -1\n}" },
            { "id": "v2", "title": "Find Word", "description": "Write <code>func findWord(words []string, target string) int</code> returning index or -1.", "functionSignature": "func findWord(words []string, target string) int", "testCases": [{ "input": "[]string{\"go\", \"py\"}, \"py\"", "output": "1" }], "hints": ["Same pattern with strings"], "solution": "func findWord(words []string, target string) int {\n    for i, w := range words {\n        if w == target { return i }\n    }\n    return -1\n}" },
            { "id": "v3", "title": "First Negative Index", "description": "Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.", "functionSignature": "func firstNegIdx(nums []int) int", "testCases": [{ "input": "[]int{5, -2, 3}", "output": "1" }], "hints": ["if num < 0 { return i }"], "solution": "func firstNegIdx(nums []int) int {\n    for i, n := range nums {\n        if n < 0 { return i }\n    }\n    return -1\n}" }
          ]
        },
        {
          "id": "challenge_7", "block": 2, "concept": "Map Counting",
          "variants": [
            { "id": "v1", "title": "Count Occurrences", "description": "Write <code>func countOccurrences(nums []int) map[int]int</code>.", "functionSignature": "func countOccurrences(nums []int) map[int]int", "testCases": [{ "input": "[]int{1, 2, 2, 3, 3, 3}", "output": "map[1:1 2:2 3:3]" }], "hints": ["counts := make(map[int]int)", "counts[num]++"], "solution": "func countOccurrences(nums []int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n]++ }\n    return c\n}" },
            { "id": "v2", "title": "Count Characters", "description": "Write <code>func countChars(s string) map[rune]int</code>.", "functionSignature": "func countChars(s string) map[rune]int", "testCases": [{ "input": "\"hello\"", "output": "map[e:1 h:1 l:2 o:1]" }], "hints": ["for _, char := range s { counts[char]++ }"], "solution": "func countChars(s string) map[rune]int {\n    c := make(map[rune]int)\n    for _, r := range s { c[r]++ }\n    return c\n}" },
            { "id": "v3", "title": "Word Frequency", "description": "Write <code>func wordFreq(words []string) map[string]int</code>.", "functionSignature": "func wordFreq(words []string) map[string]int", "testCases": [{ "input": "[]string{\"go\", \"go\", \"py\"}", "output": "map[go:2 py:1]" }], "hints": ["counts[word]++"], "solution": "func wordFreq(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words { c[w]++ }\n    return c\n}" }
          ]
        },
        {
          "id": "challenge_8", "block": 3, "concept": "Swap Pattern",
          "variants": [
            { "id": "v1", "title": "Swap Elements", "description": "Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.", "functionSignature": "func swap(nums []int, i, j int)", "testCases": [{ "input": "[]int{1,2,3}, 0, 2", "output": "[3,2,1]" }], "hints": ["nums[i], nums[j] = nums[j], nums[i]"], "solution": "func swap(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}" },
            { "id": "v2", "title": "Swap First Last", "description": "Write <code>func swapEnds(nums []int)</code> that swaps first and last elements.", "functionSignature": "func swapEnds(nums []int)", "testCases": [{ "input": "[]int{1,2,3,4}", "output": "[4,2,3,1]" }], "hints": ["nums[0], nums[len(nums)-1] = ..."], "solution": "func swapEnds(nums []int) {\n    nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n}" },
            { "id": "v3", "title": "Swap Variables", "description": "Swap two variables a=5, b=10 and print them.", "functionSignature": "// inline", "testCases": [{ "input": "a=5, b=10", "output": "a=10, b=5" }], "hints": ["a, b = b, a"], "solution": "a, b := 5, 10\na, b = b, a\nfmt.Println(a, b)" }
          ]
        },
        {
          "id": "challenge_9", "block": 3, "concept": "Two-Pointer Comparison",
          "variants": [
            { "id": "v1", "title": "Palindrome Check", "description": "Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.", "functionSignature": "func isPalindrome(nums []int) bool", "testCases": [{ "input": "[]int{1,2,3,2,1}", "output": "true" }], "hints": ["for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1", "if nums[i] != nums[j] { return false }"], "solution": "func isPalindrome(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}" },
            { "id": "v2", "title": "String Palindrome", "description": "Write <code>func isSymmetric(s string) bool</code>.", "functionSignature": "func isSymmetric(s string) bool", "testCases": [{ "input": "\"racecar\"", "output": "true" }], "hints": ["runes := []rune(s), then same pattern"], "solution": "func isSymmetric(s string) bool {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        if r[i] != r[j] { return false }\n    }\n    return true\n}" },
            { "id": "v3", "title": "Ends Match", "description": "Write <code>func endsMatch(nums []int) bool</code> - first equals last.", "functionSignature": "func endsMatch(nums []int) bool", "testCases": [{ "input": "[]int{5,2,3,5}", "output": "true" }], "hints": ["return nums[0] == nums[len(nums)-1]"], "solution": "func endsMatch(nums []int) bool {\n    return nums[0] == nums[len(nums)-1]\n}" }
          ]
        },
        {
          "id": "challenge_10", "block": 4, "concept": "Two-Pointer Swap",
          "variants": [
            { "id": "v1", "title": "Reverse Slice", "description": "Write <code>func reverse(nums []int) []int</code> that reverses in place.", "functionSignature": "func reverse(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3,4,5}", "output": "[5,4,3,2,1]" }], "hints": ["Palindrome loop + swap inside"], "solution": "func reverse(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    return nums\n}" },
            { "id": "v2", "title": "Rotate Left", "description": "Write <code>func rotateLeft(nums []int) []int</code> - first element goes to end.", "functionSignature": "func rotateLeft(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3}", "output": "[2,3,1]" }], "hints": ["Save first, shift left, put at end"], "solution": "func rotateLeft(nums []int) []int {\n    first := nums[0]\n    for i := 0; i < len(nums)-1; i++ { nums[i] = nums[i+1] }\n    nums[len(nums)-1] = first\n    return nums\n}" },
            { "id": "v3", "title": "Rotate Right", "description": "Write <code>func rotateRight(nums []int) []int</code> - last element goes to front.", "functionSignature": "func rotateRight(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3}", "output": "[3,1,2]" }], "hints": ["Save last, shift right, put at front"], "solution": "func rotateRight(nums []int) []int {\n    last := nums[len(nums)-1]\n    for i := len(nums)-1; i > 0; i-- { nums[i] = nums[i-1] }\n    nums[0] = last\n    return nums\n}" }
          ]
        },
        {
          "id": "challenge_11", "block": 4, "concept": "Map Lookup + Early Return",
          "variants": [
            { "id": "v1", "title": "First Duplicate Index", "description": "Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.", "functionSignature": "func firstDupIdx(nums []int) int", "testCases": [{ "input": "[]int{1,2,3,2}", "output": "3" }], "hints": ["seen := make(map[int]bool)", "if seen[num] { return i }; seen[num] = true"], "solution": "func firstDupIdx(nums []int) int {\n    seen := make(map[int]bool)\n    for i, n := range nums {\n        if seen[n] { return i }\n        seen[n] = true\n    }\n    return -1\n}" },
            { "id": "v2", "title": "First Repeat Char", "description": "Write <code>func firstRepeat(s string) rune</code> - first repeated char, or 0.", "functionSignature": "func firstRepeat(s string) rune", "testCases": [{ "input": "\"abcab\"", "output": "'a'" }], "hints": ["Same pattern with runes"], "solution": "func firstRepeat(s string) rune {\n    seen := make(map[rune]bool)\n    for _, r := range s {\n        if seen[r] { return r }\n        seen[r] = true\n    }\n    return 0\n}" },
            { "id": "v3", "title": "Has Duplicate", "description": "Write <code>func hasDup(nums []int) bool</code> - true if any number repeats.", "functionSignature": "func hasDup(nums []int) bool", "testCases": [{ "input": "[]int{1,2,3,2}", "output": "true" }], "hints": ["Same pattern, return true/false"], "solution": "func hasDup(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        if seen[n] { return true }\n        seen[n] = true\n    }\n    return false\n}" }
          ]
        }
      ],
      "advanced": [
        {
          "id": "advanced_1",
          "baseTitle": "Map as Set",
          "concept": "Map as Set - Have I Seen This?",
          "variants": [
            {
              "id": "v1",
              "title": "Contains Duplicate",
              "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
              "functionSignature": "func containsDuplicate(nums []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3, 1}", "output": "true" },
                { "input": "[]int{1, 2, 3, 4}", "output": "false" },
                { "input": "[]int{1, 1, 1, 1}", "output": "true" }
              ],
              "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}"
            },
            {
              "id": "v2",
              "title": "First Duplicate Value",
              "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
              "functionSignature": "func firstDuplicate(nums []int) int",
              "testCases": [
                { "input": "[]int{2, 1, 3, 5, 3, 2}", "output": "3", "note": "3 is seen again before 2 is" },
                { "input": "[]int{1, 2, 3, 4}", "output": "-1" },
                { "input": "[]int{1, 1, 2, 2}", "output": "1" }
              ],
              "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num  // Return the value, not just true\n        }\n        seen[num] = true\n    }\n    return -1\n}",
              "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!"
            },
            {
              "id": "v3",
              "title": "Count Unique Elements",
              "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
              "functionSignature": "func countUnique(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 3, 3, 3}", "output": "3", "note": "unique values: 1, 2, 3" },
                { "input": "[]int{5, 5, 5, 5}", "output": "1" },
                { "input": "[]int{1, 2, 3, 4, 5}", "output": "5" }
              ],
              "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
              "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!"
            },
            {
              "id": "v4",
              "title": "Find All Duplicates",
              "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
              "functionSignature": "func findDuplicates(nums []int) []int",
              "testCases": [
                { "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}", "output": "[2, 3]" },
                { "input": "[]int{1, 1, 2, 2, 3, 3}", "output": "[1, 2, 3]" },
                { "input": "[]int{1, 2, 3}", "output": "[]" }
              ],
              "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)  // Track what we've added to result\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
              "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result."
            },
            {
              "id": "v5",
              "title": "Common Elements",
              "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
              "functionSignature": "func hasCommon(a, b []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3}, []int{3, 4, 5}", "output": "true", "note": "3 is common" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "false" },
                { "input": "[]int{1}, []int{1}", "output": "true" }
              ],
              "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
              "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!"
            },
            {
              "id": "v6",
              "title": "Find Intersection",
              "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
              "functionSignature": "func intersection(a, b []int) []int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 1}, []int{2, 2}", "output": "[2]" },
                { "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}", "output": "[9, 4]", "note": "or [4, 9] - order doesn't matter" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "[]" }
              ],
              "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)  // Avoid duplicates in result\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
              "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result."
            }
          ]
        },
        {
          "id": "advanced_2",
          "baseTitle": "Two-Pointer In-Place",
          "concept": "Slow/Fast Pointer Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Remove Duplicates from Sorted Array",
              "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
              "functionSignature": "func removeDuplicates(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 2}", "output": "2", "note": "array becomes [1, 2, _]" },
                { "input": "[]int{0, 0, 1, 1, 2, 2, 3}", "output": "4", "note": "array becomes [0, 1, 2, 3, _, _, _]" },
                { "input": "[]int{1, 2, 3}", "output": "3" }
              ],
              "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}"
            },
            {
              "id": "v2",
              "title": "Remove Element",
              "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
              "functionSignature": "func removeElement(nums []int, val int) int",
              "testCases": [
                { "input": "[]int{3, 2, 2, 3}, 3", "output": "2", "note": "array becomes [2, 2, _, _]" },
                { "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2", "output": "5" },
                { "input": "[]int{1}, 1", "output": "0" }
              ],
              "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0."
            },
            {
              "id": "v3",
              "title": "Move Zeroes",
              "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
              "functionSignature": "func moveZeroes(nums []int)",
              "testCases": [
                { "input": "[]int{0, 1, 0, 3, 12}", "output": "[1, 3, 12, 0, 0]" },
                { "input": "[]int{0, 0, 1}", "output": "[1, 0, 0]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 2, 3]", "note": "no zeroes" }
              ],
              "solution": "func moveZeroes(nums []int) {\n    slow := 0  // Position to place next non-zero\n    \n    // Move all non-zeroes to the front\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    // Fill the rest with zeroes\n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
              "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!"
            },
            {
              "id": "v4",
              "title": "Remove Duplicates II (Allow 2)",
              "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
              "functionSignature": "func removeDuplicatesII(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1, 2, 2, 3}", "output": "5", "note": "becomes [1, 1, 2, 2, 3, _]" },
                { "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}", "output": "7" },
                { "input": "[]int{1, 1}", "output": "2" }
              ],
              "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2  // First two elements always kept\n    for fast := 2; fast < len(nums); fast++ {\n        // Compare with element two positions back\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2."
            },
            {
              "id": "v5",
              "title": "Sorted Squares",
              "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
              "functionSignature": "func sortedSquares(nums []int) []int",
              "testCases": [
                { "input": "[]int{-4, -1, 0, 3, 10}", "output": "[0, 1, 9, 16, 100]" },
                { "input": "[]int{-7, -3, 2, 3, 11}", "output": "[4, 9, 9, 49, 121]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 4, 9]" }
              ],
              "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1  // Fill from the end\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
              "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back."
            },
            {
              "id": "v6",
              "title": "Merge Sorted Array",
              "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
              "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
              "testCases": [
                { "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3", "output": "[1, 2, 2, 3, 5, 6]" },
                { "input": "[]int{1}, 1, []int{}, 0", "output": "[1]" },
                { "input": "[]int{0}, 0, []int{1}, 1", "output": "[1]" }
              ],
              "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    // Start from the end of both arrays\n    p1 := m - 1      // Last element in nums1's data\n    p2 := n - 1      // Last element in nums2\n    pos := m + n - 1 // Last position in nums1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
              "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place."
            }
          ]
        },
        {
          "id": "advanced_3",
          "baseTitle": "String Manipulation",
          "concept": "Runes + Two-Pointer Swap",
          "variants": [
            {
              "id": "v1",
              "title": "Reverse a String",
              "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
              "functionSignature": "func reverse(s string) string",
              "testCases": [
                { "input": "\"hello\"", "output": "\"olleh\"" },
                { "input": "\"ä¸–ç•Œ\"", "output": "\"ç•Œä¸–\"" },
                { "input": "\"GoğŸš€\"", "output": "\"ğŸš€oG\"" }
              ],
              "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
            },
            {
              "id": "v2",
              "title": "Is Palindrome",
              "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
              "functionSignature": "func isPalindrome(s string) bool",
              "testCases": [
                { "input": "\"A man, a plan, a canal: Panama\"", "output": "true" },
                { "input": "\"race a car\"", "output": "false" },
                { "input": "\"Was it a car or a cat I saw?\"", "output": "true" }
              ],
              "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification."
            },
            {
              "id": "v3",
              "title": "Reverse Words in String",
              "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
              "functionSignature": "func reverseWords(s string) string",
              "testCases": [
                { "input": "\"hello world\"", "output": "\"world hello\"" },
                { "input": "\"the sky is blue\"", "output": "\"blue is sky the\"" },
                { "input": "\"Go\"", "output": "\"Go\"" }
              ],
              "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    // Reverse the words slice\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
              "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together."
            },
            {
              "id": "v4",
              "title": "Reverse Only Letters",
              "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
              "functionSignature": "func reverseOnlyLetters(s string) string",
              "testCases": [
                { "input": "\"a-bC-dEf-ghIj\"", "output": "\"j-Ih-gfE-dCba\"" },
                { "input": "\"ab-cd\"", "output": "\"dc-ba\"" },
                { "input": "\"Test1ng-Leet=code-Q!\"", "output": "\"Qedo1teleC-test=gnin-T!\"", "note": "wait that's wrong" }
              ],
              "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        // Skip non-letters on left\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        // Skip non-letters on right\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        // Swap letters\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
              "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic."
            },
            {
              "id": "v5",
              "title": "Valid Palindrome II",
              "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
              "functionSignature": "func validPalindromeII(s string) bool",
              "testCases": [
                { "input": "\"aba\"", "output": "true", "note": "already palindrome" },
                { "input": "\"abca\"", "output": "true", "note": "remove 'c' or 'b'" },
                { "input": "\"abc\"", "output": "false" }
              ],
              "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            // Try skipping either character\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
              "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true."
            },
            {
              "id": "v6",
              "title": "Rotate String Left",
              "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
              "functionSignature": "func rotateLeft(s string, k int) string",
              "testCases": [
                { "input": "\"abcdef\", 2", "output": "\"cdefab\"" },
                { "input": "\"hello\", 1", "output": "\"elloh\"" },
                { "input": "\"Go\", 4", "output": "\"Go\"", "note": "k=4 is same as k=0 for len=2" }
              ],
              "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)  // Handle k > length\n    \n    // Reverse first k, reverse rest, reverse all\n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
              "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!"
            }
          ]
        },
        {
          "id": "advanced_4",
          "baseTitle": "Map Counting",
          "concept": "Map Counting Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Word Counter",
              "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
              "functionSignature": "func wordCount(s string) map[string]int",
              "testCases": [
                { "input": "\"the quick brown fox jumps over the lazy dog\"", "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]" }
              ],
              "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}"
            },
            {
              "id": "v2",
              "title": "Most Frequent Element",
              "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
              "functionSignature": "func mostFrequent(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 3, 2, 1, 4, 1}", "output": "1", "note": "1 appears 3 times" },
                { "input": "[]int{5, 5, 4, 4, 4}", "output": "4" },
                { "input": "[]int{7}", "output": "7" }
              ],
              "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
              "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures."
            },
            {
              "id": "v3",
              "title": "First Unique Character",
              "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
              "functionSignature": "func firstUniqChar(s string) int",
              "testCases": [
                { "input": "\"leetcode\"", "output": "0", "note": "'l' is first unique" },
                { "input": "\"loveleetcode\"", "output": "2", "note": "'v' is first unique" },
                { "input": "\"aabb\"", "output": "-1" }
              ],
              "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    // First pass: count all characters\n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    // Second pass: find first with count 1\n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
              "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order."
            },
            {
              "id": "v4",
              "title": "Is Anagram",
              "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
              "functionSignature": "func isAnagram(s, t string) bool",
              "testCases": [
                { "input": "\"anagram\", \"nagaram\"", "output": "true" },
                { "input": "\"rat\", \"car\"", "output": "false" },
                { "input": "\"listen\", \"silent\"", "output": "true" }
              ],
              "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have."
            },
            {
              "id": "v5",
              "title": "Can Construct",
              "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
              "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
              "testCases": [
                { "input": "\"a\", \"b\"", "output": "false" },
                { "input": "\"aa\", \"aab\"", "output": "true" },
                { "input": "\"aa\", \"ab\"", "output": "false", "note": "need 2 a's but only 1" }
              ],
              "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    // Count available letters\n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    // Try to use letters\n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa."
            },
            {
              "id": "v6",
              "title": "Majority Element",
              "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
              "functionSignature": "func majorityElement(nums []int) int",
              "testCases": [
                { "input": "[]int{3, 2, 3}", "output": "3" },
                { "input": "[]int{2, 2, 1, 1, 1, 2, 2}", "output": "2" },
                { "input": "[]int{1, 1, 1, 1}", "output": "1" }
              ],
              "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1  // Won't reach here per problem guarantee\n}",
              "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!"
            }
          ]
        },
        {
          "id": "advanced_5",
          "baseTitle": "Hash Map Lookup",
          "concept": "Hash Map Complement Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Two Sum",
              "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
              "functionSignature": "func twoSum(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[0, 1]" },
                { "input": "[]int{3, 2, 4}, 6", "output": "[1, 2]" },
                { "input": "[]int{3, 3}, 6", "output": "[0, 1]" }
              ],
              "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}"
            },
            {
              "id": "v2",
              "title": "Two Sum II (Sorted Input)",
              "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
              "functionSignature": "func twoSumSorted(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[1, 2]", "note": "1-indexed!" },
                { "input": "[]int{2, 3, 4}, 6", "output": "[1, 3]" },
                { "input": "[]int{-1, 0}, -1", "output": "[1, 2]" }
              ],
              "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}  // 1-indexed\n        } else if sum < target {\n            left++  // Need bigger sum\n        } else {\n            right--  // Need smaller sum\n        }\n    }\n    return nil\n}",
              "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum."
            },
            {
              "id": "v3",
              "title": "Pair with Difference",
              "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
              "functionSignature": "func pairWithDiff(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{5, 20, 3, 2, 50, 80}, 78", "output": "[1, 5]", "note": "80 - 2 = 78... wait" },
                { "input": "[]int{1, 5, 3}, 2", "output": "[0, 2]", "note": "3 - 1 = 2" },
                { "input": "[]int{1, 2, 3}, 10", "output": "nil" }
              ],
              "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)  // value -> index\n    \n    for i, num := range nums {\n        // Check if num - target exists (num is larger)\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        // Check if num + target exists (num is smaller)\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
              "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k)."
            },
            {
              "id": "v4",
              "title": "Count Pairs with Sum",
              "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
              "functionSignature": "func countPairs(nums []int, target int) int",
              "testCases": [
                { "input": "[]int{1, 5, 7, 1}, 6", "output": "2", "note": "(1,5) and (1,5)" },
                { "input": "[]int{1, 1, 1, 1}, 2", "output": "2", "note": "two pairs of 1+1" },
                { "input": "[]int{1, 2, 3}, 10", "output": "0" }
              ],
              "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            // Same number: count pairs within this group\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            // Different numbers: multiply counts (only count once via complement > num)\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
              "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting."
            },
            {
              "id": "v5",
              "title": "Three Sum Exists",
              "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
              "functionSignature": "func threeSumExists(nums []int) bool",
              "testCases": [
                { "input": "[]int{-1, 0, 1, 2}", "output": "true", "note": "-1 + 0 + 1 = 0" },
                { "input": "[]int{1, 2, 3}", "output": "false" },
                { "input": "[]int{0, 0, 0}", "output": "true" }
              ],
              "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        // Skip duplicates for i\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        // Two-pointer for remaining two numbers\n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
              "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(nÂ²) total."
            },
            {
              "id": "v6",
              "title": "Subarray Sum Equals K",
              "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
              "functionSignature": "func subarraySum(nums []int, k int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1}, 2", "output": "2", "note": "[1,1] at positions 0-1 and 1-2" },
                { "input": "[]int{1, 2, 3}, 3", "output": "2", "note": "[1,2] and [3]" },
                { "input": "[]int{1, -1, 0}, 0", "output": "3" }
              ],
              "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1  // Empty prefix has sum 0\n    \n    for _, num := range nums {\n        prefixSum += num\n        // If prefixSum - k exists, we found subarrays\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
              "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred."
            }
          ]
        },
        {
          "id": "advanced_6",
          "baseTitle": "Sliding Window",
          "concept": "Sliding Window Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Maximum Sum Subarray of Size K",
              "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
              "functionSignature": "func maxSumSubarray(nums []int, k int) int",
              "testCases": [
                { "input": "[]int{2, 1, 5, 1, 3, 2}, 3", "output": "9", "note": "subarray [5,1,3]" },
                { "input": "[]int{2, 3, 4, 1, 5}, 2", "output": "7", "note": "subarray [3,4]" },
                { "input": "[]int{1, 1, 1, 1}, 2", "output": "2" }
              ],
              "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    // Calculate sum of first window\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    // Slide the window\n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]  // Add new, remove old\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
              "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space."
            },
            {
              "id": "v2",
              "title": "Longest Substring Without Repeating",
              "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
              "functionSignature": "func lengthOfLongestSubstring(s string) int",
              "testCases": [
                { "input": "\"abcabcbb\"", "output": "3", "note": "\"abc\"" },
                { "input": "\"bbbbb\"", "output": "1", "note": "\"b\"" },
                { "input": "\"pwwkew\"", "output": "3", "note": "\"wke\"" }
              ],
              "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)  // char -> last index\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1  // Shrink window\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
              "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to."
            },
            {
              "id": "v3",
              "title": "Minimum Size Subarray Sum",
              "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
              "functionSignature": "func minSubarrayLen(target int, nums []int) int",
              "testCases": [
                { "input": "7, []int{2, 3, 1, 2, 4, 3}", "output": "2", "note": "[4,3] sums to 7" },
                { "input": "4, []int{1, 4, 4}", "output": "1", "note": "[4] alone >= 4" },
                { "input": "11, []int{1, 1, 1, 1}", "output": "0", "note": "can't reach 11" }
              ],
              "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1  // Impossible value\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        // Shrink window while sum >= target\n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
              "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern."
            }
          ]
        }
      ],
      "preExercises": {
        "advanced_1": {
          "title": "Pre-exercise: Map as a Set",
          "description": "Before tackling the algorithm, let's practice the core pattern: using a map to track what you've seen.",
          "exercises": [
            {
              "id": "pre1",
              "title": "Track Visited Pages",
              "problem": "You're building a browser history tracker. Write code that creates a <code>map[string]bool</code> called <code>visited</code>, marks three pages as visited, then checks if \"google.com\" has been visited.",
              "hints": [
                {
                  "title": "Creating the map",
                  "content": "Create with: <code>visited := make(map[string]bool)</code><br>This creates an empty map where keys are strings and values are booleans."
                },
                {
                  "title": "Marking as visited",
                  "content": "To mark a page as visited: <code>visited[\"google.com\"] = true</code><br>Do this for three different pages."
                },
                {
                  "title": "Checking if visited",
                  "content": "The simple way: <code>if visited[\"google.com\"]</code><br>This works because if the key doesn't exist, Go returns <code>false</code> (the zero value for bool)!"
                }
              ],
              "solution": "visited := make(map[string]bool)\n\n// Mark pages as visited\nvisited[\"google.com\"] = true\nvisited[\"github.com\"] = true\nvisited[\"go.dev\"] = true\n\n// Check if google.com was visited\nif visited[\"google.com\"] {\n    fmt.Println(\"You've been to google.com\")\n}\n\n// Check something NOT visited\nif visited[\"facebook.com\"] {\n    fmt.Println(\"You've been to facebook.com\")\n} else {\n    fmt.Println(\"Never visited facebook.com\")\n}",
              "expectedOutput": "You've been to google.com\nNever visited facebook.com",
              "keyInsight": "When you access a key that doesn't exist in a <code>map[T]bool</code>, Go returns <code>false</code>. This makes <code>if visited[key]</code> a clean way to check membership - no need for the comma-ok pattern here!"
            },
            {
              "id": "pre2",
              "title": "Unique Letter Collector",
              "problem": "Write code that loops through the string \"banana\" and collects each unique letter into a <code>map[rune]bool</code>. Print how many unique letters there are.",
              "hints": [
                {
                  "title": "Setup",
                  "content": "Create the map: <code>letters := make(map[rune]bool)</code><br>Loop with: <code>for _, char := range \"banana\"</code>"
                },
                {
                  "title": "Collecting",
                  "content": "For each character, just mark it as seen: <code>letters[char] = true</code><br>Maps automatically handle duplicates - setting the same key twice just overwrites."
                },
                {
                  "title": "Counting",
                  "content": "The number of unique letters is: <code>len(letters)</code>"
                }
              ],
              "solution": "letters := make(map[rune]bool)\n\nfor _, char := range \"banana\" {\n    letters[char] = true\n}\n\nfmt.Printf(\"Unique letters: %d\\n\", len(letters))  // 3: b, a, n",
              "expectedOutput": "Unique letters: 3",
              "keyInsight": "A map automatically handles duplicates - you can set the same key multiple times and it just overwrites. This is why <code>len(map)</code> gives you the count of unique keys!"
            }
          ]
        },
        "advanced_2": {
          "title": "Pre-exercise: Slow/Fast Pointer Prep",
          "description": "Before the in-place algorithm, let's practice the core logic of detecting duplicates in sorted arrays.",
          "exercises": [
            {
              "id": "pre2a",
              "title": "Copy Unique to New Slice",
              "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 3}</code>, create a NEW slice containing only the unique values <code>[1, 2, 3]</code>. Don't modify the original - just build a new one with <code>append</code>.",
              "hints": [
                {
                  "title": "Step 1: Setup",
                  "content": "<pre>nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element is always unique</pre>"
                },
                {
                  "title": "Step 2: Loop starting from index 1",
                  "content": "<pre>for i := 1; i < len(nums); i++ {\n    // Compare current with previous\n}</pre>"
                },
                {
                  "title": "Step 3: Append when different",
                  "content": "<pre>if nums[i] != nums[i-1] {\n    result = append(result, nums[i])\n}</pre>"
                }
              ],
              "solution": "nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element always unique\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        result = append(result, nums[i])\n    }\n}\n\nfmt.Println(result)  // [1 2 3]",
              "expectedOutput": "[1 2 3]",
              "keyInsight": "In a sorted array, duplicates are always adjacent! So we only need to compare each element with the one before it. This same logic powers the in-place algorithm - we'll just write to the array instead of appending."
            },
            {
              "id": "pre2b",
              "title": "Count Consecutive Groups",
              "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 2, 3}</code>, count how many distinct groups there are. Answer: 3 (the 1s, the 2s, and the 3).",
              "hints": [
                {
                  "title": "Step 1: Initialize counter",
                  "content": "<pre>nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group</pre>"
                },
                {
                  "title": "Step 2: Loop and count transitions",
                  "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}</pre>"
                }
              ],
              "solution": "nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}\n\nfmt.Printf(\"Groups: %d\\n\", groups)",
              "expectedOutput": "Groups: 3",
              "keyInsight": "This is exactly what the slow/fast algorithm returns! The slow pointer ends up at the last unique position, so slow+1 = number of unique elements = number of groups."
            }
          ]
        },
        "advanced_4": {
          "title": "Pre-exercise: Map Counting Prep",
          "description": "Before counting words, let's practice the building blocks: splitting strings and incrementing map values.",
          "exercises": [
            {
              "id": "pre4a",
              "title": "Explore strings.Fields",
              "problem": "Use <code>strings.Fields</code> to split the string <code>\"hello world go\"</code> into words and print each word on its own line.",
              "hints": [
                {
                  "title": "Step 1: Import and split",
                  "content": "<pre>import \"strings\"\n\nwords := strings.Fields(\"hello world go\")</pre>"
                },
                {
                  "title": "Step 2: Loop and print",
                  "content": "<pre>for _, word := range words {\n    fmt.Println(word)\n}</pre>"
                }
              ],
              "solution": "import \"strings\"\n\nwords := strings.Fields(\"hello world go\")\nfor _, word := range words {\n    fmt.Println(word)\n}",
              "expectedOutput": "hello\nworld\ngo",
              "keyInsight": "<code>strings.Fields</code> splits on any whitespace (spaces, tabs, newlines) and returns a <code>[]string</code>. It's smarter than <code>strings.Split(s, \" \")</code> because it handles multiple spaces correctly."
            },
            {
              "id": "pre4b",
              "title": "Count Letters (Simpler)",
              "problem": "Count how many times each letter appears in <code>\"hello\"</code>. Store in a <code>map[rune]int</code> and print the counts.",
              "hints": [
                {
                  "title": "Step 1: Create the map",
                  "content": "<pre>counts := make(map[rune]int)</pre>"
                },
                {
                  "title": "Step 2: Loop through string",
                  "content": "<pre>for _, char := range \"hello\" {\n    counts[char]++\n}</pre>"
                },
                {
                  "title": "Step 3: Print results",
                  "content": "<pre>for char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}</pre>"
                }
              ],
              "solution": "counts := make(map[rune]int)\n\nfor _, char := range \"hello\" {\n    counts[char]++\n}\n\nfor char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}",
              "expectedOutput": "h: 1\ne: 1\nl: 2\no: 1",
              "keyInsight": "The <code>++</code> operator works on map values! When the key doesn't exist, Go returns 0 (the zero value for int), then increments to 1. So <code>counts[char]++</code> handles both first-time and repeat cases."
            }
          ]
        },
        "advanced_5": {
          "title": "Pre-exercise: Two Sum Building Blocks",
          "description": "Before the full algorithm, let's practice the two key operations: looking up complements and building index maps.",
          "exercises": [
            {
              "id": "pre5a",
              "title": "Find Complement in Map",
              "problem": "Given this pre-built map <code>map[int]int{2: 0, 7: 1, 11: 2}</code> (value to index), target=9, and current number=7: calculate the complement and check if it exists in the map. Print the result.",
              "hints": [
                {
                  "title": "Step 1: Setup",
                  "content": "<pre>seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7</pre>"
                },
                {
                  "title": "Step 2: Calculate complement",
                  "content": "<pre>complement := target - num  // 9 - 7 = 2</pre>"
                },
                {
                  "title": "Step 3: Check map with comma-ok",
                  "content": "<pre>if idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found! %d is at index %d\\n\", complement, idx)\n}</pre>"
                }
              ],
              "solution": "seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7\n\ncomplement := target - num  // 9 - 7 = 2\n\nif idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found %d at index %d\\n\", complement, idx)\n} else {\n    fmt.Println(\"Not found\")\n}",
              "expectedOutput": "Found 2 at index 0",
              "keyInsight": "The complement is <code>target - current</code>. If we're looking for two numbers that sum to 9, and we have 7, we need to find 2. The map tells us WHERE we saw the 2 (at index 0)."
            },
            {
              "id": "pre5b",
              "title": "Build Value-to-Index Map",
              "problem": "Given <code>[]int{2, 7, 11}</code>, build a map that maps each value to its index: <code>map[int]int{2: 0, 7: 1, 11: 2}</code>.",
              "hints": [
                {
                  "title": "Step 1: Create empty map",
                  "content": "<pre>nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)</pre>"
                },
                {
                  "title": "Step 2: Loop with index",
                  "content": "<pre>for i, num := range nums {\n    valueToIndex[num] = i\n}</pre>"
                }
              ],
              "solution": "nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)\n\nfor i, num := range nums {\n    valueToIndex[num] = i\n}\n\nfmt.Println(valueToIndex)",
              "expectedOutput": "map[2:0 7:1 11:2]",
              "keyInsight": "The Two Sum algorithm builds this map AS it loops - checking for the complement first, then adding the current number. This ensures we don't match a number with itself!"
            }
          ]
        },
        "advanced_6": {
          "title": "Pre-exercise: Sliding Window Fundamentals",
          "description": "Before tackling sliding window problems, let's practice the core mechanics: managing a window and efficiently updating its state.",
          "exercises": [
            {
              "id": "pre6a",
              "title": "Fixed Window Sum",
              "problem": "Given <code>[]int{1, 2, 3, 4, 5}</code> and window size k=3, calculate the sum of the first window [1,2,3], then slide it one position and calculate the new sum [2,3,4] WITHOUT re-summing all elements.",
              "hints": [
                {
                  "title": "Step 1: Calculate first window sum",
                  "content": "<pre>nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first k elements\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Println(windowSum)  // 6</pre>"
                },
                {
                  "title": "Step 2: Slide the window",
                  "content": "<pre>// The trick: add new element, subtract old element\n// New element is at index k (which is 3)\n// Old element is at index 0\nwindowSum = windowSum + nums[k] - nums[0]</pre>"
                },
                {
                  "title": "Step 3: General formula",
                  "content": "When sliding from position i-1 to i:<pre>windowSum = windowSum + nums[i+k-1] - nums[i-1]</pre>Or equivalently, when the right edge moves to index i:<pre>windowSum = windowSum + nums[i] - nums[i-k]</pre>"
                }
              ],
              "solution": "nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first window\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Printf(\"Window [0:3] sum: %d\\n\", windowSum)  // 6\n\n// Slide window: add nums[3], remove nums[0]\nwindowSum = windowSum + nums[3] - nums[0]\nfmt.Printf(\"Window [1:4] sum: %d\\n\", windowSum)  // 9\n\n// Slide again: add nums[4], remove nums[1]\nwindowSum = windowSum + nums[4] - nums[1]\nfmt.Printf(\"Window [2:5] sum: %d\\n\", windowSum)  // 12",
              "expectedOutput": "Window [0:3] sum: 6\nWindow [1:4] sum: 9\nWindow [2:5] sum: 12",
              "keyInsight": "The sliding window trick: instead of recalculating the entire sum (O(k)), just add the new element and subtract the leaving element (O(1)). This makes processing all windows O(n) instead of O(n*k)!"
            },
            {
              "id": "pre6b",
              "title": "Variable Window with Map",
              "problem": "Track characters in a variable-size window. Given string \"abca\", add characters one by one to a <code>map[byte]int</code> (tracking counts), then simulate shrinking by decrementing counts.",
              "hints": [
                {
                  "title": "Step 1: Setup and expand",
                  "content": "<pre>s := \"abca\"\nseen := make(map[byte]int)\n\n// Add each character (expanding window)\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n    fmt.Printf(\"Added %c, counts: %v\\n\", s[i], seen)\n}</pre>"
                },
                {
                  "title": "Step 2: Shrink from left",
                  "content": "<pre>// Remove the first character (shrink)\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])  // Clean up zero counts\n}\nfmt.Printf(\"After removing %c: %v\\n\", s[0], seen)</pre>"
                }
              ],
              "solution": "s := \"abca\"\nseen := make(map[byte]int)\n\n// Expand: add all characters\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n}\nfmt.Printf(\"Full window: %v\\n\", seen)  // a:2, b:1, c:1\n\n// Shrink: remove from left (index 0 = 'a')\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])\n}\nfmt.Printf(\"After removing s[0]: %v\\n\", seen)  // a:1, b:1, c:1\n\n// Shrink more: remove s[1] = 'b'\nseen[s[1]]--\nif seen[s[1]] == 0 {\n    delete(seen, s[1])\n}\nfmt.Printf(\"After removing s[1]: %v\\n\", seen)  // a:1, c:1",
              "expectedOutput": "Full window: map[97:2 98:1 99:1]\nAfter removing s[0]: map[97:1 98:1 99:1]\nAfter removing s[1]: map[97:1 99:1]",
              "keyInsight": "Variable sliding windows use a map to track what's in the window. When expanding (right pointer moves), increment counts. When shrinking (left pointer moves), decrement counts. Delete keys when count hits 0 to keep the map clean."
            }
          ]
        }
      }
    };

    function loadVariants() {
        variantsData = variantsDataEmbedded;
        shuffleWarmups();
        shuffleIntermediate();
        shuffleChallenges();
        shuffleVariants();
    }

    function shuffleWarmups() {
        if (!variantsData || !variantsData.warmups) return;

        // Pick a random variant for each warmup
        variantsData.warmups.forEach(warmup => {
            const current = currentWarmupVariants[warmup.id];
            const available = warmup.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : warmup.variants;
            currentWarmupVariants[warmup.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderWarmups();

        // Visual feedback
        const btn = document.getElementById('shuffle-warmups-btn');
        if (btn) {
            btn.textContent = 'âœ“ Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            setTimeout(() => {
                btn.textContent = 'ğŸ² Shuffle';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--green-bright)';
            }, 800);
        }
    }

    function renderWarmups() {
        const container = document.getElementById('warmups-container');
        if (!container || !variantsData || !variantsData.warmups) return;

        let html = '';

        variantsData.warmups.forEach((warmup, idx) => {
            const variant = currentWarmupVariants[warmup.id];
            const num = idx + 1;

            const conceptLink = conceptLinks[warmup.concept];
            const conceptHtml = conceptLink
                ? `<a href="${conceptLink}" class="concept-link" style="color: var(--green-dim); opacity: 0.8;">(${warmup.concept} â†—)</a>`
                : `<span style="font-size: 0.75rem; opacity: 0.6; color: var(--text-dim);">(${warmup.concept})</span>`;

            html += `<div class="exercise">
                <h4>Warmup ${num}: ${variant.title} ${conceptHtml}</h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint, hIdx) => {
                    html += `<details>
                        <summary>ğŸ’¡ Hint${variant.hints.length > 1 ? ' ' + (hIdx + 1) : ''}</summary>
                        <div class="hint-content">${hint}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>âœ… Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function shuffleIntermediate() {
        if (!variantsData || !variantsData.intermediate) return;

        // Pick a random variant for each intermediate exercise
        variantsData.intermediate.forEach(exercise => {
            const current = currentIntermediateVariants[exercise.id];
            const available = exercise.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : exercise.variants;
            currentIntermediateVariants[exercise.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderIntermediate();

        // Visual feedback
        const btn = document.getElementById('shuffle-intermediate-btn');
        if (btn) {
            btn.textContent = 'âœ“ Shuffled!';
            btn.style.background = 'var(--cyan)';
            btn.style.color = 'var(--bg-dark)';
            setTimeout(() => {
                btn.textContent = 'ğŸ² Shuffle';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--cyan)';
            }, 800);
        }
    }

    function renderIntermediate() {
        const container = document.getElementById('intermediate-container');
        if (!container || !variantsData || !variantsData.intermediate) return;

        let html = '';

        variantsData.intermediate.forEach((exercise, idx) => {
            const variant = currentIntermediateVariants[exercise.id];
            const num = idx + 1;

            const conceptLink = conceptLinks[exercise.concept];
            const conceptHtml = conceptLink
                ? `<a href="${conceptLink}" class="concept-link" style="color: var(--cyan); opacity: 0.8;">(${exercise.concept} â†—)</a>`
                : `<span style="font-size: 0.75rem; opacity: 0.6; color: var(--text-dim);">(${exercise.concept})</span>`;

            html += `<div class="exercise">
                <h4>Intermediate ${num}: ${variant.title} ${conceptHtml}</h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint, hIdx) => {
                    html += `<details>
                        <summary>ğŸ’¡ Hint${variant.hints.length > 1 ? ' ' + (hIdx + 1) : ''}</summary>
                        <div class="hint-content">${hint}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>âœ… Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            // Add expected output if available
            if (variant.expected) {
                html += `<div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>${escapeHtml(variant.expected)}</pre>
                </div>`;
            }

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function shuffleChallenges() {
        if (!variantsData || !variantsData.challenges) return;

        // Pick a random variant for each challenge
        variantsData.challenges.forEach(challenge => {
            const current = currentChallengeVariants[challenge.id];
            const available = challenge.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : challenge.variants;
            currentChallengeVariants[challenge.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderChallenges();

        // Visual feedback
        const btn = document.getElementById('shuffle-challenges-btn');
        if (btn) {
            btn.textContent = 'âœ“ Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            btn.style.borderColor = 'var(--green-bright)';
            setTimeout(() => {
                btn.textContent = 'ğŸ² Shuffle Challenges';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--orange)';
                btn.style.borderColor = 'var(--orange)';
            }, 800);
        }
    }

    function renderChallenges() {
        const container = document.getElementById('challenges-container');
        if (!container || !variantsData || !variantsData.challenges) return;

        let html = '';
        let currentBlock = 0;
        const blockNames = { 1: 'Core Patterns', 2: 'Building & Filtering', 3: 'Two-Pointer Foundation', 4: 'Two-Pointer Application' };
        const blockDifficulty = { 1: 'â­', 2: 'â­â­', 3: 'â­â­', 4: 'â­â­â­' };

        variantsData.challenges.forEach((challenge, idx) => {
            const variant = currentChallengeVariants[challenge.id];
            const num = idx + 1;
            const difficulty = blockDifficulty[challenge.block];

            // Add block header if new block
            if (challenge.block !== currentBlock) {
                currentBlock = challenge.block;
                html += `<p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block ${currentBlock}: ${blockNames[currentBlock]} <span style="opacity: 0.7">${difficulty}</span></p>`;
            }

            html += `<div class="exercise">
                <h4>Challenge ${num}: ${variant.title} <span style="font-size: 0.75rem; opacity: 0.6;">${difficulty}</span></h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint, hIdx) => {
                    html += `<details>
                        <summary>ğŸ’¡ Hint ${hIdx + 1}</summary>
                        <div class="hint-content">${hint}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>âœ… Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${variant.testCases.map(tc =>
                    `${tc.input} â†’ ${tc.output}`
                ).join('\n')}</pre>
            </div></div>`;
        });

        container.innerHTML = html;
    }

    function shuffleVariants() {
        if (!variantsData) return;

        // Pick a DIFFERENT random variant for each exercise
        variantsData.advanced.forEach(exercise => {
            const currentVariant = currentVariants[exercise.id];
            const availableVariants = exercise.variants.filter(v =>
                !currentVariant || v.id !== currentVariant.id
            );
            // If all variants exhausted (only 1), just pick randomly
            const pool = availableVariants.length > 0 ? availableVariants : exercise.variants;
            const randomIndex = Math.floor(Math.random() * pool.length);
            currentVariants[exercise.id] = pool[randomIndex];
        });

        renderExercises();

        // Visual feedback - flash the button
        const btn = document.getElementById('shuffle-btn');
        if (btn) {
            btn.textContent = 'âœ“ Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            btn.style.borderColor = 'var(--green-bright)';
            setTimeout(() => {
                btn.textContent = 'ğŸ² Shuffle Variants';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--purple)';
                btn.style.borderColor = 'var(--purple)';
            }, 800);
        }
    }

    function renderExercises() {
        const container = document.getElementById('advanced-exercises-container');
        if (!container) return;

        let html = '';

        // Render each advanced exercise with its pre-exercises
        variantsData.advanced.forEach((exercise, idx) => {
            const variant = currentVariants[exercise.id];
            const shared = sharedContent[exercise.id];
            const num = idx + 1;

            // Render pre-exercises for this specific advanced exercise (if any)
            html += renderPreExercisesFor(exercise.id, num, variant.title);

            html += `<div class="exercise">
                <h4>Advanced ${num}: ${variant.title}</h4>
                <p>${variant.description}</p>`;

            // Add pre-reading if available
            if (shared && shared.preReading) {
                html += `<details>
                    <summary>${shared.preReading.title}</summary>
                    <div class="hint-content">${shared.preReading.content}</div>
                </details>`;
            }

            // Add hints
            if (shared && shared.hints) {
                shared.hints.forEach(hint => {
                    html += `<details>
                        <summary>${hint.title}</summary>
                        <div class="hint-content">${hint.content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>âœ… Solution with Explanation</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(variant.solution)}</pre>
                    ${variant.solutionNotes ? `<br>${variant.solutionNotes}` : ''}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${variant.testCases.map(tc =>
                    `${variant.functionSignature.match(/func (\w+)/)[1]}(${tc.input}) â†’ ${tc.output}${tc.note ? ` (${tc.note})` : ''}`
                ).join('\n')}</pre>
            </div>`;

            html += '</div>';

            // Add section divider (except after last exercise)
            if (idx < variantsData.advanced.length - 1) {
                html += `<hr style="border: none; border-top: 2px dashed var(--bg-lighter); margin: 3rem 0;">`;
            }
        });

        container.innerHTML = html;
    }

    function renderPreExercisesFor(advancedId, advancedNum, advancedTitle) {
        if (!variantsData.preExercises || !variantsData.preExercises[advancedId]) {
            return '';
        }

        const preEx = variantsData.preExercises[advancedId];
        let html = `
            <div style="background: linear-gradient(135deg, rgba(157, 0, 255, 0.15), rgba(157, 0, 255, 0.05)); border: 2px solid var(--purple); border-radius: 8px; padding: 1.5rem; margin: 2rem 0 1rem 0;">
                <div style="color: var(--purple); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem;">â¬‡ï¸ Warm up for Advanced ${advancedNum}</div>
                <div style="color: var(--text); font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">ğŸ¯ ${preEx.title}</div>
                <p style="color: var(--text-dim); margin: 0;">${preEx.description}</p>
            </div>`;

        preEx.exercises.forEach((ex, idx) => {
            html += `<div class="exercise" style="border-color: var(--purple); margin-bottom: 1.5rem;">
                <h4 style="color: var(--purple);">Warm-up ${advancedNum}.${idx + 1}: ${ex.title}</h4>
                <p>${ex.problem}</p>`;

            // Add hints
            ex.hints.forEach(hint => {
                html += `<details>
                    <summary>ğŸ’¡ ${hint.title}</summary>
                    <div class="hint-content">${hint.content}</div>
                </details>`;
            });

            // Add solution
            html += `<details>
                <summary>âœ… Solution</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(ex.solution)}</pre>
                    <br><strong>Key insight:</strong> ${ex.keyInsight}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${escapeHtml(ex.expectedOutput)}</pre>
            </div>`;

            html += '</div>';
        });

        // Add transition to main exercise
        html += `
            <div style="text-align: center; margin: 1.5rem 0; color: var(--purple); font-weight: 600;">
                â¬‡ï¸ Now try the full exercise â¬‡ï¸
            </div>`;

        return html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Load variants on page load
    document.addEventListener('DOMContentLoaded', loadVariants);

    // Style the shuffle buttons hover
    document.addEventListener('DOMContentLoaded', () => {
        const advBtn = document.getElementById('shuffle-btn');
        if (advBtn) {
            advBtn.addEventListener('mouseenter', () => {
                advBtn.style.background = 'var(--purple)';
                advBtn.style.color = 'white';
            });
            advBtn.addEventListener('mouseleave', () => {
                advBtn.style.background = 'var(--bg-card)';
                advBtn.style.color = 'var(--purple)';
            });
        }

        const chalBtn = document.getElementById('shuffle-challenges-btn');
        if (chalBtn) {
            chalBtn.addEventListener('mouseenter', () => {
                chalBtn.style.background = 'var(--orange)';
                chalBtn.style.color = 'white';
            });
            chalBtn.addEventListener('mouseleave', () => {
                chalBtn.style.background = 'var(--bg-card)';
                chalBtn.style.color = 'var(--orange)';
            });
        }
    });
    </script>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1: Go Fundamentals | Go From Python</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="scanlines"></div>
    <div class="container">
        <nav>
            <a href="module0.html">‚Üê Module 0</a>
            <a href="module2.html">Module 2 ‚Üí</a>
        </nav>

        <div class="module-header">
            <div class="module-tag">// MODULE 01</div>
            <h1>Go Fundamentals</h1>
            <p class="module-desc">Variables, types, functions, and control flow. Every concept mapped from Python.</p>
        </div>

        <div class="lesson">
            <h2>Your First Go Program</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="func">print</span>(<span class="string">"Hello, World!"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="func">main</span>() {
    fmt.<span class="func">Println</span>(<span class="string">"Hello, World!"</span>)
}</pre>
                </div>
            </div>
            <ul>
                <li><strong>package main</strong> ‚Äî Entry point package</li>
                <li><strong>import "fmt"</strong> ‚Äî Import formatting package</li>
                <li><strong>func main()</strong> ‚Äî Entry point function</li>
            </ul>
            <div class="tip">
                <div class="tip-title">Run it</div>
                <p>Save as <span class="inline-code">main.go</span>, run with <span class="inline-code">go run main.go</span></p>
            </div>
        </div>

        <div class="lesson">
            <h2>Variables & Types</h2>
            <p>Python is dynamically typed. Go is statically typed. This is the biggest shift.</p>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre>name = <span class="string">"Alice"</span>
age = <span class="number">30</span>
height = <span class="number">5.9</span>
is_cool = <span class="keyword">True</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="comment">// Explicit types</span>
<span class="keyword">var</span> name <span class="type">string</span> = <span class="string">"Alice"</span>
<span class="keyword">var</span> age <span class="type">int</span> = <span class="number">30</span>

<span class="comment">// Type inference with :=</span>
name := <span class="string">"Alice"</span>
age := <span class="number">30</span>
height := <span class="number">5.9</span>
isCool := <span class="keyword">true</span></pre>
                </div>
            </div>
            <div class="warning">
                <div class="warning-title">Gotcha</div>
                <p><span class="inline-code">:=</span> only works inside functions. At package level, use <span class="inline-code">var</span>.</p>
            </div>
            <h3>Common Types</h3>
            <div class="code-block">
                <div class="code-header go">Types</div>
                <pre><span class="type">string</span>   <span class="comment">// "hello"</span>
<span class="type">int</span>      <span class="comment">// 42 (platform-dependent size)</span>
<span class="type">int64</span>    <span class="comment">// 64-bit integer</span>
<span class="type">float64</span>  <span class="comment">// 3.14</span>
<span class="type">bool</span>     <span class="comment">// true, false</span>
<span class="type">byte</span>     <span class="comment">// alias for uint8</span>
<span class="type">rune</span>     <span class="comment">// alias for int32 (Unicode code point)</span></pre>
            </div>
            <div class="tip">
                <div class="tip-title">Zero Values</div>
                <p>Uninitialized variables get zero values: <span class="inline-code">""</span> for string, <span class="inline-code">0</span> for numbers, <span class="inline-code">false</span> for bool.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Functions</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">def</span> <span class="func">add</span>(a, b):
    <span class="keyword">return</span> a + b

<span class="keyword">def</span> <span class="func">greet</span>(name):
    <span class="keyword">return</span> <span class="string">f"Hello, </span>{name}<span class="string">!"</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">func</span> <span class="func">add</span>(a <span class="type">int</span>, b <span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> a + b
}

<span class="keyword">func</span> <span class="func">greet</span>(name <span class="type">string</span>) <span class="type">string</span> {
    <span class="keyword">return</span> fmt.<span class="func">Sprintf</span>(<span class="string">"Hello, %s!"</span>, name)
}</pre>
                </div>
            </div>
            <h3>Multiple Return Values</h3>
            <div class="code-block">
                <div class="code-header go">Multiple returns</div>
                <pre><span class="keyword">func</span> <span class="func">divide</span>(a, b <span class="type">float64</span>) (<span class="type">float64</span>, <span class="type">error</span>) {
    <span class="keyword">if</span> b == <span class="number">0</span> {
        <span class="keyword">return</span> <span class="number">0</span>, errors.<span class="func">New</span>(<span class="string">"division by zero"</span>)
    }
    <span class="keyword">return</span> a / b, <span class="keyword">nil</span>
}

result, err := divide(<span class="number">10</span>, <span class="number">2</span>)
<span class="keyword">if</span> err != <span class="keyword">nil</span> {
    fmt.<span class="func">Println</span>(err)
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Control Flow</h2>
            <h3 id="lesson-if">If Statements</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span>:
    <span class="func">print</span>(<span class="string">"Can drink"</span>)
<span class="keyword">elif</span> age >= <span class="number">18</span>:
    <span class="func">print</span>(<span class="string">"Can vote"</span>)
<span class="keyword">else</span>:
    <span class="func">print</span>(<span class="string">"Too young"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can drink"</span>)
} <span class="keyword">else if</span> age >= <span class="number">18</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can vote"</span>)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Too young"</span>)
}</pre>
                </div>
            </div>
            <h3 id="lesson-loops">For Loops (The Only Loop)</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">for</span> i <span class="keyword">in</span> <span class="func">range</span>(<span class="number">5</span>):
    <span class="func">print</span>(i)

<span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="func">enumerate</span>(items):
    <span class="func">print</span>(i, item)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">5</span>; i++ {
    fmt.<span class="func">Println</span>(i)
}

<span class="keyword">for</span> i, item := <span class="keyword">range</span> items {
    fmt.<span class="func">Println</span>(i, item)
}</pre>
                </div>
            </div>
        </div>

        <div class="lesson">
            <h2>Slices & Maps</h2>
            <h3 id="lesson-slices">Slices (Dynamic Arrays)</h3>
            <div class="code-block">
                <div class="code-header go">Slices</div>
                <pre>nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}
nums = <span class="func">append</span>(nums, <span class="number">4</span>)
fmt.<span class="func">Println</span>(nums[<span class="number">0</span>])     <span class="comment">// 1</span>
fmt.<span class="func">Println</span>(<span class="func">len</span>(nums))  <span class="comment">// 4</span>
fmt.<span class="func">Println</span>(nums[<span class="number">1</span>:<span class="number">3</span>])   <span class="comment">// [2 3]</span></pre>
            </div>
            <h3 id="lesson-maps">Maps (Dictionaries)</h3>
            <div class="code-block">
                <div class="code-header go">Creating and using maps</div>
                <pre>ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{
    <span class="string">"alice"</span>: <span class="number">30</span>,
    <span class="string">"bob"</span>:   <span class="number">25</span>,
}
ages[<span class="string">"charlie"</span>] = <span class="number">35</span>  <span class="comment">// Add new key</span>

fmt.<span class="func">Println</span>(ages[<span class="string">"alice"</span>])  <span class="comment">// 30</span></pre>
            </div>
            <div class="warning" id="lesson-comma-ok">
                <div class="warning-title">The Missing Key Problem</div>
                <p>In Python, accessing a missing key raises <span class="inline-code">KeyError</span>. In Go, it returns the <strong>zero value</strong> (0 for int, "" for string, etc). This means you can't tell if a key is missing or just has a zero value!</p>
            </div>
            <div class="code-block">
                <div class="code-header go">The "comma ok" idiom - checking if a key exists</div>
                <pre><span class="comment">// Wrong: Can't tell if dave is missing or age is 0</span>
age := ages[<span class="string">"dave"</span>]  <span class="comment">// Returns 0 (zero value)</span>

<span class="comment">// Right: Use the "comma ok" pattern</span>
<span class="comment">// ORDER: value, exists := map[key]</span>
<span class="comment">//        ‚Üë      ‚Üë</span>
<span class="comment">//        ‚îÇ      ‚îî‚îÄ‚îÄ boolean: true if found, false if not</span>
<span class="comment">//        ‚îî‚îÄ‚îÄ the actual value (or zero value)</span>

age, ok := ages[<span class="string">"dave"</span>]
<span class="comment">// age = 0 (zero value for int)</span>
<span class="comment">// ok = false (key doesn't exist)</span>

<span class="keyword">if</span> ok {
    fmt.<span class="func">Println</span>(<span class="string">"Found:"</span>, age)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Not found"</span>)  <span class="comment">// This prints</span>
}

<span class="comment">// Common shorthand: declare inside if statement</span>
<span class="keyword">if</span> age, ok := ages[<span class="string">"alice"</span>]; ok {
    <span class="comment">//   ‚Üë    ‚Üë</span>
    <span class="comment">//   30  true</span>
    fmt.<span class="func">Println</span>(<span class="string">"Alice is"</span>, age)  <span class="comment">// Prints: Alice is 30</span>
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header python">Python equivalent</div>
                <pre><span class="comment"># In Python, you might do:</span>
age = ages.get(<span class="string">"dave"</span>)  <span class="comment"># Returns None if missing</span>
<span class="keyword">if</span> age <span class="keyword">is not None</span>:
    <span class="func">print</span>(<span class="string">f"Found: </span>{age}<span class="string">"</span>)

<span class="comment"># Or check with 'in':</span>
<span class="keyword">if</span> <span class="string">"dave"</span> <span class="keyword">in</span> ages:
    <span class="func">print</span>(<span class="string">f"Found: </span>{ages[<span class="string">'dave'</span>]}<span class="string">"</span>)</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Remember the order!</div>
                <p><strong>First variable</strong> = the value you're looking for<br>
                <strong>Second variable</strong> = boolean (did we find it?)<br><br>
                Pattern: <span class="inline-code">value, found := map[key]</span><br>
                You can name them anything, but <span class="inline-code">ok</span> is conventional for the boolean.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            <p>Progress through each section in order, or jump to where you need practice.</p>

            <!-- Table of Contents -->
            <div style="background: var(--bg-card); border-radius: 8px; padding: 1rem 1.5rem; margin: 1rem 0 2rem 0;">
                <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text);">Jump to section:</div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; font-size: 0.9rem;">
                    <a href="#warmups" style="color: var(--green-bright);">üî• Warmups</a>
                    <a href="#intermediate" style="color: var(--cyan);">‚ö° Intermediate</a>
                    <a href="#challenges" style="color: var(--orange);">üí™ Challenges</a>
                    <a href="#advanced" style="color: var(--purple);">üöÄ Advanced</a>
                </div>
            </div>

            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1.5rem;">
                <h3 id="warmups" style="color: var(--green-bright); margin: 0;">üî• Warmups</h3>
                <button id="shuffle-warmups-btn" onclick="shuffleWarmups()" style="background: var(--bg-card); border: 2px solid var(--green-bright); color: var(--green-bright); padding: 0.4rem 0.9rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; transition: all 0.3s;">üé≤ Shuffle</button>
            </div>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice individual concepts you just learned.</p>

            <div id="warmups-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div>

            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 2rem;">
                <h3 id="intermediate" style="color: var(--cyan); margin: 0;">‚ö° Intermediate</h3>
                <button id="shuffle-intermediate-btn" onclick="shuffleIntermediate()" style="background: var(--bg-card); border: 2px solid var(--cyan); color: var(--cyan); padding: 0.4rem 0.9rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; transition: all 0.3s;">üé≤ Shuffle</button>
            </div>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Each exercise introduces ONE new concept. Build your toolkit!</p>

            <div id="intermediate-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div>

            <h3 id="challenges" style="color: var(--orange); margin-top: 2rem;">üí™ Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">Practice combining concepts. Skip to Advanced if you're comfortable with the basics.</p>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-challenges-btn" onclick="shuffleChallenges()" style="background: var(--bg-card); border: 1px solid var(--orange); color: var(--orange); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    üé≤ Shuffle Challenges
                </button>
            </div>

            <!-- Challenges will be dynamically loaded -->
            <div id="challenges-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div><!-- end challenges-container -->

            <h3 id="advanced" style="color: var(--purple); margin-top: 2rem;">üöÄ Advanced</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">These combine many concepts and introduce new Go features. Complete challenges first!</p>
            <div class="tip" style="margin-bottom: 1rem; padding: 0.75rem 1rem;">
                <strong>How to use this section:</strong> Each Advanced exercise has warm-up exercises above it. Do the warm-ups first (they teach the building blocks), then attempt the full exercise.
            </div>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-btn" onclick="shuffleVariants()" style="background: var(--bg-card); border: 1px solid var(--purple); color: var(--purple); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    üé≤ Shuffle Variants
                </button>
            </div>

            <!-- Pre-exercises for Advanced 1 -->
            <div id="pre-exercises-container"></div>

            <!-- Advanced exercises will be dynamically loaded -->
            <div id="advanced-exercises-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div><!-- end advanced-exercises-container -->

            <div class="tip">
                <div class="tip-title">Learning Path</div>
                <p><strong>Warmups</strong> ‚Üí master basic syntax<br>
                <strong>Intermediate</strong> ‚Üí learn one new concept at a time<br>
                <strong>Challenges</strong> ‚Üí 11 exercises in 4 blocks that build toward Advanced<br>
                <strong>Advanced</strong> ‚Üí 6 algorithm patterns with pre-exercises for scaffolding<br><br>
                <strong>Key bridges:</strong><br>
                ‚Ä¢ Challenge 7 (Count Occurrences) teaches the map pattern used in Advanced 1, 4, 5<br>
                ‚Ä¢ Challenge 11 (First Duplicate Index) directly prepares you for Advanced 1 & 5<br>
                ‚Ä¢ Challenges 8-10 build two-pointer skills for Advanced 2 & 3<br>
                ‚Ä¢ Advanced 6 (Sliding Window) is a critical interview pattern - common in LeetCode mediums!<br><br>
                Stuck? Check the tactical hints - they show you the code step by step!</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 1 Summary</h2>
            <h3>Core Concepts</h3>
            <ul>
                <li><strong>:=</strong> for declaration + assignment inside functions</li>
                <li><strong>Types:</strong> string, int, float64, bool (statically typed!)</li>
                <li><strong>Functions:</strong> <span class="inline-code">func name(params) returnType { }</span></li>
                <li><strong>Multiple returns:</strong> <span class="inline-code">func f() (int, error)</span></li>
                <li><strong>Slices:</strong> <span class="inline-code">[]Type{}</span> - dynamic arrays</li>
                <li><strong>Maps:</strong> <span class="inline-code">map[KeyType]ValueType{}</span> - like dictionaries</li>
            </ul>
            
            <h3>Key Patterns You Learned</h3>
            <ul>
                <li><strong>The "comma ok" idiom:</strong> <span class="inline-code">value, ok := map[key]</span> - check if a map key exists</li>
                <li><strong>Simultaneous assignment:</strong> <span class="inline-code">a, b = b, a</span> - swap without temp variable</li>
            </ul>
            
            <h3>Algorithm Patterns & When to Use Them</h3>
            <ul>
                <li><strong>Two-pointer (opposite ends):</strong> When you need to work from both ends toward the middle
                    <ul style="margin-top: 0.5rem;">
                        <li>Palindrome checking</li>
                        <li>Reversing arrays/strings</li>
                        <li>Pattern: <span class="inline-code">for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1</span></li>
                    </ul>
                </li>
                <li><strong>Slow/fast pointers:</strong> When one pointer reads and another writes, moving at different speeds
                    <ul style="margin-top: 0.5rem;">
                        <li>Removing duplicates from sorted arrays</li>
                        <li>In-place array modifications</li>
                        <li>Pattern: <span class="inline-code">slow := 0</span> outside, <span class="inline-code">for fast := 1; ...</span> inside</li>
                    </ul>
                </li>
                <li><strong>Map for tracking:</strong> When you need to remember "have I seen this before?"
                    <ul style="margin-top: 0.5rem;">
                        <li>Finding duplicates</li>
                        <li>Counting occurrences</li>
                        <li>Two Sum (storing complements)</li>
                        <li>Pattern: Check map first, then add to map if not found</li>
                    </ul>
                </li>
                <li><strong>Building slices with append:</strong> When you need to filter or transform data
                    <ul style="margin-top: 0.5rem;">
                        <li>Filtering even numbers</li>
                        <li>Collecting results dynamically</li>
                        <li>Pattern: Start with <span class="inline-code">result := []Type{}</span>, then <span class="inline-code">result = append(result, item)</span></li>
                    </ul>
                </li>
                <li><strong>Sliding window:</strong> When you need to find something optimal in a contiguous subarray
                    <ul style="margin-top: 0.5rem;">
                        <li>Max sum subarray of size k (fixed window)</li>
                        <li>Longest substring without repeating chars (variable window)</li>
                        <li>Pattern (fixed): Calculate first window, then slide by adding new element and subtracting old</li>
                        <li>Pattern (variable): Expand right pointer, shrink left when condition met/violated</li>
                    </ul>
                </li>
            </ul>
            
            <h3>Common Gotchas</h3>
            <ul>
                <li><strong>Missing map keys return zero values</strong> - use "comma ok" to check if key exists</li>
                <li><strong>Strings are bytes, not characters</strong> - use <span class="inline-code">[]rune(s)</span> for Unicode</li>
                <li><strong>Slices are references</strong> - modifying a slice modifies the original</li>
                <li><strong>:= only works inside functions</strong> - use <span class="inline-code">var</span> at package level</li>
            </ul>
            
            <h3>Next Steps</h3>
            <p style="color: var(--text-dim);">You now have the fundamentals to solve many LeetCode Easy problems! Module 2 will cover pointers, structs, and methods - the building blocks for more complex programs.</p>
        </div>

        <div class="nav-buttons">
            <a href="module0.html" class="nav-btn">‚Üê Module 0</a>
            <a href="module2.html" class="nav-btn primary">Module 2: Pointers ‚Üí</a>
        </div>
    </div>

    <script>
    // Variant system for exercises
    let variantsData = null;
    let currentVariants = {};  // For advanced exercises
    let currentChallengeVariants = {};  // For challenges
    let currentWarmupVariants = {};  // For warmups
    let currentIntermediateVariants = {};  // For intermediate

    // Links from concept names to lesson sections
    const conceptLinks = {
        "For Loops": "#lesson-loops",
        "If/Else": "#lesson-if",
        "Slices & Range": "#lesson-slices",
        "Maps": "#lesson-maps",
        "make() Function": "#lesson-slices",
        "Comma-Ok Pattern": "#lesson-comma-ok",
        "Range with Index": "#lesson-loops",
        "Building Slices": "#lesson-slices"
    };

    // Shared hints/pre-reading for each exercise type (these are the same across variants)
    const sharedContent = {
        advanced_1: {
            preReading: {
                title: 'üìñ Pre-reading: The "Have I Seen This?" Pattern',
                content: `<strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                    <strong>Naive approach (slow):</strong><br>
                    For each element, check every other element to see if it matches ‚Üí O(n¬≤)<br>
                    For 1000 elements, that's 1,000,000 comparisons! üêå<br><br>
                    <strong>Smart approach (fast):</strong><br>
                    Use a map to remember what you've seen ‚Üí O(n)<br>
                    For 1000 elements, that's just 1000 operations! üöÄ<br><br>
                    <strong>The Pattern:</strong><br>
                    1. Create an empty map to track what you've seen<br>
                    2. For each element, check: "Have I seen this before?"<br>
                    3. If yes ‚Üí found a duplicate!<br>
                    4. If no ‚Üí remember it and continue`
            },
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `As you go through the elements, how would you remember which ones you've already seen? What data structure gives you fast lookup to check "have I seen this before?"`
                },
                {
                    title: 'üí° Hint',
                    content: `Use a map as your "memory" - the key is the element, and you just need to know it exists (what simple type represents yes/no?). For each element: first check if it's in your memory, then add it if not. If you make it through all elements without finding a duplicate, they must all be unique.`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>seen := make(map[int]bool)

for _, num := range nums {
    if seen[num] {
        return true  // Duplicate found!
    }
    seen[num] = true
}
return false  // All unique</pre>`
                }
            ]
        },
        advanced_2: {
            preReading: {
                title: 'üìñ Pre-reading: The Slow/Fast Pointer Pattern',
                content: `<strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>
                    <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                    <strong>The Slow/Fast Pattern:</strong><br>
                    ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                    ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                    ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                    <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)
    // Compare items[fast] with items[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>`
            },
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `If the array is already sorted, where will duplicates be? If you're keeping track of the 'last unique' position, what do you do when you find a new unique value?`
                },
                {
                    title: 'üí° Hint',
                    content: `Use two pointers: 'slow' marks where to write the next unique value, 'fast' scans ahead. When fast finds something different from what slow points to, you've found a new unique value - increment slow and copy it there.`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>slow := 0
for fast := 1; fast < len(nums); fast++ {
    if nums[fast] != nums[slow] {
        slow++
        nums[slow] = nums[fast]
    }
}
return slow + 1</pre>`
                }
            ]
        },
        advanced_3: {
            preReading: {
                title: 'üìñ Pre-reading: Strings vs Runes in Go',
                content: `<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                    For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                    But for Unicode (emoji üéâ, Chinese ‰∏ñÁïå, etc.), one character can be 2-4 bytes.<br><br>
                    <strong>Example:</strong><br>
                    <code>"Hello"</code> = 5 bytes = 5 characters ‚úÖ<br>
                    <code>"‰∏ñÁïå"</code> = 6 bytes but only 2 characters! ‚ö†Ô∏è<br>
                    <code>"üéâ"</code> = 4 bytes but only 1 character! ‚ö†Ô∏è<br><br>
                    <strong>The Solution: Runes</strong><br>
                    A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                    Converting to <code>[]rune</code> splits the string into actual characters, not bytes.`
            },
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `Why can't you just index a string directly with [i]? What's special about strings in Go when dealing with non-ASCII characters?`
                },
                {
                    title: 'üí° Hint',
                    content: `Convert to []rune to handle Unicode properly. Then use the two-pointer swap pattern you learned - swap from both ends working inward.`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>runes := []rune(s)
for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
    runes[i], runes[j] = runes[j], runes[i]
}
return string(runes)</pre>`
                }
            ]
        },
        advanced_4: {
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `What's the pattern for counting things? What data structure lets you track 'how many of each thing' efficiently?`
                },
                {
                    title: 'üí° Hint',
                    content: `First split the string into words (check the strings package for a function that splits on whitespace). Then use a map where keys are words and values are counts - what operation increases a map value?`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>words := strings.Fields(s)
counts := make(map[string]int)
for _, word := range words {
    counts[word]++
}
return counts</pre>`
                }
            ]
        },
        advanced_5: {
            preReading: {
                title: 'üìñ Pre-reading: The Hash Map Complement Pattern',
                content: `<strong>The Naive Approach (slow):</strong><br>
                    Check every pair of numbers - requires nested loops O(n¬≤)<br><br>
                    <strong>The Smart Approach (fast):</strong><br>
                    Use a map to remember what you've seen - only one loop O(n)<br><br>
                    <strong>The Key Insight:</strong><br>
                    If target = 9 and current number = 2, we need to find 7.<br>
                    Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                    Maps make this lookup instant!`
            },
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `For each number, what other number would you need to find to reach the target? Instead of searching the whole array for it, how could you instantly check if you've seen it?`
                },
                {
                    title: 'üí° Hint',
                    content: `The complement is <code>target - current</code>. Use a map to remember numbers you've seen AND their indices (since you need to return indices). Check for the complement before adding the current number to your map.`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>seen := make(map[int]int)
for i, num := range nums {
    complement := target - num
    if j, ok := seen[complement]; ok {
        return []int{j, i}
    }
    seen[num] = i
}</pre>`
                }
            ]
        },
        advanced_6: {
            preReading: {
                title: 'üìñ Pre-reading: The Sliding Window Pattern',
                content: `<strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>
                    <strong>Naive approach (slow):</strong><br>
                    Check every possible subarray - O(n¬≤) or worse üêå<br><br>
                    <strong>Smart approach (fast):</strong><br>
                    Use a "window" that slides through the array - O(n) üöÄ<br><br>
                    <strong>Two Types of Sliding Windows:</strong><br>
                    <strong>1. Fixed-size window:</strong> Window size k stays constant<br>
                    ‚Ä¢ Add the new element entering on the right<br>
                    ‚Ä¢ Subtract the element leaving on the left<br><br>
                    <strong>2. Variable-size window:</strong> Window grows and shrinks<br>
                    ‚Ä¢ Expand (move right pointer) to include more elements<br>
                    ‚Ä¢ Shrink (move left pointer) when condition is violated or met`
            },
            hints: [
                {
                    title: 'ü§î Think about it',
                    content: `If you've already calculated the sum for elements 0-3, do you really need to recalculate everything for elements 1-4? What operation can give you the new sum efficiently?`
                },
                {
                    title: 'üí° Hint',
                    content: `For fixed windows: add the new element entering, subtract the element leaving. Think of it as the window 'sliding' right - one element comes in, one goes out. Track your max/min as you slide.`
                },
                {
                    title: 'üëÄ Show me',
                    content: `<pre>// Initial window
windowSum := 0
for i := 0; i < k; i++ {
    windowSum += nums[i]
}
maxSum := windowSum

// Slide the window
for i := k; i < len(nums); i++ {
    windowSum += nums[i] - nums[i-k]
    if windowSum > maxSum {
        maxSum = windowSum
    }
}</pre>`
                }
            ]
        }
    };

    // Embedded variants data (works with file:// protocol)
    // These are DIFFERENT problems that test the same concepts, not just renamed variables
    const variantsDataEmbedded = {
      "intermediate": [
        { "id": "intermediate_1", "concept": "make() Function", "variants": [
          { "id": "v1", "title": "Make and Append to Slice", "description": "Create an empty slice using <code>make([]int, 0)</code>, add three numbers with <code>append</code>, then print its length.", "hints": ["<code>make([]int, 0)</code> creates an empty int slice", "<code>nums = append(nums, value)</code> adds to the slice"], "solution": "nums := make([]int, 0)\nnums = append(nums, 10)\nnums = append(nums, 20)\nnums = append(nums, 30)\nfmt.Println(len(nums))  // 3", "expected": "3" },
          { "id": "v2", "title": "Make an Empty Map", "description": "Create an empty map using <code>make(map[string]int)</code>, add three key-value pairs, then print its length.", "hints": ["<code>make(map[string]int)</code> creates an empty map", "<code>scores[\"alice\"] = 100</code> adds a key-value pair"], "solution": "scores := make(map[string]int)\nscores[\"alice\"] = 100\nscores[\"bob\"] = 85\nscores[\"carol\"] = 92\nfmt.Println(len(scores))  // 3", "expected": "3" },
          { "id": "v3", "title": "Append Multiple Values", "description": "Create an empty string slice, then use <code>append</code> to add multiple values at once. Print the slice.", "hints": ["<code>append</code> can take multiple values: <code>append(slice, a, b, c)</code>"], "solution": "words := make([]string, 0)\nwords = append(words, \"go\", \"is\", \"fun\")\nfmt.Println(words)  // [go is fun]", "expected": "[go is fun]" }
        ]},
        { "id": "intermediate_2", "concept": "Comma-Ok Pattern", "variants": [
          { "id": "v1", "title": "Check Map Key Exists", "description": "Create a map of fruit prices. Check if \"banana\" exists using the <code>value, ok := map[key]</code> pattern.", "hints": ["<code>price, ok := prices[\"banana\"]</code>", "<code>ok</code> is true if key exists, false otherwise"], "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"orange\": 2.00,\n}\n\nif price, ok := prices[\"banana\"]; ok {\n    fmt.Printf(\"Banana: $%.2f\\n\", price)\n} else {\n    fmt.Println(\"Banana not found\")\n}", "expected": "Banana not found" },
          { "id": "v2", "title": "Safe Map Lookup", "description": "Create a map of user ages. Safely look up a user that exists AND one that doesn't, printing appropriate messages.", "hints": ["Use <code>if age, ok := ages[name]; ok { ... } else { ... }</code>"], "solution": "ages := map[string]int{\"alice\": 30, \"bob\": 25}\n\nif age, ok := ages[\"alice\"]; ok {\n    fmt.Printf(\"Alice is %d\\n\", age)\n}\n\nif age, ok := ages[\"charlie\"]; ok {\n    fmt.Printf(\"Charlie is %d\\n\", age)\n} else {\n    fmt.Println(\"Charlie not found\")\n}", "expected": "Alice is 30\nCharlie not found" },
          { "id": "v3", "title": "Default Value Pattern", "description": "Create a map of stock counts. If an item doesn't exist, print \"Out of stock\" instead of 0.", "hints": ["Check with comma-ok before using the value"], "solution": "stock := map[string]int{\"apple\": 5, \"banana\": 0}\n\nitem := \"orange\"\nif count, ok := stock[item]; ok {\n    fmt.Printf(\"%s: %d in stock\\n\", item, count)\n} else {\n    fmt.Printf(\"%s: Out of stock\\n\", item)\n}", "expected": "orange: Out of stock" }
        ]},
        { "id": "intermediate_3", "concept": "Range with Index", "variants": [
          { "id": "v1", "title": "Print Index and Value", "description": "Create a slice of your favorite foods. Loop through and print both index and value: \"0: pizza\", \"1: tacos\", etc.", "hints": ["<code>for i, food := range foods</code> gives you both index and value"], "solution": "foods := []string{\"pizza\", \"tacos\", \"sushi\"}\nfor i, food := range foods {\n    fmt.Printf(\"%d: %s\\n\", i, food)\n}", "expected": "0: pizza\n1: tacos\n2: sushi" },
          { "id": "v2", "title": "Numbered List", "description": "Create a slice of task names. Print them as a numbered list starting from 1: \"1. Buy milk\", \"2. Walk dog\", etc.", "hints": ["Use <code>i+1</code> to start numbering from 1 instead of 0"], "solution": "tasks := []string{\"Buy milk\", \"Walk dog\", \"Code\"}\nfor i, task := range tasks {\n    fmt.Printf(\"%d. %s\\n\", i+1, task)\n}", "expected": "1. Buy milk\n2. Walk dog\n3. Code" },
          { "id": "v3", "title": "Find Element Index", "description": "Create a slice of colors. Find and print the index of \"green\" (or -1 if not found).", "hints": ["Loop with index, check if element matches"], "solution": "colors := []string{\"red\", \"blue\", \"green\", \"yellow\"}\ntarget := \"green\"\nresult := -1\n\nfor i, color := range colors {\n    if color == target {\n        result = i\n        break\n    }\n}\nfmt.Printf(\"Index of %s: %d\\n\", target, result)", "expected": "Index of green: 2" }
        ]},
        { "id": "intermediate_4", "concept": "Building Slices", "variants": [
          { "id": "v1", "title": "Collect Even Numbers", "description": "Create an empty slice, then loop 1-10 and append only even numbers. Print the result.", "hints": ["Check <code>if i%2 == 0</code>", "Use <code>append</code> inside the if block"], "solution": "evens := []int{}\nfor i := 1; i <= 10; i++ {\n    if i%2 == 0 {\n        evens = append(evens, i)\n    }\n}\nfmt.Println(evens)", "expected": "[2 4 6 8 10]" },
          { "id": "v2", "title": "Filter Long Words", "description": "Given <code>[]string{\"go\", \"python\", \"js\", \"rust\"}</code>, collect only words with 3+ characters into a new slice.", "hints": ["Check <code>if len(word) >= 3</code>"], "solution": "words := []string{\"go\", \"python\", \"js\", \"rust\"}\nlong := []string{}\nfor _, word := range words {\n    if len(word) >= 3 {\n        long = append(long, word)\n    }\n}\nfmt.Println(long)", "expected": "[python rust]" },
          { "id": "v3", "title": "Collect Multiples of 3", "description": "Create an empty slice, loop 1-15, and append only numbers divisible by 3. Print the result.", "hints": ["Check <code>if i%3 == 0</code>"], "solution": "multiples := []int{}\nfor i := 1; i <= 15; i++ {\n    if i%3 == 0 {\n        multiples = append(multiples, i)\n    }\n}\nfmt.Println(multiples)", "expected": "[3 6 9 12 15]" }
        ]}
      ],
      "warmups": [
        { "id": "warmup_1", "concept": "For Loops", "variants": [
          { "id": "v1", "title": "Print 1 to 10", "description": "Write a program that prints the numbers 1 to 10, one per line.", "hints": ["Use <code>for i := 1; i <= 10; i++</code>"], "solution": "for i := 1; i <= 10; i++ {\n    fmt.Println(i)\n}" },
          { "id": "v2", "title": "Countdown from 5", "description": "Write a program that counts down from 5 to 1, then prints \"Go!\"", "hints": ["Use <code>for i := 5; i >= 1; i--</code>", "Print \"Go!\" after the loop"], "solution": "for i := 5; i >= 1; i-- {\n    fmt.Println(i)\n}\nfmt.Println(\"Go!\")" },
          { "id": "v3", "title": "Print Even Numbers", "description": "Write a program that prints even numbers from 2 to 10.", "hints": ["Use <code>for i := 2; i <= 10; i += 2</code>"], "solution": "for i := 2; i <= 10; i += 2 {\n    fmt.Println(i)\n}" }
        ]},
        { "id": "warmup_2", "concept": "If/Else", "variants": [
          { "id": "v1", "title": "Check Number Sign", "description": "Write <code>func checkSign(n int) string</code> that returns \"positive\", \"negative\", or \"zero\".", "hints": ["Use <code>if n > 0</code>, then <code>else if n < 0</code>, then <code>else</code>"], "solution": "func checkSign(n int) string {\n    if n > 0 {\n        return \"positive\"\n    } else if n < 0 {\n        return \"negative\"\n    }\n    return \"zero\"\n}" },
          { "id": "v2", "title": "Pass or Fail", "description": "Write <code>func passOrFail(score int) string</code> that returns \"pass\" if score >= 60, else \"fail\".", "hints": ["Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"], "solution": "func passOrFail(score int) string {\n    if score >= 60 {\n        return \"pass\"\n    }\n    return \"fail\"\n}" },
          { "id": "v3", "title": "Age Category", "description": "Write <code>func ageCategory(age int) string</code> that returns \"child\" (< 13), \"teen\" (13-19), or \"adult\" (20+).", "hints": ["Chain if/else if/else based on age ranges"], "solution": "func ageCategory(age int) string {\n    if age < 13 {\n        return \"child\"\n    } else if age < 20 {\n        return \"teen\"\n    }\n    return \"adult\"\n}" }
        ]},
        { "id": "warmup_3", "concept": "Slices & Range", "variants": [
          { "id": "v1", "title": "Iterate Numbers", "description": "Create a slice with three numbers, then print each using <code>for range</code>.", "hints": ["Create: <code>nums := []int{7, 42, 99}</code>", "Loop: <code>for _, num := range nums</code>"], "solution": "nums := []int{7, 42, 99}\nfor _, num := range nums {\n    fmt.Println(num)\n}" },
          { "id": "v2", "title": "Iterate with Index", "description": "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc.", "hints": ["Loop with index: <code>for i, color := range colors</code>", "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"], "solution": "colors := []string{\"red\", \"blue\", \"green\"}\nfor i, color := range colors {\n    fmt.Printf(\"%d: %s\\n\", i, color)\n}" },
          { "id": "v3", "title": "Iterate Strings", "description": "Create a slice of your favorite foods, print each on its own line.", "hints": ["Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"], "solution": "foods := []string{\"pizza\", \"sushi\", \"tacos\"}\nfor _, food := range foods {\n    fmt.Println(food)\n}" }
        ]},
        { "id": "warmup_4", "concept": "Maps", "variants": [
          { "id": "v1", "title": "Ages Map", "description": "Create a map of names to ages, then print each person's name and age.", "hints": ["Map syntax: <code>map[string]int{\"alice\": 30}</code>", "Loop: <code>for name, age := range ages</code>"], "solution": "ages := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d\\n\", name, age)\n}" },
          { "id": "v2", "title": "Prices Map", "description": "Create a map of items to prices (float64), then print each item and price.", "hints": ["Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"], "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"banana\": 0.75,\n}\nfor item, price := range prices {\n    fmt.Printf(\"%s: $%.2f\\n\", item, price)\n}" },
          { "id": "v3", "title": "Capitals Map", "description": "Create a map of countries to their capitals, then print each pair.", "hints": ["Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"], "solution": "capitals := map[string]string{\n    \"France\": \"Paris\",\n    \"Japan\":  \"Tokyo\",\n}\nfor country, capital := range capitals {\n    fmt.Printf(\"%s: %s\\n\", country, capital)\n}" }
        ]}
      ],
      "challenges": [
        {
          "id": "challenge_1", "block": 1, "concept": "Accumulator Pattern",
          "variants": [
            { "id": "v1", "title": "Sum of Slice", "description": "Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.", "functionSignature": "func sum(numbers []int) int", "testCases": [{ "input": "[]int{1, 2, 3, 4, 5}", "output": "15" }], "hints": [{ "title": "ü§î Think about it", "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?" }, { "title": "üí° Hint", "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator." }, { "title": "üëÄ Show me", "content": "<pre>total := 0\nfor _, num := range numbers {\n    total += num\n}</pre>" }], "solution": "func sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}" },
            { "id": "v2", "title": "Join Words", "description": "Write <code>func joinWords(words []string) string</code> that joins all words with spaces.", "functionSignature": "func joinWords(words []string) string", "testCases": [{ "input": "[]string{\"go\", \"is\", \"fun\"}", "output": "\"go is fun\"" }], "hints": [{ "title": "ü§î Think about it", "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?" }, { "title": "üí° Hint", "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator." }, { "title": "üëÄ Show me", "content": "<pre>result := \"\"\nfor i, word := range words {\n    if i > 0 {\n        result += \" \"\n    }\n    result += word\n}</pre>" }], "solution": "func joinWords(words []string) string {\n    result := \"\"\n    for i, word := range words {\n        if i > 0 {\n            result += \" \"\n        }\n        result += word\n    }\n    return result\n}" },
            { "id": "v3", "title": "Total String Length", "description": "Write <code>func totalLength(words []string) int</code> that returns total length of all strings.", "functionSignature": "func totalLength(words []string) int", "testCases": [{ "input": "[]string{\"go\", \"is\", \"fun\"}", "output": "7" }], "hints": [{ "title": "ü§î Think about it", "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?" }, { "title": "üí° Hint", "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator." }, { "title": "üëÄ Show me", "content": "<pre>total := 0\nfor _, word := range words {\n    total += len(word)\n}</pre>" }], "solution": "func totalLength(words []string) int {\n    total := 0\n    for _, word := range words {\n        total += len(word)\n    }\n    return total\n}" }
          ]
        },
        {
          "id": "challenge_2", "block": 1, "concept": "Counting with Condition",
          "variants": [
            { "id": "v1", "title": "Count Evens", "description": "Write <code>func countEvens(nums []int) int</code> that counts even numbers.", "functionSignature": "func countEvens(nums []int) int", "testCases": [{ "input": "[]int{1, 2, 3, 4, 5, 6}", "output": "3" }], "hints": [{ "title": "ü§î Think about it", "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?" }, { "title": "üí° Hint", "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter." }, { "title": "üëÄ Show me", "content": "<pre>count := 0\nfor _, num := range nums {\n    if num%2 == 0 {\n        count++\n    }\n}</pre>" }], "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num%2 == 0 {\n            count++\n        }\n    }\n    return count\n}" },
            { "id": "v2", "title": "Count Negatives", "description": "Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.", "functionSignature": "func countNegatives(nums []int) int", "testCases": [{ "input": "[]int{-1, 2, -3, 4}", "output": "2" }], "hints": [{ "title": "ü§î Think about it", "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?" }, { "title": "üí° Hint", "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter." }, { "title": "üëÄ Show me", "content": "<pre>count := 0\nfor _, num := range nums {\n    if num < 0 {\n        count++\n    }\n}</pre>" }], "solution": "func countNegatives(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num < 0 {\n            count++\n        }\n    }\n    return count\n}" },
            { "id": "v3", "title": "Count Long Words", "description": "Write <code>func countLong(words []string, minLen int) int</code> that counts words >= minLen.", "functionSignature": "func countLong(words []string, minLen int) int", "testCases": [{ "input": "[]string{\"go\", \"python\", \"js\"}, 3", "output": "1" }], "hints": [{ "title": "ü§î Think about it", "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?" }, { "title": "üí° Hint", "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter." }, { "title": "üëÄ Show me", "content": "<pre>count := 0\nfor _, word := range words {\n    if len(word) >= minLen {\n        count++\n    }\n}</pre>" }], "solution": "func countLong(words []string, minLen int) int {\n    count := 0\n    for _, word := range words {\n        if len(word) >= minLen {\n            count++\n        }\n    }\n    return count\n}" }
          ]
        },
        {
          "id": "challenge_3", "block": 1, "concept": "Multiple Conditionals",
          "variants": [
            { "id": "v1", "title": "FizzBuzz", "description": "Print 1-20. Multiples of 3: \"Fizz\", 5: \"Buzz\", both: \"FizzBuzz\".", "functionSignature": "// loop", "testCases": [{ "input": "15", "output": "FizzBuzz" }], "hints": [{ "title": "ü§î Think about it", "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?" }, { "title": "üí° Hint", "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually." }, { "title": "üëÄ Show me", "content": "<pre>if i%15 == 0 {\n    fmt.Println(\"FizzBuzz\")\n} else if i%3 == 0 {\n    fmt.Println(\"Fizz\")\n} else if i%5 == 0 {\n    fmt.Println(\"Buzz\")\n} else {\n    fmt.Println(i)\n}</pre>" }], "solution": "for i := 1; i <= 20; i++ {\n    if i%15 == 0 {\n        fmt.Println(\"FizzBuzz\")\n    } else if i%3 == 0 {\n        fmt.Println(\"Fizz\")\n    } else if i%5 == 0 {\n        fmt.Println(\"Buzz\")\n    } else {\n        fmt.Println(i)\n    }\n}" },
            { "id": "v2", "title": "Grade Classifier", "description": "Write <code>func grade(score int) string</code> returning A/B/C/D/F.", "functionSignature": "func grade(score int) string", "testCases": [{ "input": "85", "output": "\"B\"" }], "hints": [{ "title": "ü§î Think about it", "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?" }, { "title": "üí° Hint", "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually." }, { "title": "üëÄ Show me", "content": "<pre>if score >= 90 { return \"A\" }\nif score >= 80 { return \"B\" }\nif score >= 70 { return \"C\" }\nif score >= 60 { return \"D\" }\nreturn \"F\"</pre>" }], "solution": "func grade(score int) string {\n    if score >= 90 { return \"A\" }\n    if score >= 80 { return \"B\" }\n    if score >= 70 { return \"C\" }\n    if score >= 60 { return \"D\" }\n    return \"F\"\n}" },
            { "id": "v3", "title": "Number Sign", "description": "Write <code>func sign(n int) string</code> returning positive/negative/zero.", "functionSignature": "func sign(n int) string", "testCases": [{ "input": "-5", "output": "\"negative\"" }], "hints": [{ "title": "ü§î Think about it", "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?" }, { "title": "üí° Hint", "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually." }, { "title": "üëÄ Show me", "content": "<pre>if n > 0 { return \"positive\" }\nif n < 0 { return \"negative\" }\nreturn \"zero\"</pre>" }], "solution": "func sign(n int) string {\n    if n > 0 { return \"positive\" }\n    if n < 0 { return \"negative\" }\n    return \"zero\"\n}" }
          ]
        },
        {
          "id": "challenge_4", "block": 1, "concept": "Finding Extrema",
          "variants": [
            { "id": "v1", "title": "Find Maximum", "description": "Write <code>func max(nums []int) int</code> that returns the largest number.", "functionSignature": "func max(nums []int) int", "testCases": [{ "input": "[]int{3, 7, 2, 9}", "output": "9" }], "hints": [{ "title": "ü§î Think about it", "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?" }, { "title": "üí° Hint", "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best." }, { "title": "üëÄ Show me", "content": "<pre>best := nums[0]\nfor _, n := range nums {\n    if n > best { best = n }\n}\nreturn best</pre>" }], "solution": "func max(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n > m { m = n }\n    }\n    return m\n}" },
            { "id": "v2", "title": "Find Minimum", "description": "Write <code>func min(nums []int) int</code> that returns the smallest number.", "functionSignature": "func min(nums []int) int", "testCases": [{ "input": "[]int{3, 7, 2, 9}", "output": "2" }], "hints": [{ "title": "ü§î Think about it", "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?" }, { "title": "üí° Hint", "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best." }, { "title": "üëÄ Show me", "content": "<pre>best := nums[0]\nfor _, n := range nums {\n    if n < best { best = n }\n}\nreturn best</pre>" }], "solution": "func min(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n < m { m = n }\n    }\n    return m\n}" },
            { "id": "v3", "title": "Longest String", "description": "Write <code>func longest(words []string) string</code> that returns the longest word.", "functionSignature": "func longest(words []string) string", "testCases": [{ "input": "[]string{\"go\", \"python\"}", "output": "\"python\"" }], "hints": [{ "title": "ü§î Think about it", "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?" }, { "title": "üí° Hint", "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best." }, { "title": "üëÄ Show me", "content": "<pre>best := words[0]\nfor _, w := range words {\n    if len(w) > len(best) { best = w }\n}\nreturn best</pre>" }], "solution": "func longest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) > len(r) { r = w }\n    }\n    return r\n}" }
          ]
        },
        {
          "id": "challenge_5", "block": 2, "concept": "Filter with Append",
          "variants": [
            { "id": "v1", "title": "Filter Positives", "description": "Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.", "functionSignature": "func filterPositives(nums []int) []int", "testCases": [{ "input": "[]int{-2, 3, -1, 5}", "output": "[3, 5]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?" }, { "title": "üí° Hint", "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass." }, { "title": "üëÄ Show me", "content": "<pre>result := []int{}\nfor _, n := range nums {\n    if n > 0 {\n        result = append(result, n)\n    }\n}</pre>" }], "solution": "func filterPositives(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > 0 { r = append(r, n) }\n    }\n    return r\n}" },
            { "id": "v2", "title": "Filter Evens", "description": "Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.", "functionSignature": "func filterEvens(nums []int) []int", "testCases": [{ "input": "[]int{1, 2, 3, 4}", "output": "[2, 4]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?" }, { "title": "üí° Hint", "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass." }, { "title": "üëÄ Show me", "content": "<pre>result := []int{}\nfor _, n := range nums {\n    if n%2 == 0 {\n        result = append(result, n)\n    }\n}</pre>" }], "solution": "func filterEvens(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n%2 == 0 { r = append(r, n) }\n    }\n    return r\n}" },
            { "id": "v3", "title": "Filter Short Words", "description": "Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.", "functionSignature": "func filterShort(words []string, max int) []string", "testCases": [{ "input": "[]string{\"go\", \"python\"}, 3", "output": "[\"go\"]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?" }, { "title": "üí° Hint", "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass." }, { "title": "üëÄ Show me", "content": "<pre>result := []string{}\nfor _, w := range words {\n    if len(w) <= max {\n        result = append(result, w)\n    }\n}</pre>" }], "solution": "func filterShort(words []string, max int) []string {\n    r := []string{}\n    for _, w := range words {\n        if len(w) <= max { r = append(r, w) }\n    }\n    return r\n}" }
          ]
        },
        {
          "id": "challenge_6", "block": 2, "concept": "Find Index",
          "variants": [
            { "id": "v1", "title": "Find Index", "description": "Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.", "functionSignature": "func findIndex(nums []int, target int) int", "testCases": [{ "input": "[]int{10, 20, 30}, 20", "output": "1" }], "hints": [{ "title": "ü§î Think about it", "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?" }, { "title": "üí° Hint", "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1." }, { "title": "üëÄ Show me", "content": "<pre>for i, num := range nums {\n    if num == target {\n        return i\n    }\n}\nreturn -1</pre>" }], "solution": "func findIndex(nums []int, target int) int {\n    for i, n := range nums {\n        if n == target { return i }\n    }\n    return -1\n}" },
            { "id": "v2", "title": "Find Word", "description": "Write <code>func findWord(words []string, target string) int</code> returning index or -1.", "functionSignature": "func findWord(words []string, target string) int", "testCases": [{ "input": "[]string{\"go\", \"py\"}, \"py\"", "output": "1" }], "hints": [{ "title": "ü§î Think about it", "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?" }, { "title": "üí° Hint", "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1." }, { "title": "üëÄ Show me", "content": "<pre>for i, w := range words {\n    if w == target {\n        return i\n    }\n}\nreturn -1</pre>" }], "solution": "func findWord(words []string, target string) int {\n    for i, w := range words {\n        if w == target { return i }\n    }\n    return -1\n}" },
            { "id": "v3", "title": "First Negative Index", "description": "Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.", "functionSignature": "func firstNegIdx(nums []int) int", "testCases": [{ "input": "[]int{5, -2, 3}", "output": "1" }], "hints": [{ "title": "ü§î Think about it", "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?" }, { "title": "üí° Hint", "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1." }, { "title": "üëÄ Show me", "content": "<pre>for i, n := range nums {\n    if n < 0 {\n        return i\n    }\n}\nreturn -1</pre>" }], "solution": "func firstNegIdx(nums []int) int {\n    for i, n := range nums {\n        if n < 0 { return i }\n    }\n    return -1\n}" }
          ]
        },
        {
          "id": "challenge_7", "block": 2, "concept": "Map Counting",
          "variants": [
            { "id": "v1", "title": "Count Occurrences", "description": "Write <code>func countOccurrences(nums []int) map[int]int</code>.", "functionSignature": "func countOccurrences(nums []int) map[int]int", "testCases": [{ "input": "[]int{1, 2, 2, 3, 3, 3}", "output": "map[1:1 2:2 3:3]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?" }, { "title": "üí° Hint", "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence." }, { "title": "üëÄ Show me", "content": "<pre>counts := make(map[int]int)\ncounts[num]++</pre>" }], "solution": "func countOccurrences(nums []int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n]++ }\n    return c\n}" },
            { "id": "v2", "title": "Count Characters", "description": "Write <code>func countChars(s string) map[rune]int</code>.", "functionSignature": "func countChars(s string) map[rune]int", "testCases": [{ "input": "\"hello\"", "output": "map[e:1 h:1 l:2 o:1]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?" }, { "title": "üí° Hint", "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence." }, { "title": "üëÄ Show me", "content": "<pre>counts := make(map[rune]int)\ncounts[char]++</pre>" }], "solution": "func countChars(s string) map[rune]int {\n    c := make(map[rune]int)\n    for _, r := range s { c[r]++ }\n    return c\n}" },
            { "id": "v3", "title": "Word Frequency", "description": "Write <code>func wordFreq(words []string) map[string]int</code>.", "functionSignature": "func wordFreq(words []string) map[string]int", "testCases": [{ "input": "[]string{\"go\", \"go\", \"py\"}", "output": "map[go:2 py:1]" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?" }, { "title": "üí° Hint", "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence." }, { "title": "üëÄ Show me", "content": "<pre>counts := make(map[string]int)\ncounts[word]++</pre>" }], "solution": "func wordFreq(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words { c[w]++ }\n    return c\n}" }
          ]
        },
        {
          "id": "challenge_8", "block": 3, "concept": "Swap Pattern",
          "variants": [
            { "id": "v1", "title": "Swap Elements", "description": "Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.", "functionSignature": "func swap(nums []int, i, j int)", "testCases": [{ "input": "[]int{1,2,3}, 0, 2", "output": "[3,2,1]" }], "hints": [{ "title": "ü§î Think about it", "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b." }, { "title": "üí° Hint", "content": "Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost." }, { "title": "üëÄ Show me", "content": "<pre>nums[i], nums[j] = nums[j], nums[i]</pre>" }], "solution": "func swap(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}" },
            { "id": "v2", "title": "Swap First Last", "description": "Write <code>func swapEnds(nums []int)</code> that swaps first and last elements.", "functionSignature": "func swapEnds(nums []int)", "testCases": [{ "input": "[]int{1,2,3,4}", "output": "[4,2,3,1]" }], "hints": [{ "title": "ü§î Think about it", "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b." }, { "title": "üí° Hint", "content": "Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost." }, { "title": "üëÄ Show me", "content": "<pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>" }], "solution": "func swapEnds(nums []int) {\n    nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n}" },
            { "id": "v3", "title": "Swap Variables", "description": "Swap two variables a=5, b=10 and print them.", "functionSignature": "// inline", "testCases": [{ "input": "a=5, b=10", "output": "a=10, b=5" }], "hints": [{ "title": "ü§î Think about it", "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b." }, { "title": "üí° Hint", "content": "Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost." }, { "title": "üëÄ Show me", "content": "<pre>a, b = b, a</pre>" }], "solution": "a, b := 5, 10\na, b = b, a\nfmt.Println(a, b)" }
          ]
        },
        {
          "id": "challenge_9", "block": 3, "concept": "Two-Pointer Comparison",
          "variants": [
            { "id": "v1", "title": "Palindrome Check", "description": "Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.", "functionSignature": "func isPalindrome(nums []int) bool", "testCases": [{ "input": "[]int{1,2,3,2,1}", "output": "true" }], "hints": [{ "title": "ü§î Think about it", "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?" }, { "title": "üí° Hint", "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is." }, { "title": "üëÄ Show me", "content": "<pre>for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {\n    if items[i] != items[j] { return false }\n}</pre>" }], "solution": "func isPalindrome(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}" },
            { "id": "v2", "title": "String Palindrome", "description": "Write <code>func isSymmetric(s string) bool</code>.", "functionSignature": "func isSymmetric(s string) bool", "testCases": [{ "input": "\"racecar\"", "output": "true" }], "hints": [{ "title": "ü§î Think about it", "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?" }, { "title": "üí° Hint", "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is." }, { "title": "üëÄ Show me", "content": "<pre>runes := []rune(s)\nfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n    if runes[i] != runes[j] { return false }\n}</pre>" }], "solution": "func isSymmetric(s string) bool {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        if r[i] != r[j] { return false }\n    }\n    return true\n}" },
            { "id": "v3", "title": "Ends Match", "description": "Write <code>func endsMatch(nums []int) bool</code> - first equals last.", "functionSignature": "func endsMatch(nums []int) bool", "testCases": [{ "input": "[]int{5,2,3,5}", "output": "true" }], "hints": [{ "title": "ü§î Think about it", "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?" }, { "title": "üí° Hint", "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is." }, { "title": "üëÄ Show me", "content": "<pre>return nums[0] == nums[len(nums)-1]</pre>" }], "solution": "func endsMatch(nums []int) bool {\n    return nums[0] == nums[len(nums)-1]\n}" }
          ]
        },
        {
          "id": "challenge_10", "block": 4, "concept": "Two-Pointer Swap",
          "variants": [
            { "id": "v1", "title": "Reverse Slice", "description": "Write <code>func reverse(nums []int) []int</code> that reverses in place.", "functionSignature": "func reverse(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3,4,5}", "output": "[5,4,3,2,1]" }], "hints": [{ "title": "ü§î Think about it", "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?" }, { "title": "üí° Hint", "content": "Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross." }, { "title": "üëÄ Show me", "content": "<pre>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n    nums[i], nums[j] = nums[j], nums[i]\n}</pre>" }], "solution": "func reverse(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    return nums\n}" },
            { "id": "v2", "title": "Rotate Left", "description": "Write <code>func rotateLeft(nums []int) []int</code> - first element goes to end.", "functionSignature": "func rotateLeft(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3}", "output": "[2,3,1]" }], "hints": [{ "title": "ü§î Think about it", "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?" }, { "title": "üí° Hint", "content": "Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross." }, { "title": "üëÄ Show me", "content": "<pre>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n    nums[i], nums[j] = nums[j], nums[i]\n}</pre>" }], "solution": "func rotateLeft(nums []int) []int {\n    first := nums[0]\n    for i := 0; i < len(nums)-1; i++ { nums[i] = nums[i+1] }\n    nums[len(nums)-1] = first\n    return nums\n}" },
            { "id": "v3", "title": "Rotate Right", "description": "Write <code>func rotateRight(nums []int) []int</code> - last element goes to front.", "functionSignature": "func rotateRight(nums []int) []int", "testCases": [{ "input": "[]int{1,2,3}", "output": "[3,1,2]" }], "hints": [{ "title": "ü§î Think about it", "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?" }, { "title": "üí° Hint", "content": "Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross." }, { "title": "üëÄ Show me", "content": "<pre>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n    nums[i], nums[j] = nums[j], nums[i]\n}</pre>" }], "solution": "func rotateRight(nums []int) []int {\n    last := nums[len(nums)-1]\n    for i := len(nums)-1; i > 0; i-- { nums[i] = nums[i-1] }\n    nums[0] = last\n    return nums\n}" }
          ]
        },
        {
          "id": "challenge_11", "block": 4, "concept": "Map Lookup + Early Return",
          "variants": [
            { "id": "v1", "title": "First Duplicate Index", "description": "Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.", "functionSignature": "func firstDupIdx(nums []int) int", "testCases": [{ "input": "[]int{1,2,3,2}", "output": "3" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?" }, { "title": "üí° Hint", "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue." }, { "title": "üëÄ Show me", "content": "<pre>seen := make(map[int]bool)\nif seen[item] { return ... }\nseen[item] = true</pre>" }], "solution": "func firstDupIdx(nums []int) int {\n    seen := make(map[int]bool)\n    for i, n := range nums {\n        if seen[n] { return i }\n        seen[n] = true\n    }\n    return -1\n}" },
            { "id": "v2", "title": "First Repeat Char", "description": "Write <code>func firstRepeat(s string) rune</code> - first repeated char, or 0.", "functionSignature": "func firstRepeat(s string) rune", "testCases": [{ "input": "\"abcab\"", "output": "'a'" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?" }, { "title": "üí° Hint", "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue." }, { "title": "üëÄ Show me", "content": "<pre>seen := make(map[rune]bool)\nif seen[r] { return r }\nseen[r] = true</pre>" }], "solution": "func firstRepeat(s string) rune {\n    seen := make(map[rune]bool)\n    for _, r := range s {\n        if seen[r] { return r }\n        seen[r] = true\n    }\n    return 0\n}" },
            { "id": "v3", "title": "Has Duplicate", "description": "Write <code>func hasDup(nums []int) bool</code> - true if any number repeats.", "functionSignature": "func hasDup(nums []int) bool", "testCases": [{ "input": "[]int{1,2,3,2}", "output": "true" }], "hints": [{ "title": "ü§î Think about it", "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?" }, { "title": "üí° Hint", "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue." }, { "title": "üëÄ Show me", "content": "<pre>seen := make(map[int]bool)\nif seen[n] { return true }\nseen[n] = true</pre>" }], "solution": "func hasDup(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        if seen[n] { return true }\n        seen[n] = true\n    }\n    return false\n}" }
          ]
        }
      ],
      "advanced": [
        {
          "id": "advanced_1",
          "baseTitle": "Map as Set",
          "concept": "Map as Set - Have I Seen This?",
          "variants": [
            {
              "id": "v1",
              "title": "Contains Duplicate",
              "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
              "functionSignature": "func containsDuplicate(nums []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3, 1}", "output": "true" },
                { "input": "[]int{1, 2, 3, 4}", "output": "false" },
                { "input": "[]int{1, 1, 1, 1}", "output": "true" }
              ],
              "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}"
            },
            {
              "id": "v2",
              "title": "First Duplicate Value",
              "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
              "functionSignature": "func firstDuplicate(nums []int) int",
              "testCases": [
                { "input": "[]int{2, 1, 3, 5, 3, 2}", "output": "3", "note": "3 is seen again before 2 is" },
                { "input": "[]int{1, 2, 3, 4}", "output": "-1" },
                { "input": "[]int{1, 1, 2, 2}", "output": "1" }
              ],
              "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num  // Return the value, not just true\n        }\n        seen[num] = true\n    }\n    return -1\n}",
              "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!"
            },
            {
              "id": "v3",
              "title": "Count Unique Elements",
              "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
              "functionSignature": "func countUnique(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 3, 3, 3}", "output": "3", "note": "unique values: 1, 2, 3" },
                { "input": "[]int{5, 5, 5, 5}", "output": "1" },
                { "input": "[]int{1, 2, 3, 4, 5}", "output": "5" }
              ],
              "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
              "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!"
            },
            {
              "id": "v4",
              "title": "Find All Duplicates",
              "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
              "functionSignature": "func findDuplicates(nums []int) []int",
              "testCases": [
                { "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}", "output": "[2, 3]" },
                { "input": "[]int{1, 1, 2, 2, 3, 3}", "output": "[1, 2, 3]" },
                { "input": "[]int{1, 2, 3}", "output": "[]" }
              ],
              "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)  // Track what we've added to result\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
              "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result."
            },
            {
              "id": "v5",
              "title": "Common Elements",
              "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
              "functionSignature": "func hasCommon(a, b []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3}, []int{3, 4, 5}", "output": "true", "note": "3 is common" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "false" },
                { "input": "[]int{1}, []int{1}", "output": "true" }
              ],
              "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
              "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!"
            },
            {
              "id": "v6",
              "title": "Find Intersection",
              "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
              "functionSignature": "func intersection(a, b []int) []int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 1}, []int{2, 2}", "output": "[2]" },
                { "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}", "output": "[9, 4]", "note": "or [4, 9] - order doesn't matter" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "[]" }
              ],
              "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)  // Avoid duplicates in result\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
              "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result."
            }
          ]
        },
        {
          "id": "advanced_2",
          "baseTitle": "Two-Pointer In-Place",
          "concept": "Slow/Fast Pointer Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Remove Duplicates from Sorted Array",
              "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
              "functionSignature": "func removeDuplicates(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 2}", "output": "2", "note": "array becomes [1, 2, _]" },
                { "input": "[]int{0, 0, 1, 1, 2, 2, 3}", "output": "4", "note": "array becomes [0, 1, 2, 3, _, _, _]" },
                { "input": "[]int{1, 2, 3}", "output": "3" }
              ],
              "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}"
            },
            {
              "id": "v2",
              "title": "Remove Element",
              "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
              "functionSignature": "func removeElement(nums []int, val int) int",
              "testCases": [
                { "input": "[]int{3, 2, 2, 3}, 3", "output": "2", "note": "array becomes [2, 2, _, _]" },
                { "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2", "output": "5" },
                { "input": "[]int{1}, 1", "output": "0" }
              ],
              "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0."
            },
            {
              "id": "v3",
              "title": "Move Zeroes",
              "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
              "functionSignature": "func moveZeroes(nums []int)",
              "testCases": [
                { "input": "[]int{0, 1, 0, 3, 12}", "output": "[1, 3, 12, 0, 0]" },
                { "input": "[]int{0, 0, 1}", "output": "[1, 0, 0]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 2, 3]", "note": "no zeroes" }
              ],
              "solution": "func moveZeroes(nums []int) {\n    slow := 0  // Position to place next non-zero\n    \n    // Move all non-zeroes to the front\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    // Fill the rest with zeroes\n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
              "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!"
            },
            {
              "id": "v4",
              "title": "Remove Duplicates II (Allow 2)",
              "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
              "functionSignature": "func removeDuplicatesII(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1, 2, 2, 3}", "output": "5", "note": "becomes [1, 1, 2, 2, 3, _]" },
                { "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}", "output": "7" },
                { "input": "[]int{1, 1}", "output": "2" }
              ],
              "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2  // First two elements always kept\n    for fast := 2; fast < len(nums); fast++ {\n        // Compare with element two positions back\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2."
            },
            {
              "id": "v5",
              "title": "Sorted Squares",
              "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
              "functionSignature": "func sortedSquares(nums []int) []int",
              "testCases": [
                { "input": "[]int{-4, -1, 0, 3, 10}", "output": "[0, 1, 9, 16, 100]" },
                { "input": "[]int{-7, -3, 2, 3, 11}", "output": "[4, 9, 9, 49, 121]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 4, 9]" }
              ],
              "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1  // Fill from the end\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
              "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back."
            },
            {
              "id": "v6",
              "title": "Merge Sorted Array",
              "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
              "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
              "testCases": [
                { "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3", "output": "[1, 2, 2, 3, 5, 6]" },
                { "input": "[]int{1}, 1, []int{}, 0", "output": "[1]" },
                { "input": "[]int{0}, 0, []int{1}, 1", "output": "[1]" }
              ],
              "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    // Start from the end of both arrays\n    p1 := m - 1      // Last element in nums1's data\n    p2 := n - 1      // Last element in nums2\n    pos := m + n - 1 // Last position in nums1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
              "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place."
            }
          ]
        },
        {
          "id": "advanced_3",
          "baseTitle": "String Manipulation",
          "concept": "Runes + Two-Pointer Swap",
          "variants": [
            {
              "id": "v1",
              "title": "Reverse a String",
              "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
              "functionSignature": "func reverse(s string) string",
              "testCases": [
                { "input": "\"hello\"", "output": "\"olleh\"" },
                { "input": "\"‰∏ñÁïå\"", "output": "\"Áïå‰∏ñ\"" },
                { "input": "\"GoüöÄ\"", "output": "\"üöÄoG\"" }
              ],
              "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
            },
            {
              "id": "v2",
              "title": "Is Palindrome",
              "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
              "functionSignature": "func isPalindrome(s string) bool",
              "testCases": [
                { "input": "\"A man, a plan, a canal: Panama\"", "output": "true" },
                { "input": "\"race a car\"", "output": "false" },
                { "input": "\"Was it a car or a cat I saw?\"", "output": "true" }
              ],
              "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification."
            },
            {
              "id": "v3",
              "title": "Reverse Words in String",
              "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
              "functionSignature": "func reverseWords(s string) string",
              "testCases": [
                { "input": "\"hello world\"", "output": "\"world hello\"" },
                { "input": "\"the sky is blue\"", "output": "\"blue is sky the\"" },
                { "input": "\"Go\"", "output": "\"Go\"" }
              ],
              "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    // Reverse the words slice\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
              "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together."
            },
            {
              "id": "v4",
              "title": "Reverse Only Letters",
              "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
              "functionSignature": "func reverseOnlyLetters(s string) string",
              "testCases": [
                { "input": "\"a-bC-dEf-ghIj\"", "output": "\"j-Ih-gfE-dCba\"" },
                { "input": "\"ab-cd\"", "output": "\"dc-ba\"" },
                { "input": "\"Test1ng-Leet=code-Q!\"", "output": "\"Qedo1teleC-test=gnin-T!\"", "note": "wait that's wrong" }
              ],
              "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        // Skip non-letters on left\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        // Skip non-letters on right\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        // Swap letters\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
              "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic."
            },
            {
              "id": "v5",
              "title": "Valid Palindrome II",
              "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
              "functionSignature": "func validPalindromeII(s string) bool",
              "testCases": [
                { "input": "\"aba\"", "output": "true", "note": "already palindrome" },
                { "input": "\"abca\"", "output": "true", "note": "remove 'c' or 'b'" },
                { "input": "\"abc\"", "output": "false" }
              ],
              "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            // Try skipping either character\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
              "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true."
            },
            {
              "id": "v6",
              "title": "Rotate String Left",
              "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
              "functionSignature": "func rotateLeft(s string, k int) string",
              "testCases": [
                { "input": "\"abcdef\", 2", "output": "\"cdefab\"" },
                { "input": "\"hello\", 1", "output": "\"elloh\"" },
                { "input": "\"Go\", 4", "output": "\"Go\"", "note": "k=4 is same as k=0 for len=2" }
              ],
              "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)  // Handle k > length\n    \n    // Reverse first k, reverse rest, reverse all\n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
              "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!"
            }
          ]
        },
        {
          "id": "advanced_4",
          "baseTitle": "Map Counting",
          "concept": "Map Counting Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Word Counter",
              "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
              "functionSignature": "func wordCount(s string) map[string]int",
              "testCases": [
                { "input": "\"the quick brown fox jumps over the lazy dog\"", "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]" }
              ],
              "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}"
            },
            {
              "id": "v2",
              "title": "Most Frequent Element",
              "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
              "functionSignature": "func mostFrequent(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 3, 2, 1, 4, 1}", "output": "1", "note": "1 appears 3 times" },
                { "input": "[]int{5, 5, 4, 4, 4}", "output": "4" },
                { "input": "[]int{7}", "output": "7" }
              ],
              "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
              "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures."
            },
            {
              "id": "v3",
              "title": "First Unique Character",
              "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
              "functionSignature": "func firstUniqChar(s string) int",
              "testCases": [
                { "input": "\"leetcode\"", "output": "0", "note": "'l' is first unique" },
                { "input": "\"loveleetcode\"", "output": "2", "note": "'v' is first unique" },
                { "input": "\"aabb\"", "output": "-1" }
              ],
              "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    // First pass: count all characters\n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    // Second pass: find first with count 1\n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
              "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order."
            },
            {
              "id": "v4",
              "title": "Is Anagram",
              "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
              "functionSignature": "func isAnagram(s, t string) bool",
              "testCases": [
                { "input": "\"anagram\", \"nagaram\"", "output": "true" },
                { "input": "\"rat\", \"car\"", "output": "false" },
                { "input": "\"listen\", \"silent\"", "output": "true" }
              ],
              "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have."
            },
            {
              "id": "v5",
              "title": "Can Construct",
              "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
              "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
              "testCases": [
                { "input": "\"a\", \"b\"", "output": "false" },
                { "input": "\"aa\", \"aab\"", "output": "true" },
                { "input": "\"aa\", \"ab\"", "output": "false", "note": "need 2 a's but only 1" }
              ],
              "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    // Count available letters\n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    // Try to use letters\n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa."
            },
            {
              "id": "v6",
              "title": "Majority Element",
              "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
              "functionSignature": "func majorityElement(nums []int) int",
              "testCases": [
                { "input": "[]int{3, 2, 3}", "output": "3" },
                { "input": "[]int{2, 2, 1, 1, 1, 2, 2}", "output": "2" },
                { "input": "[]int{1, 1, 1, 1}", "output": "1" }
              ],
              "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1  // Won't reach here per problem guarantee\n}",
              "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!"
            }
          ]
        },
        {
          "id": "advanced_5",
          "baseTitle": "Hash Map Lookup",
          "concept": "Hash Map Complement Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Two Sum",
              "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
              "functionSignature": "func twoSum(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[0, 1]" },
                { "input": "[]int{3, 2, 4}, 6", "output": "[1, 2]" },
                { "input": "[]int{3, 3}, 6", "output": "[0, 1]" }
              ],
              "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}"
            },
            {
              "id": "v2",
              "title": "Two Sum II (Sorted Input)",
              "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
              "functionSignature": "func twoSumSorted(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[1, 2]", "note": "1-indexed!" },
                { "input": "[]int{2, 3, 4}, 6", "output": "[1, 3]" },
                { "input": "[]int{-1, 0}, -1", "output": "[1, 2]" }
              ],
              "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}  // 1-indexed\n        } else if sum < target {\n            left++  // Need bigger sum\n        } else {\n            right--  // Need smaller sum\n        }\n    }\n    return nil\n}",
              "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum."
            },
            {
              "id": "v3",
              "title": "Pair with Difference",
              "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
              "functionSignature": "func pairWithDiff(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{5, 20, 3, 2, 50, 80}, 78", "output": "[1, 5]", "note": "80 - 2 = 78... wait" },
                { "input": "[]int{1, 5, 3}, 2", "output": "[0, 2]", "note": "3 - 1 = 2" },
                { "input": "[]int{1, 2, 3}, 10", "output": "nil" }
              ],
              "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)  // value -> index\n    \n    for i, num := range nums {\n        // Check if num - target exists (num is larger)\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        // Check if num + target exists (num is smaller)\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
              "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k)."
            },
            {
              "id": "v4",
              "title": "Count Pairs with Sum",
              "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
              "functionSignature": "func countPairs(nums []int, target int) int",
              "testCases": [
                { "input": "[]int{1, 5, 7, 1}, 6", "output": "2", "note": "(1,5) and (1,5)" },
                { "input": "[]int{1, 1, 1, 1}, 2", "output": "2", "note": "two pairs of 1+1" },
                { "input": "[]int{1, 2, 3}, 10", "output": "0" }
              ],
              "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            // Same number: count pairs within this group\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            // Different numbers: multiply counts (only count once via complement > num)\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
              "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting."
            },
            {
              "id": "v5",
              "title": "Three Sum Exists",
              "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
              "functionSignature": "func threeSumExists(nums []int) bool",
              "testCases": [
                { "input": "[]int{-1, 0, 1, 2}", "output": "true", "note": "-1 + 0 + 1 = 0" },
                { "input": "[]int{1, 2, 3}", "output": "false" },
                { "input": "[]int{0, 0, 0}", "output": "true" }
              ],
              "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        // Skip duplicates for i\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        // Two-pointer for remaining two numbers\n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
              "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n¬≤) total."
            },
            {
              "id": "v6",
              "title": "Subarray Sum Equals K",
              "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
              "functionSignature": "func subarraySum(nums []int, k int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1}, 2", "output": "2", "note": "[1,1] at positions 0-1 and 1-2" },
                { "input": "[]int{1, 2, 3}, 3", "output": "2", "note": "[1,2] and [3]" },
                { "input": "[]int{1, -1, 0}, 0", "output": "3" }
              ],
              "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1  // Empty prefix has sum 0\n    \n    for _, num := range nums {\n        prefixSum += num\n        // If prefixSum - k exists, we found subarrays\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
              "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred."
            }
          ]
        },
        {
          "id": "advanced_6",
          "baseTitle": "Sliding Window",
          "concept": "Sliding Window Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Maximum Sum Subarray of Size K",
              "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
              "functionSignature": "func maxSumSubarray(nums []int, k int) int",
              "testCases": [
                { "input": "[]int{2, 1, 5, 1, 3, 2}, 3", "output": "9", "note": "subarray [5,1,3]" },
                { "input": "[]int{2, 3, 4, 1, 5}, 2", "output": "7", "note": "subarray [3,4]" },
                { "input": "[]int{1, 1, 1, 1}, 2", "output": "2" }
              ],
              "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    // Calculate sum of first window\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    // Slide the window\n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]  // Add new, remove old\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
              "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space."
            },
            {
              "id": "v2",
              "title": "Longest Substring Without Repeating",
              "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
              "functionSignature": "func lengthOfLongestSubstring(s string) int",
              "testCases": [
                { "input": "\"abcabcbb\"", "output": "3", "note": "\"abc\"" },
                { "input": "\"bbbbb\"", "output": "1", "note": "\"b\"" },
                { "input": "\"pwwkew\"", "output": "3", "note": "\"wke\"" }
              ],
              "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)  // char -> last index\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1  // Shrink window\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
              "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to."
            },
            {
              "id": "v3",
              "title": "Minimum Size Subarray Sum",
              "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
              "functionSignature": "func minSubarrayLen(target int, nums []int) int",
              "testCases": [
                { "input": "7, []int{2, 3, 1, 2, 4, 3}", "output": "2", "note": "[4,3] sums to 7" },
                { "input": "4, []int{1, 4, 4}", "output": "1", "note": "[4] alone >= 4" },
                { "input": "11, []int{1, 1, 1, 1}", "output": "0", "note": "can't reach 11" }
              ],
              "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1  // Impossible value\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        // Shrink window while sum >= target\n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
              "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern."
            }
          ]
        }
      ],
      "preExercises": {
        "advanced_1": {
          "title": "Pre-exercise: Map as a Set",
          "description": "Before tackling the algorithm, let's practice the core pattern: using a map to track what you've seen.",
          "exercises": [
            {
              "id": "pre1",
              "title": "Track Visited Pages",
              "problem": "You're building a browser history tracker. Write code that creates a <code>map[string]bool</code> called <code>visited</code>, marks three pages as visited, then checks if \"google.com\" has been visited.",
              "hints": [
                {
                  "title": "Creating the map",
                  "content": "Create with: <code>visited := make(map[string]bool)</code><br>This creates an empty map where keys are strings and values are booleans."
                },
                {
                  "title": "Marking as visited",
                  "content": "To mark a page as visited: <code>visited[\"google.com\"] = true</code><br>Do this for three different pages."
                },
                {
                  "title": "Checking if visited",
                  "content": "The simple way: <code>if visited[\"google.com\"]</code><br>This works because if the key doesn't exist, Go returns <code>false</code> (the zero value for bool)!"
                }
              ],
              "solution": "visited := make(map[string]bool)\n\n// Mark pages as visited\nvisited[\"google.com\"] = true\nvisited[\"github.com\"] = true\nvisited[\"go.dev\"] = true\n\n// Check if google.com was visited\nif visited[\"google.com\"] {\n    fmt.Println(\"You've been to google.com\")\n}\n\n// Check something NOT visited\nif visited[\"facebook.com\"] {\n    fmt.Println(\"You've been to facebook.com\")\n} else {\n    fmt.Println(\"Never visited facebook.com\")\n}",
              "expectedOutput": "You've been to google.com\nNever visited facebook.com",
              "keyInsight": "When you access a key that doesn't exist in a <code>map[T]bool</code>, Go returns <code>false</code>. This makes <code>if visited[key]</code> a clean way to check membership - no need for the comma-ok pattern here!"
            },
            {
              "id": "pre2",
              "title": "Unique Letter Collector",
              "problem": "Write code that loops through the string \"banana\" and collects each unique letter into a <code>map[rune]bool</code>. Print how many unique letters there are.",
              "hints": [
                {
                  "title": "Setup",
                  "content": "Create the map: <code>letters := make(map[rune]bool)</code><br>Loop with: <code>for _, char := range \"banana\"</code>"
                },
                {
                  "title": "Collecting",
                  "content": "For each character, just mark it as seen: <code>letters[char] = true</code><br>Maps automatically handle duplicates - setting the same key twice just overwrites."
                },
                {
                  "title": "Counting",
                  "content": "The number of unique letters is: <code>len(letters)</code>"
                }
              ],
              "solution": "letters := make(map[rune]bool)\n\nfor _, char := range \"banana\" {\n    letters[char] = true\n}\n\nfmt.Printf(\"Unique letters: %d\\n\", len(letters))  // 3: b, a, n",
              "expectedOutput": "Unique letters: 3",
              "keyInsight": "A map automatically handles duplicates - you can set the same key multiple times and it just overwrites. This is why <code>len(map)</code> gives you the count of unique keys!"
            }
          ]
        },
        "advanced_2": {
          "title": "Pre-exercise: Slow/Fast Pointer Prep",
          "description": "Before the in-place algorithm, let's practice the core logic of detecting duplicates in sorted arrays.",
          "exercises": [
            {
              "id": "pre2a",
              "title": "Copy Unique to New Slice",
              "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 3}</code>, create a NEW slice containing only the unique values <code>[1, 2, 3]</code>. Don't modify the original - just build a new one with <code>append</code>.",
              "hints": [
                {
                  "title": "Step 1: Setup",
                  "content": "<pre>nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element is always unique</pre>"
                },
                {
                  "title": "Step 2: Loop starting from index 1",
                  "content": "<pre>for i := 1; i < len(nums); i++ {\n    // Compare current with previous\n}</pre>"
                },
                {
                  "title": "Step 3: Append when different",
                  "content": "<pre>if nums[i] != nums[i-1] {\n    result = append(result, nums[i])\n}</pre>"
                }
              ],
              "solution": "nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element always unique\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        result = append(result, nums[i])\n    }\n}\n\nfmt.Println(result)  // [1 2 3]",
              "expectedOutput": "[1 2 3]",
              "keyInsight": "In a sorted array, duplicates are always adjacent! So we only need to compare each element with the one before it. This same logic powers the in-place algorithm - we'll just write to the array instead of appending."
            },
            {
              "id": "pre2b",
              "title": "Count Consecutive Groups",
              "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 2, 3}</code>, count how many distinct groups there are. Answer: 3 (the 1s, the 2s, and the 3).",
              "hints": [
                {
                  "title": "Step 1: Initialize counter",
                  "content": "<pre>nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group</pre>"
                },
                {
                  "title": "Step 2: Loop and count transitions",
                  "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}</pre>"
                }
              ],
              "solution": "nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}\n\nfmt.Printf(\"Groups: %d\\n\", groups)",
              "expectedOutput": "Groups: 3",
              "keyInsight": "This is exactly what the slow/fast algorithm returns! The slow pointer ends up at the last unique position, so slow+1 = number of unique elements = number of groups."
            }
          ]
        },
        "advanced_4": {
          "title": "Pre-exercise: Map Counting Prep",
          "description": "Before counting words, let's practice the building blocks: splitting strings and incrementing map values.",
          "exercises": [
            {
              "id": "pre4a",
              "title": "Explore strings.Fields",
              "problem": "Use <code>strings.Fields</code> to split the string <code>\"hello world go\"</code> into words and print each word on its own line.",
              "hints": [
                {
                  "title": "Step 1: Import and split",
                  "content": "<pre>import \"strings\"\n\nwords := strings.Fields(\"hello world go\")</pre>"
                },
                {
                  "title": "Step 2: Loop and print",
                  "content": "<pre>for _, word := range words {\n    fmt.Println(word)\n}</pre>"
                }
              ],
              "solution": "import \"strings\"\n\nwords := strings.Fields(\"hello world go\")\nfor _, word := range words {\n    fmt.Println(word)\n}",
              "expectedOutput": "hello\nworld\ngo",
              "keyInsight": "<code>strings.Fields</code> splits on any whitespace (spaces, tabs, newlines) and returns a <code>[]string</code>. It's smarter than <code>strings.Split(s, \" \")</code> because it handles multiple spaces correctly."
            },
            {
              "id": "pre4b",
              "title": "Count Letters (Simpler)",
              "problem": "Count how many times each letter appears in <code>\"hello\"</code>. Store in a <code>map[rune]int</code> and print the counts.",
              "hints": [
                {
                  "title": "Step 1: Create the map",
                  "content": "<pre>counts := make(map[rune]int)</pre>"
                },
                {
                  "title": "Step 2: Loop through string",
                  "content": "<pre>for _, char := range \"hello\" {\n    counts[char]++\n}</pre>"
                },
                {
                  "title": "Step 3: Print results",
                  "content": "<pre>for char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}</pre>"
                }
              ],
              "solution": "counts := make(map[rune]int)\n\nfor _, char := range \"hello\" {\n    counts[char]++\n}\n\nfor char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}",
              "expectedOutput": "h: 1\ne: 1\nl: 2\no: 1",
              "keyInsight": "The <code>++</code> operator works on map values! When the key doesn't exist, Go returns 0 (the zero value for int), then increments to 1. So <code>counts[char]++</code> handles both first-time and repeat cases."
            }
          ]
        },
        "advanced_5": {
          "title": "Pre-exercise: Two Sum Building Blocks",
          "description": "Before the full algorithm, let's practice the two key operations: looking up complements and building index maps.",
          "exercises": [
            {
              "id": "pre5a",
              "title": "Find Complement in Map",
              "problem": "Given this pre-built map <code>map[int]int{2: 0, 7: 1, 11: 2}</code> (value to index), target=9, and current number=7: calculate the complement and check if it exists in the map. Print the result.",
              "hints": [
                {
                  "title": "Step 1: Setup",
                  "content": "<pre>seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7</pre>"
                },
                {
                  "title": "Step 2: Calculate complement",
                  "content": "<pre>complement := target - num  // 9 - 7 = 2</pre>"
                },
                {
                  "title": "Step 3: Check map with comma-ok",
                  "content": "<pre>if idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found! %d is at index %d\\n\", complement, idx)\n}</pre>"
                }
              ],
              "solution": "seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7\n\ncomplement := target - num  // 9 - 7 = 2\n\nif idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found %d at index %d\\n\", complement, idx)\n} else {\n    fmt.Println(\"Not found\")\n}",
              "expectedOutput": "Found 2 at index 0",
              "keyInsight": "The complement is <code>target - current</code>. If we're looking for two numbers that sum to 9, and we have 7, we need to find 2. The map tells us WHERE we saw the 2 (at index 0)."
            },
            {
              "id": "pre5b",
              "title": "Build Value-to-Index Map",
              "problem": "Given <code>[]int{2, 7, 11}</code>, build a map that maps each value to its index: <code>map[int]int{2: 0, 7: 1, 11: 2}</code>.",
              "hints": [
                {
                  "title": "Step 1: Create empty map",
                  "content": "<pre>nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)</pre>"
                },
                {
                  "title": "Step 2: Loop with index",
                  "content": "<pre>for i, num := range nums {\n    valueToIndex[num] = i\n}</pre>"
                }
              ],
              "solution": "nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)\n\nfor i, num := range nums {\n    valueToIndex[num] = i\n}\n\nfmt.Println(valueToIndex)",
              "expectedOutput": "map[2:0 7:1 11:2]",
              "keyInsight": "The Two Sum algorithm builds this map AS it loops - checking for the complement first, then adding the current number. This ensures we don't match a number with itself!"
            }
          ]
        },
        "advanced_6": {
          "title": "Pre-exercise: Sliding Window Fundamentals",
          "description": "Before tackling sliding window problems, let's practice the core mechanics: managing a window and efficiently updating its state.",
          "exercises": [
            {
              "id": "pre6a",
              "title": "Fixed Window Sum",
              "problem": "Given <code>[]int{1, 2, 3, 4, 5}</code> and window size k=3, calculate the sum of the first window [1,2,3], then slide it one position and calculate the new sum [2,3,4] WITHOUT re-summing all elements.",
              "hints": [
                {
                  "title": "Step 1: Calculate first window sum",
                  "content": "<pre>nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first k elements\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Println(windowSum)  // 6</pre>"
                },
                {
                  "title": "Step 2: Slide the window",
                  "content": "<pre>// The trick: add new element, subtract old element\n// New element is at index k (which is 3)\n// Old element is at index 0\nwindowSum = windowSum + nums[k] - nums[0]</pre>"
                },
                {
                  "title": "Step 3: General formula",
                  "content": "When sliding from position i-1 to i:<pre>windowSum = windowSum + nums[i+k-1] - nums[i-1]</pre>Or equivalently, when the right edge moves to index i:<pre>windowSum = windowSum + nums[i] - nums[i-k]</pre>"
                }
              ],
              "solution": "nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first window\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Printf(\"Window [0:3] sum: %d\\n\", windowSum)  // 6\n\n// Slide window: add nums[3], remove nums[0]\nwindowSum = windowSum + nums[3] - nums[0]\nfmt.Printf(\"Window [1:4] sum: %d\\n\", windowSum)  // 9\n\n// Slide again: add nums[4], remove nums[1]\nwindowSum = windowSum + nums[4] - nums[1]\nfmt.Printf(\"Window [2:5] sum: %d\\n\", windowSum)  // 12",
              "expectedOutput": "Window [0:3] sum: 6\nWindow [1:4] sum: 9\nWindow [2:5] sum: 12",
              "keyInsight": "The sliding window trick: instead of recalculating the entire sum (O(k)), just add the new element and subtract the leaving element (O(1)). This makes processing all windows O(n) instead of O(n*k)!"
            },
            {
              "id": "pre6b",
              "title": "Variable Window with Map",
              "problem": "Track characters in a variable-size window. Given string \"abca\", add characters one by one to a <code>map[byte]int</code> (tracking counts), then simulate shrinking by decrementing counts.",
              "hints": [
                {
                  "title": "Step 1: Setup and expand",
                  "content": "<pre>s := \"abca\"\nseen := make(map[byte]int)\n\n// Add each character (expanding window)\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n    fmt.Printf(\"Added %c, counts: %v\\n\", s[i], seen)\n}</pre>"
                },
                {
                  "title": "Step 2: Shrink from left",
                  "content": "<pre>// Remove the first character (shrink)\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])  // Clean up zero counts\n}\nfmt.Printf(\"After removing %c: %v\\n\", s[0], seen)</pre>"
                }
              ],
              "solution": "s := \"abca\"\nseen := make(map[byte]int)\n\n// Expand: add all characters\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n}\nfmt.Printf(\"Full window: %v\\n\", seen)  // a:2, b:1, c:1\n\n// Shrink: remove from left (index 0 = 'a')\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])\n}\nfmt.Printf(\"After removing s[0]: %v\\n\", seen)  // a:1, b:1, c:1\n\n// Shrink more: remove s[1] = 'b'\nseen[s[1]]--\nif seen[s[1]] == 0 {\n    delete(seen, s[1])\n}\nfmt.Printf(\"After removing s[1]: %v\\n\", seen)  // a:1, c:1",
              "expectedOutput": "Full window: map[97:2 98:1 99:1]\nAfter removing s[0]: map[97:1 98:1 99:1]\nAfter removing s[1]: map[97:1 99:1]",
              "keyInsight": "Variable sliding windows use a map to track what's in the window. When expanding (right pointer moves), increment counts. When shrinking (left pointer moves), decrement counts. Delete keys when count hits 0 to keep the map clean."
            }
          ]
        }
      }
    };

    function loadVariants() {
        variantsData = variantsDataEmbedded;
        shuffleWarmups();
        shuffleIntermediate();
        shuffleChallenges();
        shuffleVariants();
    }

    function shuffleWarmups() {
        if (!variantsData || !variantsData.warmups) return;

        // Pick a random variant for each warmup
        variantsData.warmups.forEach(warmup => {
            const current = currentWarmupVariants[warmup.id];
            const available = warmup.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : warmup.variants;
            currentWarmupVariants[warmup.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderWarmups();

        // Visual feedback
        const btn = document.getElementById('shuffle-warmups-btn');
        if (btn) {
            btn.textContent = '‚úì Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            setTimeout(() => {
                btn.textContent = 'üé≤ Shuffle';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--green-bright)';
            }, 800);
        }
    }

    function renderWarmups() {
        const container = document.getElementById('warmups-container');
        if (!container || !variantsData || !variantsData.warmups) return;

        let html = '';

        variantsData.warmups.forEach((warmup, idx) => {
            const variant = currentWarmupVariants[warmup.id];
            const num = idx + 1;

            const conceptLink = conceptLinks[warmup.concept];
            const conceptHtml = conceptLink
                ? `<a href="${conceptLink}" class="concept-link" style="color: var(--green-dim); opacity: 0.8;">(${warmup.concept} ‚Üó)</a>`
                : `<span style="font-size: 0.75rem; opacity: 0.6; color: var(--text-dim);">(${warmup.concept})</span>`;

            html += `<div class="exercise">
                <h4>Warmup ${num}: ${variant.title} ${conceptHtml}</h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint) => {
                    // Support both old string format and new object format
                    const title = typeof hint === 'object' ? hint.title : 'üí° Hint';
                    const content = typeof hint === 'object' ? hint.content : hint;
                    html += `<details>
                        <summary>${title}</summary>
                        <div class="hint-content">${content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function shuffleIntermediate() {
        if (!variantsData || !variantsData.intermediate) return;

        // Pick a random variant for each intermediate exercise
        variantsData.intermediate.forEach(exercise => {
            const current = currentIntermediateVariants[exercise.id];
            const available = exercise.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : exercise.variants;
            currentIntermediateVariants[exercise.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderIntermediate();

        // Visual feedback
        const btn = document.getElementById('shuffle-intermediate-btn');
        if (btn) {
            btn.textContent = '‚úì Shuffled!';
            btn.style.background = 'var(--cyan)';
            btn.style.color = 'var(--bg-dark)';
            setTimeout(() => {
                btn.textContent = 'üé≤ Shuffle';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--cyan)';
            }, 800);
        }
    }

    function renderIntermediate() {
        const container = document.getElementById('intermediate-container');
        if (!container || !variantsData || !variantsData.intermediate) return;

        let html = '';

        variantsData.intermediate.forEach((exercise, idx) => {
            const variant = currentIntermediateVariants[exercise.id];
            const num = idx + 1;

            const conceptLink = conceptLinks[exercise.concept];
            const conceptHtml = conceptLink
                ? `<a href="${conceptLink}" class="concept-link" style="color: var(--cyan); opacity: 0.8;">(${exercise.concept} ‚Üó)</a>`
                : `<span style="font-size: 0.75rem; opacity: 0.6; color: var(--text-dim);">(${exercise.concept})</span>`;

            html += `<div class="exercise">
                <h4>Intermediate ${num}: ${variant.title} ${conceptHtml}</h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint) => {
                    // Support both old string format and new object format
                    const title = typeof hint === 'object' ? hint.title : 'üí° Hint';
                    const content = typeof hint === 'object' ? hint.content : hint;
                    html += `<details>
                        <summary>${title}</summary>
                        <div class="hint-content">${content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            // Add expected output if available
            if (variant.expected) {
                html += `<div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>${escapeHtml(variant.expected)}</pre>
                </div>`;
            }

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function shuffleChallenges() {
        if (!variantsData || !variantsData.challenges) return;

        // Pick a random variant for each challenge
        variantsData.challenges.forEach(challenge => {
            const current = currentChallengeVariants[challenge.id];
            const available = challenge.variants.filter(v => !current || v.id !== current.id);
            const pool = available.length > 0 ? available : challenge.variants;
            currentChallengeVariants[challenge.id] = pool[Math.floor(Math.random() * pool.length)];
        });

        renderChallenges();

        // Visual feedback
        const btn = document.getElementById('shuffle-challenges-btn');
        if (btn) {
            btn.textContent = '‚úì Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            btn.style.borderColor = 'var(--green-bright)';
            setTimeout(() => {
                btn.textContent = 'üé≤ Shuffle Challenges';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--orange)';
                btn.style.borderColor = 'var(--orange)';
            }, 800);
        }
    }

    function renderChallenges() {
        const container = document.getElementById('challenges-container');
        if (!container || !variantsData || !variantsData.challenges) return;

        let html = '';
        let currentBlock = 0;
        const blockNames = { 1: 'Core Patterns', 2: 'Building & Filtering', 3: 'Two-Pointer Foundation', 4: 'Two-Pointer Application' };
        const blockDifficulty = { 1: '‚≠ê', 2: '‚≠ê‚≠ê', 3: '‚≠ê‚≠ê', 4: '‚≠ê‚≠ê‚≠ê' };

        variantsData.challenges.forEach((challenge, idx) => {
            const variant = currentChallengeVariants[challenge.id];
            const num = idx + 1;
            const difficulty = blockDifficulty[challenge.block];

            // Add block header if new block
            if (challenge.block !== currentBlock) {
                currentBlock = challenge.block;
                html += `<p style="color: var(--cyan); font-size: 0.85rem; margin: 1.5rem 0 0.5rem; font-weight: 600;">Block ${currentBlock}: ${blockNames[currentBlock]} <span style="opacity: 0.7">${difficulty}</span></p>`;
            }

            html += `<div class="exercise">
                <h4>Challenge ${num}: ${variant.title} <span style="font-size: 0.75rem; opacity: 0.6;">${difficulty}</span></h4>
                <p>${variant.description}</p>`;

            // Add hints
            if (variant.hints) {
                variant.hints.forEach((hint) => {
                    // Support both old string format and new object format
                    const title = typeof hint === 'object' ? hint.title : 'üí° Hint';
                    const content = typeof hint === 'object' ? hint.content : hint;
                    html += `<details>
                        <summary>${title}</summary>
                        <div class="hint-content">${content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution</summary>
                <div class="hint-content"><pre>${escapeHtml(variant.solution)}</pre></div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${variant.testCases.map(tc =>
                    `${tc.input} ‚Üí ${tc.output}`
                ).join('\n')}</pre>
            </div></div>`;
        });

        container.innerHTML = html;
    }

    function shuffleVariants() {
        if (!variantsData) return;

        // Pick a DIFFERENT random variant for each exercise
        variantsData.advanced.forEach(exercise => {
            const currentVariant = currentVariants[exercise.id];
            const availableVariants = exercise.variants.filter(v =>
                !currentVariant || v.id !== currentVariant.id
            );
            // If all variants exhausted (only 1), just pick randomly
            const pool = availableVariants.length > 0 ? availableVariants : exercise.variants;
            const randomIndex = Math.floor(Math.random() * pool.length);
            currentVariants[exercise.id] = pool[randomIndex];
        });

        renderExercises();

        // Visual feedback - flash the button
        const btn = document.getElementById('shuffle-btn');
        if (btn) {
            btn.textContent = '‚úì Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            btn.style.borderColor = 'var(--green-bright)';
            setTimeout(() => {
                btn.textContent = 'üé≤ Shuffle Variants';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--purple)';
                btn.style.borderColor = 'var(--purple)';
            }, 800);
        }
    }

    function renderExercises() {
        const container = document.getElementById('advanced-exercises-container');
        if (!container) return;

        let html = '';

        // Render each advanced exercise with its pre-exercises
        variantsData.advanced.forEach((exercise, idx) => {
            const variant = currentVariants[exercise.id];
            const shared = sharedContent[exercise.id];
            const num = idx + 1;

            // Render pre-exercises for this specific advanced exercise (if any)
            html += renderPreExercisesFor(exercise.id, num, variant.title);

            html += `<div class="exercise">
                <h4>Advanced ${num}: ${variant.title}</h4>
                <p>${variant.description}</p>`;

            // Add pre-reading if available
            if (shared && shared.preReading) {
                html += `<details>
                    <summary>${shared.preReading.title}</summary>
                    <div class="hint-content">${shared.preReading.content}</div>
                </details>`;
            }

            // Add hints
            if (shared && shared.hints) {
                shared.hints.forEach(hint => {
                    html += `<details>
                        <summary>${hint.title}</summary>
                        <div class="hint-content">${hint.content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution with Explanation</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(variant.solution)}</pre>
                    ${variant.solutionNotes ? `<br>${variant.solutionNotes}` : ''}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${variant.testCases.map(tc =>
                    `${variant.functionSignature.match(/func (\w+)/)[1]}(${tc.input}) ‚Üí ${tc.output}${tc.note ? ` (${tc.note})` : ''}`
                ).join('\n')}</pre>
            </div>`;

            html += '</div>';

            // Add section divider (except after last exercise)
            if (idx < variantsData.advanced.length - 1) {
                html += `<hr style="border: none; border-top: 2px dashed var(--bg-lighter); margin: 3rem 0;">`;
            }
        });

        container.innerHTML = html;
    }

    function renderPreExercisesFor(advancedId, advancedNum, advancedTitle) {
        if (!variantsData.preExercises || !variantsData.preExercises[advancedId]) {
            return '';
        }

        const preEx = variantsData.preExercises[advancedId];
        let html = `
            <div style="background: linear-gradient(135deg, rgba(157, 0, 255, 0.15), rgba(157, 0, 255, 0.05)); border: 2px solid var(--purple); border-radius: 8px; padding: 1.5rem; margin: 2rem 0 1rem 0;">
                <div style="color: var(--purple); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 0.5rem;">‚¨áÔ∏è Warm up for Advanced ${advancedNum}</div>
                <div style="color: var(--text); font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">üéØ ${preEx.title}</div>
                <p style="color: var(--text-dim); margin: 0;">${preEx.description}</p>
            </div>`;

        preEx.exercises.forEach((ex, idx) => {
            html += `<div class="exercise" style="border-color: var(--purple); margin-bottom: 1.5rem;">
                <h4 style="color: var(--purple);">Warm-up ${advancedNum}.${idx + 1}: ${ex.title}</h4>
                <p>${ex.problem}</p>`;

            // Add hints
            ex.hints.forEach(hint => {
                html += `<details>
                    <summary>üí° ${hint.title}</summary>
                    <div class="hint-content">${hint.content}</div>
                </details>`;
            });

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(ex.solution)}</pre>
                    <br><strong>Key insight:</strong> ${ex.keyInsight}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${escapeHtml(ex.expectedOutput)}</pre>
            </div>`;

            html += '</div>';
        });

        // Add transition to main exercise
        html += `
            <div style="text-align: center; margin: 1.5rem 0; color: var(--purple); font-weight: 600;">
                ‚¨áÔ∏è Now try the full exercise ‚¨áÔ∏è
            </div>`;

        return html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Load variants on page load
    document.addEventListener('DOMContentLoaded', loadVariants);

    // Style the shuffle buttons hover
    document.addEventListener('DOMContentLoaded', () => {
        const advBtn = document.getElementById('shuffle-btn');
        if (advBtn) {
            advBtn.addEventListener('mouseenter', () => {
                advBtn.style.background = 'var(--purple)';
                advBtn.style.color = 'white';
            });
            advBtn.addEventListener('mouseleave', () => {
                advBtn.style.background = 'var(--bg-card)';
                advBtn.style.color = 'var(--purple)';
            });
        }

        const chalBtn = document.getElementById('shuffle-challenges-btn');
        if (chalBtn) {
            chalBtn.addEventListener('mouseenter', () => {
                chalBtn.style.background = 'var(--orange)';
                chalBtn.style.color = 'white';
            });
            chalBtn.addEventListener('mouseleave', () => {
                chalBtn.style.background = 'var(--bg-card)';
                chalBtn.style.color = 'var(--orange)';
            });
        }
    });
    </script>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
</body>
</html>

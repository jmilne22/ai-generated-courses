<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1: Go Fundamentals | Go From Python</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-dark: #0a0a0f; --bg-card: #12121a; --bg-code: #1a1a24; --green-bright: #00ff9d; --green-dim: #00cc7d; --green-glow: rgba(0, 255, 157, 0.15); --orange: #ff9d00; --purple: #9d00ff; --blue: #00b4ff; --red: #ff4757; --text-main: #e0e0e0; --text-dim: #888; --border: #2a2a3a; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Space Grotesk', sans-serif; background: var(--bg-dark); color: var(--text-main); min-height: 100vh; line-height: 1.7; }
        body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px); pointer-events: none; z-index: 1000; opacity: 0.3; }
        .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
        nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; border-bottom: 1px solid var(--border); margin-bottom: 3rem; }
        nav a { color: var(--text-dim); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; transition: color 0.3s; }
        nav a:hover { color: var(--green-bright); }
        .module-header { margin-bottom: 3rem; }
        .module-tag { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--green-bright); margin-bottom: 0.5rem; }
        h1 { font-size: 2.5rem; margin-bottom: 1rem; }
        .module-desc { color: var(--text-dim); font-size: 1.1rem; }
        .lesson { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; margin-bottom: 2rem; }
        .lesson h2 { font-size: 1.5rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem; }
        .lesson h2::before { content: '#'; color: var(--green-bright); font-family: 'JetBrains Mono', monospace; }
        .lesson h3 { font-size: 1.2rem; margin: 1.5rem 0 1rem; color: var(--orange); }
        .lesson p { margin-bottom: 1rem; color: var(--text-dim); }
        .lesson p strong { color: var(--text-main); }
        .code-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0; }
        @media (max-width: 700px) { .code-compare { grid-template-columns: 1fr; } }
        .code-block { background: var(--bg-code); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; margin: 1.5rem 0; }
        .code-header { background: var(--bg-dark); padding: 0.5rem 1rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 0.5rem; }
        .code-header.python { color: var(--orange); }
        .code-header.go { color: var(--blue); }
        .code-header::before { content: '‚óè'; font-size: 0.6rem; }
        pre { padding: 1rem; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; }
        .keyword { color: var(--purple); }
        .string { color: var(--green-bright); }
        .comment { color: var(--text-dim); }
        .func { color: var(--blue); }
        .type { color: var(--orange); }
        .number { color: var(--red); }
        .tip { background: rgba(0, 255, 157, 0.1); border-left: 3px solid var(--green-bright); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 0 8px 8px 0; }
        .tip-title { font-weight: 600; color: var(--green-bright); margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .warning { background: rgba(255, 157, 0, 0.1); border-left: 3px solid var(--orange); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 0 8px 8px 0; }
        .warning-title { font-weight: 600; color: var(--orange); margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .nav-buttons { display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border); }
        .nav-btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.5rem; background: var(--bg-card); border: 1px solid var(--border); color: var(--text-main); text-decoration: none; border-radius: 8px; transition: all 0.3s; }
        .nav-btn:hover { border-color: var(--green-bright); box-shadow: 0 0 20px var(--green-glow); }
        .nav-btn.primary { background: var(--green-bright); color: var(--bg-dark); }
        ul, ol { margin: 1rem 0 1rem 1.5rem; color: var(--text-dim); }
        li { margin-bottom: 0.5rem; }
        li strong { color: var(--text-main); }
        .inline-code { background: var(--bg-code); padding: 0.15rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em; color: var(--green-bright); }
        .exercise { background: var(--bg-code); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; }
        .exercise h4 { color: var(--text-main); margin-bottom: 0.5rem; font-size: 1rem; }
        .exercise > p { color: var(--text-dim); margin-bottom: 0.75rem; }
        details { margin-top: 0.75rem; }
        details summary { cursor: pointer; color: var(--blue); font-size: 0.85rem; padding: 0.3rem 0; user-select: none; }
        details summary:hover { color: var(--green-bright); }
        details[open] summary { color: var(--green-bright); }
        .hint-content { margin-top: 0.5rem; padding: 0.75rem; background: var(--bg-dark); border-radius: 6px; font-size: 0.85rem; color: var(--text-dim); }
        .hint-content code { background: var(--bg-code); padding: 0.1rem 0.3rem; border-radius: 3px; font-family: 'JetBrains Mono', monospace; color: var(--green-bright); font-size: 0.85rem; }
        .hint-content pre { margin: 0.5rem 0; padding: 0.75rem; background: var(--bg-code); border-radius: 4px; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; line-height: 1.5; color: var(--text-main); }
        .expected { margin-top: 0.75rem; padding: 0.75rem; background: rgba(0, 255, 157, 0.05); border: 1px dashed var(--green-bright); border-radius: 6px; }
        .expected-title { font-size: 0.75rem; color: var(--green-bright); margin-bottom: 0.4rem; text-transform: uppercase; font-weight: 600; }
        .expected pre { margin: 0; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--text-dim); }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="module0.html">‚Üê Module 0</a>
            <a href="module2.html">Module 2 ‚Üí</a>
        </nav>

        <div class="module-header">
            <div class="module-tag">// MODULE 01</div>
            <h1>Go Fundamentals</h1>
            <p class="module-desc">Variables, types, functions, and control flow. Every concept mapped from Python.</p>
        </div>

        <div class="lesson">
            <h2>Your First Go Program</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="func">print</span>(<span class="string">"Hello, World!"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="func">main</span>() {
    fmt.<span class="func">Println</span>(<span class="string">"Hello, World!"</span>)
}</pre>
                </div>
            </div>
            <ul>
                <li><strong>package main</strong> ‚Äî Entry point package</li>
                <li><strong>import "fmt"</strong> ‚Äî Import formatting package</li>
                <li><strong>func main()</strong> ‚Äî Entry point function</li>
            </ul>
            <div class="tip">
                <div class="tip-title">Run it</div>
                <p>Save as <span class="inline-code">main.go</span>, run with <span class="inline-code">go run main.go</span></p>
            </div>
        </div>

        <div class="lesson">
            <h2>Variables & Types</h2>
            <p>Python is dynamically typed. Go is statically typed. This is the biggest shift.</p>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre>name = <span class="string">"Alice"</span>
age = <span class="number">30</span>
height = <span class="number">5.9</span>
is_cool = <span class="keyword">True</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="comment">// Explicit types</span>
<span class="keyword">var</span> name <span class="type">string</span> = <span class="string">"Alice"</span>
<span class="keyword">var</span> age <span class="type">int</span> = <span class="number">30</span>

<span class="comment">// Type inference with :=</span>
name := <span class="string">"Alice"</span>
age := <span class="number">30</span>
height := <span class="number">5.9</span>
isCool := <span class="keyword">true</span></pre>
                </div>
            </div>
            <div class="warning">
                <div class="warning-title">Gotcha</div>
                <p><span class="inline-code">:=</span> only works inside functions. At package level, use <span class="inline-code">var</span>.</p>
            </div>
            <h3>Common Types</h3>
            <div class="code-block">
                <div class="code-header go">Types</div>
                <pre><span class="type">string</span>   <span class="comment">// "hello"</span>
<span class="type">int</span>      <span class="comment">// 42 (platform-dependent size)</span>
<span class="type">int64</span>    <span class="comment">// 64-bit integer</span>
<span class="type">float64</span>  <span class="comment">// 3.14</span>
<span class="type">bool</span>     <span class="comment">// true, false</span>
<span class="type">byte</span>     <span class="comment">// alias for uint8</span>
<span class="type">rune</span>     <span class="comment">// alias for int32 (Unicode code point)</span></pre>
            </div>
            <div class="tip">
                <div class="tip-title">Zero Values</div>
                <p>Uninitialized variables get zero values: <span class="inline-code">""</span> for string, <span class="inline-code">0</span> for numbers, <span class="inline-code">false</span> for bool.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Functions</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">def</span> <span class="func">add</span>(a, b):
    <span class="keyword">return</span> a + b

<span class="keyword">def</span> <span class="func">greet</span>(name):
    <span class="keyword">return</span> <span class="string">f"Hello, </span>{name}<span class="string">!"</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">func</span> <span class="func">add</span>(a <span class="type">int</span>, b <span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> a + b
}

<span class="keyword">func</span> <span class="func">greet</span>(name <span class="type">string</span>) <span class="type">string</span> {
    <span class="keyword">return</span> fmt.<span class="func">Sprintf</span>(<span class="string">"Hello, %s!"</span>, name)
}</pre>
                </div>
            </div>
            <h3>Multiple Return Values</h3>
            <div class="code-block">
                <div class="code-header go">Multiple returns</div>
                <pre><span class="keyword">func</span> <span class="func">divide</span>(a, b <span class="type">float64</span>) (<span class="type">float64</span>, <span class="type">error</span>) {
    <span class="keyword">if</span> b == <span class="number">0</span> {
        <span class="keyword">return</span> <span class="number">0</span>, errors.<span class="func">New</span>(<span class="string">"division by zero"</span>)
    }
    <span class="keyword">return</span> a / b, <span class="keyword">nil</span>
}

result, err := divide(<span class="number">10</span>, <span class="number">2</span>)
<span class="keyword">if</span> err != <span class="keyword">nil</span> {
    fmt.<span class="func">Println</span>(err)
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Control Flow</h2>
            <h3>If Statements</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span>:
    <span class="func">print</span>(<span class="string">"Can drink"</span>)
<span class="keyword">elif</span> age >= <span class="number">18</span>:
    <span class="func">print</span>(<span class="string">"Can vote"</span>)
<span class="keyword">else</span>:
    <span class="func">print</span>(<span class="string">"Too young"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can drink"</span>)
} <span class="keyword">else if</span> age >= <span class="number">18</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can vote"</span>)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Too young"</span>)
}</pre>
                </div>
            </div>
            <h3>For Loops (The Only Loop)</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">for</span> i <span class="keyword">in</span> <span class="func">range</span>(<span class="number">5</span>):
    <span class="func">print</span>(i)

<span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="func">enumerate</span>(items):
    <span class="func">print</span>(i, item)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">5</span>; i++ {
    fmt.<span class="func">Println</span>(i)
}

<span class="keyword">for</span> i, item := <span class="keyword">range</span> items {
    fmt.<span class="func">Println</span>(i, item)
}</pre>
                </div>
            </div>
        </div>

        <div class="lesson">
            <h2>Slices & Maps</h2>
            <h3>Slices (Dynamic Arrays)</h3>
            <div class="code-block">
                <div class="code-header go">Slices</div>
                <pre>nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}
nums = <span class="func">append</span>(nums, <span class="number">4</span>)
fmt.<span class="func">Println</span>(nums[<span class="number">0</span>])     <span class="comment">// 1</span>
fmt.<span class="func">Println</span>(<span class="func">len</span>(nums))  <span class="comment">// 4</span>
fmt.<span class="func">Println</span>(nums[<span class="number">1</span>:<span class="number">3</span>])   <span class="comment">// [2 3]</span></pre>
            </div>
            <h3>Maps (Dictionaries)</h3>
            <div class="code-block">
                <div class="code-header go">Creating and using maps</div>
                <pre>ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{
    <span class="string">"alice"</span>: <span class="number">30</span>,
    <span class="string">"bob"</span>:   <span class="number">25</span>,
}
ages[<span class="string">"charlie"</span>] = <span class="number">35</span>  <span class="comment">// Add new key</span>

fmt.<span class="func">Println</span>(ages[<span class="string">"alice"</span>])  <span class="comment">// 30</span></pre>
            </div>
            <div class="warning">
                <div class="warning-title">The Missing Key Problem</div>
                <p>In Python, accessing a missing key raises <span class="inline-code">KeyError</span>. In Go, it returns the <strong>zero value</strong> (0 for int, "" for string, etc). This means you can't tell if a key is missing or just has a zero value!</p>
            </div>
            <div class="code-block">
                <div class="code-header go">The "comma ok" idiom - checking if a key exists</div>
                <pre><span class="comment">// Wrong: Can't tell if dave is missing or age is 0</span>
age := ages[<span class="string">"dave"</span>]  <span class="comment">// Returns 0 (zero value)</span>

<span class="comment">// Right: Use the "comma ok" pattern</span>
<span class="comment">// ORDER: value, exists := map[key]</span>
<span class="comment">//        ‚Üë      ‚Üë</span>
<span class="comment">//        ‚îÇ      ‚îî‚îÄ‚îÄ boolean: true if found, false if not</span>
<span class="comment">//        ‚îî‚îÄ‚îÄ the actual value (or zero value)</span>

age, ok := ages[<span class="string">"dave"</span>]
<span class="comment">// age = 0 (zero value for int)</span>
<span class="comment">// ok = false (key doesn't exist)</span>

<span class="keyword">if</span> ok {
    fmt.<span class="func">Println</span>(<span class="string">"Found:"</span>, age)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Not found"</span>)  <span class="comment">// This prints</span>
}

<span class="comment">// Common shorthand: declare inside if statement</span>
<span class="keyword">if</span> age, ok := ages[<span class="string">"alice"</span>]; ok {
    <span class="comment">//   ‚Üë    ‚Üë</span>
    <span class="comment">//   30  true</span>
    fmt.<span class="func">Println</span>(<span class="string">"Alice is"</span>, age)  <span class="comment">// Prints: Alice is 30</span>
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header python">Python equivalent</div>
                <pre><span class="comment"># In Python, you might do:</span>
age = ages.get(<span class="string">"dave"</span>)  <span class="comment"># Returns None if missing</span>
<span class="keyword">if</span> age <span class="keyword">is not None</span>:
    <span class="func">print</span>(<span class="string">f"Found: </span>{age}<span class="string">"</span>)

<span class="comment"># Or check with 'in':</span>
<span class="keyword">if</span> <span class="string">"dave"</span> <span class="keyword">in</span> ages:
    <span class="func">print</span>(<span class="string">f"Found: </span>{ages[<span class="string">'dave'</span>]}<span class="string">"</span>)</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Remember the order!</div>
                <p><strong>First variable</strong> = the value you're looking for<br>
                <strong>Second variable</strong> = boolean (did we find it?)<br><br>
                Pattern: <span class="inline-code">value, found := map[key]</span><br>
                You can name them anything, but <span class="inline-code">ok</span> is conventional for the boolean.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            <p>Progress through each section in order. Each level introduces new concepts gradually.</p>
            
            <h3 style="color: var(--green-bright); margin-top: 1.5rem;">üî• Warmups</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice individual concepts you just learned.</p>
            
            <div class="exercise">
                <h4>Warmup 1: Simple Loop</h4>
                <p>Write a program that prints the numbers 1 to 10, one per line.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use a <code>for</code> loop with <code>i := 1; i <= 10; i++</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 10; i++ {
    fmt.Println(i)
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 2: If/Else Practice</h4>
                <p>Write a function <code>func checkNumber(n int) string</code> that returns "positive" if n > 0, "negative" if n < 0, and "zero" if n == 0.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use <code>if n > 0</code>, then <code>else if n < 0</code>, then <code>else</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func checkNumber(n int) string {
    if n > 0 {
        return "positive"
    } else if n < 0 {
        return "negative"
    } else {
        return "zero"
    }
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 3: Working with Slices</h4>
                <p>Create a slice of your three favorite numbers, then print each one using a <code>for</code> loop with <code>range</code>.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Create slice: <code>nums := []int{1, 2, 3}</code><br>
                        Loop: <code>for _, num := range nums</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>nums := []int{7, 42, 99}
for _, num := range nums {
    fmt.Println(num)
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 4: Simple Map</h4>
                <p>Create a map that stores the ages of three people, then print each person's name and age.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Map syntax: <code>map[string]int{"name": age}</code><br>
                        Loop: <code>for key, value := range mapName</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>ages := map[string]int{
    "alice": 30,
    "bob":   25,
    "carol": 35,
}
for name, age := range ages {
    fmt.Printf("%s is %d years old\n", name, age)
}</pre>
                    </div>
                </details>
            </div>

            <h3 style="color: var(--blue); margin-top: 2rem;">üìö Intermediate</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Each exercise introduces ONE new concept. Build your toolkit!</p>

            <div class="exercise">
                <h4>Intermediate 1: The make Function</h4>
                <p>Create an empty slice using <code>make([]int, 0)</code>, add three numbers to it with <code>append</code>, then print its length.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        <code>make()</code> creates an empty slice with space to grow.<br>
                        <code>make([]int, 0)</code> means: "make an int slice with 0 initial elements"<br>
                        Then use: <code>nums = append(nums, value)</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>nums := make([]int, 0)
nums = append(nums, 10)
nums = append(nums, 20)
nums = append(nums, 30)
fmt.Println(len(nums))  // prints 3</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>3</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 2: Checking Map Keys</h4>
                <p>Create a map of fruit prices. Check if "banana" exists in the map using the <code>value, ok := map[key]</code> pattern.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        The "comma ok" idiom: <code>value, ok := myMap[key]</code><br>
                        <code>ok</code> will be <code>true</code> if the key exists, <code>false</code> if not.<br>
                        Use it in an if statement: <code>if price, ok := prices["banana"]; ok { ... }</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>prices := map[string]float64{
    "apple":  1.50,
    "orange": 2.00,
}

if price, ok := prices["banana"]; ok {
    fmt.Printf("Banana costs $%.2f\n", price)
} else {
    fmt.Println("Banana not found")
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>Banana not found</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 3: Range with Index and Value</h4>
                <p>Create a slice of strings (your favorite foods). Loop through it and print both the index and value: "0: pizza", "1: tacos", etc.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        <code>range</code> returns TWO values: index and element<br>
                        <code>for i, food := range foods</code> where <code>i</code> is the index (0, 1, 2...) and <code>food</code> is the value
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>foods := []string{"pizza", "tacos", "sushi"}
for i, food := range foods {
    fmt.Printf("%d: %s\n", i, food)
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>0: pizza
1: tacos
2: sushi</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 4: Building Slices in a Loop</h4>
                <p>Create an empty slice, then use a loop to add only the even numbers from 1-10 to it. Print the final slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Start with: <code>evens := []int{}</code> (or <code>make([]int, 0)</code>)<br>
                        Loop from 1 to 10, check <code>if i%2 == 0</code>, then <code>append</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>evens := []int{}
for i := 1; i <= 10; i++ {
    if i%2 == 0 {
        evens = append(evens, i)
    }
}
fmt.Println(evens)  // [2 4 6 8 10]</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>[2 4 6 8 10]</pre>
                </div>
            </div>

            <h3 style="color: var(--orange); margin-top: 2rem;">üí™ Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Combine multiple concepts to solve these.</p>
            
            <div class="exercise">
                <h4>Challenge 1: Sum of Slice</h4>
                <p>Write a function <code>func sum(numbers []int) int</code> that returns the sum of all numbers in a slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Create a <code>total</code> variable, loop through with <code>range</code>, add each number to total, return total.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func sum(numbers []int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>sum([]int{1, 2, 3, 4, 5}) ‚Üí 15
sum([]int{10, 20}) ‚Üí 30</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 2: Find in Slice</h4>
                <p>Write a function <code>func contains(items []string, target string) bool</code> that returns true if target is in the slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Loop through items, compare each to target using <code>==</code>, return true if found, return false after loop.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func contains(items []string, target string) bool {
    for _, item := range items {
        if item == target {
            return true
        }
    }
    return false
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>contains([]string{"a", "b", "c"}, "b") ‚Üí true
contains([]string{"a", "b", "c"}, "z") ‚Üí false</pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>Challenge 3: FizzBuzz</h4>
                <p>Print numbers 1-20. For multiples of 3 print "Fizz", multiples of 5 print "Buzz", multiples of both print "FizzBuzz".</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use <code>%</code> (modulo) to check divisibility. Check for 15 first (or check 3 AND 5), otherwise "FizzBuzz" won't print.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 20; i++ {
    if i%15 == 0 {
        fmt.Println("FizzBuzz")
    } else if i%3 == 0 {
        fmt.Println("Fizz")
    } else if i%5 == 0 {
        fmt.Println("Buzz")
    } else {
        fmt.Println(i)
    }
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output (partial)</div>
                    <pre>1
2
Fizz
4
Buzz
Fizz
7
...
FizzBuzz</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 4: Find Maximum</h4>
                <p>Write a function <code>func max(nums []int) int</code> that returns the largest number in a slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Start by assuming the first element is the max. Then loop through the rest and update if you find a bigger number.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func max(nums []int) int {
    maxNum := nums[0]  // Start with first element
    for _, num := range nums {
        if num > maxNum {
            maxNum = num  // Found a bigger one!
        }
    }
    return maxNum
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>max([]int{3, 7, 2, 9, 1}) ‚Üí 9
max([]int{-5, -2, -10}) ‚Üí -2</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 5: Swap Elements</h4>
                <p>Write a function <code>func swapElements(nums []int, i int, j int)</code> that swaps the elements at positions i and j in the slice.</p>
                
                <details>
                    <summary>üí° New Concept: Simultaneous Assignment</summary>
                    <div class="hint-content">
                        Go lets you swap two variables in one line without a temp variable:<br>
                        <code>a, b = b, a</code><br><br>
                        This works because Go evaluates the right side first, then assigns to the left side.<br><br>
                        For arrays: <code>nums[i], nums[j] = nums[j], nums[i]</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use Go's simultaneous assignment to swap the values at the two positions in one line.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func swapElements(nums []int, i int, j int) {
    nums[i], nums[j] = nums[j], nums[i]
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Behavior</div>
                    <pre>nums := []int{1, 2, 3, 4, 5}
swapElements(nums, 0, 4)
fmt.Println(nums) ‚Üí [5, 2, 3, 4, 1]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 6: Palindrome Checker</h4>
                <p>A <strong>palindrome</strong> is something that reads the same forwards and backwards (like "racecar" or [1, 2, 3, 2, 1]). Write a function <code>func isPalindrome(nums []int) bool</code> that checks if a slice is a palindrome using two pointers.</p>
                
                <details>
                    <summary>üìñ What's a palindrome?</summary>
                    <div class="hint-content">
                        A <strong>palindrome</strong> is something that reads the same forwards and backwards.<br><br>
                        
                        <strong>String examples (most common):</strong><br>
                        ‚Ä¢ "racecar" ‚Üí reads the same both ways ‚úÖ<br>
                        ‚Ä¢ "level" ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ "noon" ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ "A man a plan a canal Panama" ‚Üí if you ignore spaces/capitals ‚úÖ<br>
                        ‚Ä¢ "hello" ‚Üí reads "olleh" backwards ‚ùå<br><br>
                        
                        <strong>Number examples:</strong><br>
                        ‚Ä¢ 121 ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ 12321 ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ 123 ‚Üí reads 321 backwards ‚ùå<br><br>
                        
                        <strong>Slice examples (what we're doing):</strong><br>
                        ‚Ä¢ [1, 2, 3, 2, 1] ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ [5, 5] ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ [7] ‚Üí single element is always a palindrome ‚úÖ<br>
                        ‚Ä¢ [1, 2, 3] ‚Üí reads [3, 2, 1] backwards ‚ùå<br><br>
                        
                        <strong>Note:</strong> Palindromes are usually words or phrases, but for this exercise we're using a slice of integers to keep it simple. You'll learn how to work with string palindromes in the Advanced section!<br><br>
                        
                        <strong>How to check:</strong><br>
                        Compare elements from both ends moving inward. If they're all equal, it's a palindrome!
                    </div>
                </details>
                
                <details>
                    <summary>üí° New Concept: Two-Pointer Comparison</summary>
                    <div class="hint-content">
                        Instead of swapping (like Challenge 5), we <strong>compare</strong> elements from both ends.<br><br>
                        
                        <strong>The pattern:</strong><br>
                        1. Start with <code>i</code> at the beginning, <code>j</code> at the end<br>
                        2. If <code>nums[i] != nums[j]</code>, return <code>false</code> (not a palindrome!)<br>
                        3. Move pointers toward middle: <code>i++</code>, <code>j--</code><br>
                        4. If we make it through the whole loop, return <code>true</code><br><br>
                        
                        <strong>Example:</strong> [1, 2, 3, 2, 1]<br>
                        ‚Ä¢ Compare nums[0] and nums[4]: 1 == 1 ‚úì<br>
                        ‚Ä¢ Compare nums[1] and nums[3]: 2 == 2 ‚úì<br>
                        ‚Ä¢ Middle element nums[2] = 3 (no need to compare with itself)<br>
                        ‚Ä¢ It's a palindrome! ‚úÖ
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: Loop structure</summary>
                    <div class="hint-content">
                        Use the same two-pointer loop as Challenge 5's swap:<br>
                        <code>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1</code><br><br>
                        But instead of swapping, you'll <strong>compare</strong> the values.
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: When to return false</summary>
                    <div class="hint-content">
                        Inside the loop, check: <code>if nums[i] != nums[j]</code><br>
                        If they don't match, immediately return <code>false</code> - it's not a palindrome!<br><br>
                        If the loop completes without returning false, return <code>true</code> at the end.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func isPalindrome(nums []int) bool {
    // Two pointers: start from both ends
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        // If any pair doesn't match, not a palindrome
        if nums[i] != nums[j] {
            return false
        }
    }
    // Made it through - it's a palindrome!
    return true
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>isPalindrome([]int{1, 2, 3, 2, 1}) ‚Üí true
isPalindrome([]int{1, 2, 3, 4, 5}) ‚Üí false
isPalindrome([]int{5, 5}) ‚Üí true
isPalindrome([]int{7}) ‚Üí true</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 7: Reverse a Slice</h4>
                <p>Write a function <code>func reverseSlice(nums []int) []int</code> that returns a new slice with elements in reverse order. This combines the two-pointer technique from Challenge 6 with swapping from Challenge 5!</p>
                
                <details>
                    <summary>üìñ Pre-reading: The Two-Pointer Technique</summary>
                    <div class="hint-content">
                        <strong>What is it?</strong> A common algorithm pattern where you use two variables (pointers) starting at different positions, moving toward each other.<br><br>
                        <strong>For reversing:</strong><br>
                        ‚Ä¢ Start one pointer at the beginning (index 0)<br>
                        ‚Ä¢ Start another at the end (index len-1)<br>
                        ‚Ä¢ Swap the elements they point to<br>
                        ‚Ä¢ Move pointers toward the middle<br>
                        ‚Ä¢ Stop when they meet<br><br>
                        <strong>Example:</strong> [1, 2, 3, 4, 5]<br>
                        Step 1: Swap positions 0 and 4 ‚Üí [5, 2, 3, 4, 1]<br>
                        Step 2: Swap positions 1 and 3 ‚Üí [5, 4, 3, 2, 1]<br>
                        Step 3: Position 2 stays (middle) ‚Üí Done!
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Combine what you learned:<br>
                        ‚Ä¢ Use the two-pointer loop from Challenge 6: <code>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1</code><br>
                        ‚Ä¢ Use the swap syntax from Challenge 5: <code>nums[i], nums[j] = nums[j], nums[i]</code><br><br>
                        The key difference from palindrome checking: instead of <strong>comparing</strong>, you <strong>swap</strong>!<br>
                        You can modify the slice in place - no need to create a copy.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func reverseSlice(nums []int) []int {
    // Two-pointer swap - reverse in place
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        // Swap elements at positions i and j
        nums[i], nums[j] = nums[j], nums[i]
    }
    return nums
}</pre>
                        <strong>Breaking down the for loop:</strong><br>
                        <code>i, j := 0, len(nums)-1</code> - Initialize TWO variables at once<br>
                        <code>i < j</code> - Continue while pointers haven't crossed<br>
                        <code>i, j = i+1, j-1</code> - Move BOTH pointers (i forward, j backward)<br><br>
                        
                        <strong>The swap:</strong><br>
                        <code>nums[i], nums[j] = nums[j], nums[i]</code><br>
                        This is Go's simultaneous assignment - it swaps values in one line!<br><br>
                        
                        <strong>Why this works:</strong><br>
                        We reverse the slice <strong>in place</strong> by swapping elements from both ends moving toward the middle. No need to create a copy!<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/tour/moretypes/7" target="_blank" style="color: var(--green-bright);">Go slices (official tour)</a><br>
                        ‚Ä¢ <a href="https://go.dev/blog/slices-intro" target="_blank" style="color: var(--green-bright);">Slices introduction (Go blog)</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverseSlice([]int{1, 2, 3, 4, 5}) ‚Üí [5, 4, 3, 2, 1]
reverseSlice([]int{10, 20}) ‚Üí [20, 10]</pre>
                </div>
            </div>

            <h3 style="color: var(--purple); margin-top: 2rem;">üöÄ Advanced</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">These combine many concepts and introduce new Go features. Complete challenges first!</p>

            <div class="exercise">
                <h4>Advanced 1: Contains Duplicate</h4>
                <p>Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.</p>
                
                <details>
                    <summary>üìñ Pre-reading: The "Have I Seen This?" Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                        
                        <strong>Naive approach (slow):</strong><br>
                        For each number, check every other number to see if it matches ‚Üí O(n¬≤)<br>
                        For 1000 numbers, that's 1,000,000 comparisons! üêå<br><br>
                        
                        <strong>Smart approach (fast):</strong><br>
                        Use a map to remember what you've seen ‚Üí O(n)<br>
                        For 1000 numbers, that's just 1000 operations! üöÄ<br><br>
                        
                        <strong>The Pattern:</strong><br>
                        1. Create an empty map to track what you've seen<br>
                        2. For each element, check: "Have I seen this before?"<br>
                        3. If yes ‚Üí found a duplicate!<br>
                        4. If no ‚Üí remember it and continue
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: What to track</summary>
                    <div class="hint-content">
                        You need a map to remember which numbers you've already seen.<br><br>
                        
                        What should the map store?<br>
                        ‚Ä¢ <strong>Key:</strong> the number itself (<code>int</code>)<br>
                        ‚Ä¢ <strong>Value:</strong> we just need to know it exists... so <code>bool</code> works!<br><br>
                        
                        Create it with: <code>seen := make(map[int]bool)</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: Checking if you've seen it</summary>
                    <div class="hint-content">
                        For each number in the slice:<br>
                        ‚Ä¢ Check: <code>if seen[num]</code> - is it in the map?<br>
                        ‚Ä¢ If <code>true</code>, you've seen it before ‚Üí return <code>true</code> (found duplicate!)<br>
                        ‚Ä¢ If <code>false</code>, mark it as seen: <code>seen[num] = true</code><br><br>
                        
                        This works because when a key doesn't exist in a map, Go returns the zero value for that type. For <code>bool</code>, the zero value is <code>false</code>.
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 3: What to return</summary>
                    <div class="hint-content">
                        If you make it through the entire loop without finding a duplicate, what does that mean?<br><br>
                        
                        All numbers are unique! Return <code>false</code> at the end.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func containsDuplicate(nums []int) bool {
    // Map to track what we've seen
    seen := make(map[int]bool)
    
    // Check each number
    for _, num := range nums {
        // Have we seen this before?
        if seen[num] {
            // Yes! Found a duplicate
            return true
        }
        // No, remember it for later
        seen[num] = true
    }
    
    // Made it through - no duplicates
    return false
}</pre>
                        <strong>Why this works:</strong><br>
                        The map acts as our "memory". Each time we see a number, we check our memory. If it's already there, we found a duplicate!<br><br>
                        
                        <strong>Note:</strong> We can simplify <code>if seen[num]</code> instead of <code>if _, ok := seen[num]; ok</code> because:<br>
                        ‚Ä¢ If the key exists, <code>seen[num]</code> returns <code>true</code><br>
                        ‚Ä¢ If the key doesn't exist, <code>seen[num]</code> returns <code>false</code> (the zero value for bool)<br>
                        ‚Ä¢ This works perfectly for our use case!<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - we only loop through once<br>
                        <strong>Space complexity:</strong> O(n) - worst case, store all unique numbers in map
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>containsDuplicate([]int{1, 2, 3, 1}) ‚Üí true
containsDuplicate([]int{1, 2, 3, 4}) ‚Üí false
containsDuplicate([]int{1, 1, 1, 1}) ‚Üí true</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 2: Remove Duplicates from Sorted Array</h4>
                <p>Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first part of the slice should contain the unique elements.</p>
                
                <details>
                    <summary>üìñ Pre-reading: The Slow/Fast Pointer Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> Given <code>[1,1,2,2,3]</code>, modify it to <code>[1,2,3,_,_]</code> and return <code>3</code><br><br>
                        
                        <strong>Key insight:</strong> The array is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                        
                        <strong>The Slow/Fast Pattern:</strong><br>
                        This is a NEW variant of two-pointers you haven't seen yet:<br>
                        ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                        ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                        ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                        
                        <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(nums); fast++ {  // Initialize IN loop (read position)
    // Compare nums[fast] with nums[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>
                        
                        <strong>Why this structure?</strong><br>
                        ‚Ä¢ <code>slow</code> only moves when we find something to write (conditional)<br>
                        ‚Ä¢ <code>fast</code> always moves to keep reading (automatic)<br>
                        ‚Ä¢ This is different from <code>i, j</code> in challenges where both moved together!<br><br>
                        
                        <strong>Example walkthrough:</strong> [1,1,2,2,3]<br>
                        ‚Ä¢ Start: slow=0, fast=1<br>
                        ‚Ä¢ nums[1]=1 same as nums[0]=1? Yes ‚Üí skip (only fast moves)<br>
                        ‚Ä¢ fast=2: nums[2]=2 different from nums[0]=1? Yes ‚Üí slow++, write nums[2] to nums[1]<br>
                        ‚Ä¢ fast=3: nums[3]=2 same as nums[1]=2? Yes ‚Üí skip<br>
                        ‚Ä¢ fast=4: nums[4]=3 different from nums[1]=2? Yes ‚Üí slow++, write nums[4] to nums[2]<br>
                        ‚Ä¢ Result: [1,2,3,2,3], return slow+1 = 3
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: Edge cases and setup</summary>
                    <div class="hint-content">
                        <strong>Handle edge cases first:</strong><br>
                        What if the array is empty? Add this at the start:<br>
                        <code>if len(nums) == 0 { return 0 }</code><br><br>
                        
                        <strong>Setup:</strong><br>
                        Initialize <code>slow := 0</code> before the loop (first element is always unique)<br>
                        Start your loop with <code>fast := 1</code> (compare from second element onward)
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: When to write</summary>
                    <div class="hint-content">
                        Loop while <code>fast < len(nums)</code><br><br>
                        
                        At each step, compare <code>nums[fast]</code> with <code>nums[slow]</code>:<br>
                        ‚Ä¢ If they're <strong>different</strong>: found a new unique value!<br>
                          - Increment <code>slow</code><br>
                          - Write <code>nums[fast]</code> to <code>nums[slow]</code><br>
                        ‚Ä¢ If they're the <strong>same</strong>: it's a duplicate, skip it<br>
                        ‚Ä¢ Always increment <code>fast</code> to keep reading
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 3: What to return</summary>
                    <div class="hint-content">
                        After the loop, <code>slow</code> points to the last unique element's index.<br><br>
                        
                        How many unique elements are there?<br>
                        Return <code>slow + 1</code> (because indices start at 0!)
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func removeDuplicates(nums []int) int {
    // Handle edge cases
    if len(nums) == 0 {
        return 0
    }
    
    // slow tracks where to write next unique value
    slow := 0
    
    // fast reads through the array
    for fast := 1; fast < len(nums); fast++ {
        // Found a new unique value?
        if nums[fast] != nums[slow] {
            slow++                    // Move write position
            nums[slow] = nums[fast]   // Write the unique value
        }
        // If same, just skip (fast++ happens automatically)
    }
    
    // slow points to last unique element
    // Number of unique elements is slow + 1
    return slow + 1
}</pre>
                        <strong>Visual walkthrough for [1,1,2,2,3]:</strong><br><br>
                        
                        <strong>Start:</strong> slow=0, fast=1<br>
                        Array: [<strong>1</strong>,1,2,2,3]<br><br>
                        
                        <strong>Step 1:</strong> nums[1]=1, nums[0]=1 ‚Üí same, skip<br>
                        slow=0, fast=2<br><br>
                        
                        <strong>Step 2:</strong> nums[2]=2, nums[0]=1 ‚Üí different!<br>
                        slow++ ‚Üí slow=1<br>
                        nums[1] = nums[2] ‚Üí nums[1] = 2<br>
                        Array: [1,<strong>2</strong>,2,2,3]<br>
                        fast=3<br><br>
                        
                        <strong>Step 3:</strong> nums[3]=2, nums[1]=2 ‚Üí same, skip<br>
                        slow=1, fast=4<br><br>
                        
                        <strong>Step 4:</strong> nums[4]=3, nums[1]=2 ‚Üí different!<br>
                        slow++ ‚Üí slow=2<br>
                        nums[2] = nums[4] ‚Üí nums[2] = 3<br>
                        Array: [1,2,<strong>3</strong>,2,3]<br><br>
                        
                        <strong>Done:</strong> return slow+1 = 3<br>
                        First 3 elements are unique: [1,2,3]<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - one pass through array<br>
                        <strong>Space complexity:</strong> O(1) - only use two pointers
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>removeDuplicates([]int{1, 1, 2}) ‚Üí 2 (array becomes [1, 2, _])
removeDuplicates([]int{0, 0, 1, 1, 2, 2, 3}) ‚Üí 4 (array becomes [0, 1, 2, 3, _, _, _])
removeDuplicates([]int{1, 2, 3}) ‚Üí 3 (no duplicates)</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 3: Reverse a String</h4>
                <p>Now write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.</p>
                
                <details>
                    <summary>üìñ Pre-reading: Strings vs Runes in Go</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                        
                        For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                        But for Unicode (emoji üéâ, Chinese ‰∏ñÁïå, Arabic, etc.), one character can be 2-4 bytes.<br><br>
                        
                        <strong>Example:</strong><br>
                        <code>"Hello"</code> = 5 bytes = 5 characters ‚úÖ<br>
                        <code>"‰∏ñÁïå"</code> = 6 bytes but only 2 characters! ‚ö†Ô∏è<br>
                        <code>"üéâ"</code> = 4 bytes but only 1 character! ‚ö†Ô∏è<br><br>
                        
                        <strong>The Solution: Runes</strong><br>
                        A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                        Converting to <code>[]rune</code> splits the string into actual characters, not bytes.<br><br>
                        
                        <strong>Why you can't just reverse bytes:</strong><br>
                        "Hiüéâ" as bytes = [72, 105, 240, 159, 142, 137]<br>
                        Reverse bytes = [137, 142, 159, 240, 105, 72] = gibberish! ‚ùå<br>
                        Must reverse as runes = ['üéâ', 'i', 'H'] = "üéâiH" ‚úÖ<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/blog/strings" target="_blank" style="color: var(--green-bright);">Strings, bytes, runes (Go blog)</a>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Combine what you learned:<br>
                        1. Convert string to <code>[]rune</code> with <code>[]rune(s)</code> - this handles Unicode properly<br>
                        2. Use the two-pointer reversal technique from Challenge 7: <code>for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1</code><br>
                        3. Swap elements: <code>runes[i], runes[j] = runes[j], runes[i]</code><br>
                        4. Convert back to string with <code>string(runes)</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Step-by-Step Explanation</summary>
                    <div class="hint-content">
<pre>func reverse(s string) string {
    // Step 1: Convert to runes (handles Unicode properly)
    runes := []rune(s)
    
    // Step 2: Two-pointer reversal
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        // Swap characters at positions i and j
        runes[i], runes[j] = runes[j], runes[i]
    }
    
    // Step 3: Convert back to string
    return string(runes)
}</pre>
                        <strong>Visual walkthrough for "Go":</strong><br>
                        Start: <code>['G', 'o']</code>, i=0, j=1<br>
                        Swap: <code>['o', 'G']</code><br>
                        Update: i=1, j=0 ‚Üí i < j is false, stop ‚úÖ<br><br>
                        
                        <strong>Visual walkthrough for "Hiüéâ":</strong><br>
                        Start: <code>['H', 'i', 'üéâ']</code>, i=0, j=2<br>
                        Iteration 1: Swap positions 0,2 ‚Üí <code>['üéâ', 'i', 'H']</code><br>
                        Update: i=1, j=1 ‚Üí i < j is false, stop ‚úÖ<br><br>
                        
                        <strong>Key Go syntax:</strong><br>
                        ‚Ä¢ <code>for a, b := x, y</code> - declare multiple variables<br>
                        ‚Ä¢ <code>a, b = b, a</code> - simultaneous swap (no temp variable needed!)<br>
                        ‚Ä¢ <code>string(runes)</code> - convert []rune back to string<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/ref/spec#For_statements" target="_blank" style="color: var(--green-bright);">For loop syntax (Go spec)</a><br>
                        ‚Ä¢ <a href="https://go.dev/ref/spec#Assignments" target="_blank" style="color: var(--green-bright);">Assignment statements</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverse("hello") ‚Üí "olleh"
reverse("‰∏ñÁïå") ‚Üí "Áïå‰∏ñ"
reverse("GoüöÄ") ‚Üí "üöÄoG"</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 4: Word Counter</h4>
                <p>Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.</p>
                
                <details>
                    <summary>üí° New Concept: strings.Fields()</summary>
                    <div class="hint-content">
                        Go's <code>strings</code> package has useful functions. You need to import it:<br>
                        <code>import "strings"</code><br><br>
                        <code>strings.Fields(s)</code> splits a string on any whitespace and returns <code>[]string</code><br>
                        Example: <code>strings.Fields("hello world")</code> ‚Üí <code>["hello", "world"]</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        1. Create a map with <code>make(map[string]int)</code><br>
                        2. Split the string with <code>strings.Fields(s)</code><br>
                        3. Loop through words and increment the count: <code>counts[word]++</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>import "strings"

func wordCount(s string) map[string]int {
    counts := make(map[string]int)
    for _, word := range strings.Fields(s) {
        counts[word]++
    }
    return counts
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>wordCount("the quick brown fox jumps over the lazy dog")
‚Üí map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 5: Two Sum</h4>
                <p>Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code></p>
                
                <details>
                    <summary>üìñ Pre-reading: The Hash Map Pattern</summary>
                    <div class="hint-content">
                        <strong>The Naive Approach (slow):</strong><br>
                        Check every pair of numbers - requires nested loops O(n¬≤)<br>
                        For 1000 numbers, that's 1,000,000 comparisons! üêå<br><br>
                        
                        <strong>The Smart Approach (fast):</strong><br>
                        Use a map to remember what you've seen - only one loop O(n)<br>
                        For 1000 numbers, that's just 1000 operations! üöÄ<br><br>
                        
                        <strong>The Key Insight:</strong><br>
                        If target = 9 and current number = 2, we need to find 7.<br>
                        Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                        Maps make this lookup instant!<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank" style="color: var(--green-bright);">Two Sum explained (video)</a><br>
                        ‚Ä¢ <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" style="color: var(--green-bright);">Hash tables (Wikipedia)</a>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Strategy: The Map Lookup Pattern</summary>
                    <div class="hint-content">
                        This is a classic algorithm pattern. Instead of checking every pair (slow), use a map to remember what you've seen.<br><br>
                        For each number, ask: "Have I seen the number that would complete this sum?"<br>
                        If target is 9 and current number is 2, look for 7 in your map.<br>
                        If found ‚Üí return both indices!<br>
                        If not ‚Üí remember 2 and its index for later
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        1. Create a map: <code>seen := make(map[int]int)</code> (number ‚Üí index)<br>
                        2. For each number, calculate: <code>complement := target - num</code><br>
                        3. Check: <code>if j, ok := seen[complement]; ok { return []int{j, i} }</code><br>
                        4. Store current: <code>seen[num] = i</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Visual Walkthrough</summary>
                    <div class="hint-content">
<pre>func twoSum(nums []int, target int) []int {
    // Map to remember: number ‚Üí its index
    seen := make(map[int]int)
    
    // Loop through each number
    for i, num := range nums {
        // What number would complete the sum?
        complement := target - num
        
        // Have we seen that number before?
        if j, ok := seen[complement]; ok {
            // Yes! Return both indices
            return []int{j, i}
        }
        
        // No, remember this number for later
        seen[num] = i
    }
    
    // No solution found
    return nil
}</pre>
                        <strong>Visual walkthrough:</strong><br>
                        Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code><br><br>
                        
                        <strong>Iteration 1:</strong> i=0, num=2<br>
                        ‚Ä¢ complement = 9 - 2 = 7<br>
                        ‚Ä¢ Is 7 in seen? No<br>
                        ‚Ä¢ Add to map: seen = {2: 0}<br><br>
                        
                        <strong>Iteration 2:</strong> i=1, num=7<br>
                        ‚Ä¢ complement = 9 - 7 = 2<br>
                        ‚Ä¢ Is 2 in seen? Yes! (at index 0) ‚úÖ<br>
                        ‚Ä¢ Return [0, 1]<br><br>
                        
                        <strong>Why this works:</strong><br>
                        When we're at 7, we look back and say "I've seen 2 before at index 0"<br>
                        2 + 7 = 9, so we return indices [0, 1]!<br><br>
                        
                        <strong>Key concepts used:</strong><br>
                        ‚Ä¢ <code>make(map[int]int)</code> - create empty map<br>
                        ‚Ä¢ <code>if j, ok := map[key]; ok</code> - check if key exists<br>
                        ‚Ä¢ <code>map[key] = value</code> - store in map<br>
                        ‚Ä¢ <code>[]int{a, b}</code> - create slice literal<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/blog/maps" target="_blank" style="color: var(--green-bright);">Go maps in action</a><br>
                        ‚Ä¢ <a href="https://pkg.go.dev/builtin#make" target="_blank" style="color: var(--green-bright);">The make function</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>twoSum([]int{2, 7, 11, 15}, 9) ‚Üí [0, 1]
twoSum([]int{3, 2, 4}, 6) ‚Üí [1, 2]
twoSum([]int{3, 3}, 6) ‚Üí [0, 1]</pre>
                </div>
            </div>

            <div class="tip">
                <div class="tip-title">Learning Path</div>
                <p><strong>Warmups</strong> ‚Üí master basic syntax<br>
                <strong>Intermediate</strong> ‚Üí learn one new concept at a time<br>
                <strong>Challenges</strong> ‚Üí combine what you know in small steps<br>
                <strong>Advanced</strong> ‚Üí tackle algorithms with proper scaffolding<br><br>
                Challenge 6 (palindrome) teaches you the two-pointer <strong>comparison</strong> pattern, then Challenge 7 (reverse) uses the same pattern but with <strong>swapping</strong> instead. This builds understanding step by step!<br><br>
                Stuck? Check the hint. Still stuck after 5 minutes? Check the solution and study it!</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 1 Summary</h2>
            <h3>Core Concepts</h3>
            <ul>
                <li><strong>:=</strong> for declaration + assignment inside functions</li>
                <li><strong>Types:</strong> string, int, float64, bool (statically typed!)</li>
                <li><strong>Functions:</strong> <span class="inline-code">func name(params) returnType { }</span></li>
                <li><strong>Multiple returns:</strong> <span class="inline-code">func f() (int, error)</span></li>
                <li><strong>Slices:</strong> <span class="inline-code">[]Type{}</span> - dynamic arrays</li>
                <li><strong>Maps:</strong> <span class="inline-code">map[KeyType]ValueType{}</span> - like dictionaries</li>
            </ul>
            
            <h3>Key Patterns You Learned</h3>
            <ul>
                <li><strong>The "comma ok" idiom:</strong> <span class="inline-code">value, ok := map[key]</span> - check if a map key exists</li>
                <li><strong>Simultaneous assignment:</strong> <span class="inline-code">a, b = b, a</span> - swap without temp variable</li>
            </ul>
            
            <h3>Algorithm Patterns & When to Use Them</h3>
            <ul>
                <li><strong>Two-pointer (opposite ends):</strong> When you need to work from both ends toward the middle
                    <ul style="margin-top: 0.5rem;">
                        <li>Palindrome checking</li>
                        <li>Reversing arrays/strings</li>
                        <li>Pattern: <span class="inline-code">for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1</span></li>
                    </ul>
                </li>
                <li><strong>Slow/fast pointers:</strong> When one pointer reads and another writes, moving at different speeds
                    <ul style="margin-top: 0.5rem;">
                        <li>Removing duplicates from sorted arrays</li>
                        <li>In-place array modifications</li>
                        <li>Pattern: <span class="inline-code">slow := 0</span> outside, <span class="inline-code">for fast := 1; ...</span> inside</li>
                    </ul>
                </li>
                <li><strong>Map for tracking:</strong> When you need to remember "have I seen this before?"
                    <ul style="margin-top: 0.5rem;">
                        <li>Finding duplicates</li>
                        <li>Counting occurrences</li>
                        <li>Two Sum (storing complements)</li>
                        <li>Pattern: Check map first, then add to map if not found</li>
                    </ul>
                </li>
                <li><strong>Building slices with append:</strong> When you need to filter or transform data
                    <ul style="margin-top: 0.5rem;">
                        <li>Filtering even numbers</li>
                        <li>Collecting results dynamically</li>
                        <li>Pattern: Start with <span class="inline-code">result := []Type{}</span>, then <span class="inline-code">result = append(result, item)</span></li>
                    </ul>
                </li>
            </ul>
            
            <h3>Common Gotchas</h3>
            <ul>
                <li><strong>Missing map keys return zero values</strong> - use "comma ok" to check if key exists</li>
                <li><strong>Strings are bytes, not characters</strong> - use <span class="inline-code">[]rune(s)</span> for Unicode</li>
                <li><strong>Slices are references</strong> - modifying a slice modifies the original</li>
                <li><strong>:= only works inside functions</strong> - use <span class="inline-code">var</span> at package level</li>
            </ul>
            
            <h3>Next Steps</h3>
            <p style="color: var(--text-dim);">You now have the fundamentals to solve many LeetCode Easy problems! Module 2 will cover pointers, structs, and methods - the building blocks for more complex programs.</p>
        </div>

        <div class="nav-buttons">
            <a href="module0.html" class="nav-btn">‚Üê Module 0</a>
            <a href="module2.html" class="nav-btn primary">Module 2: Pointers ‚Üí</a>
        </div>
    </div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1: Go Fundamentals | Go From Python</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --bg-dark: #0a0a0f; --bg-card: #12121a; --bg-code: #1a1a24; --green-bright: #00ff9d; --green-dim: #00cc7d; --green-glow: rgba(0, 255, 157, 0.15); --orange: #ff9d00; --purple: #9d00ff; --blue: #00b4ff; --red: #ff4757; --text-main: #e0e0e0; --text-dim: #888; --border: #2a2a3a; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Space Grotesk', sans-serif; background: var(--bg-dark); color: var(--text-main); min-height: 100vh; line-height: 1.7; }
        body::before { content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: repeating-linear-gradient(0deg, rgba(0,0,0,0.1) 0px, rgba(0,0,0,0.1) 1px, transparent 1px, transparent 2px); pointer-events: none; z-index: 1000; opacity: 0.3; }
        .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
        nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 0; border-bottom: 1px solid var(--border); margin-bottom: 3rem; }
        nav a { color: var(--text-dim); text-decoration: none; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; transition: color 0.3s; }
        nav a:hover { color: var(--green-bright); }
        .module-header { margin-bottom: 3rem; }
        .module-tag { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--green-bright); margin-bottom: 0.5rem; }
        h1 { font-size: 2.5rem; margin-bottom: 1rem; }
        .module-desc { color: var(--text-dim); font-size: 1.1rem; }
        .lesson { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 2rem; margin-bottom: 2rem; }
        .lesson h2 { font-size: 1.5rem; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.75rem; }
        .lesson h2::before { content: '#'; color: var(--green-bright); font-family: 'JetBrains Mono', monospace; }
        .lesson h3 { font-size: 1.2rem; margin: 1.5rem 0 1rem; color: var(--orange); }
        .lesson p { margin-bottom: 1rem; color: var(--text-dim); }
        .lesson p strong { color: var(--text-main); }
        .code-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0; }
        @media (max-width: 700px) { .code-compare { grid-template-columns: 1fr; } }
        .code-block { background: var(--bg-code); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; margin: 1.5rem 0; }
        .code-header { background: var(--bg-dark); padding: 0.5rem 1rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 0.5rem; }
        .code-header.python { color: var(--orange); }
        .code-header.go { color: var(--blue); }
        .code-header::before { content: '‚óè'; font-size: 0.6rem; }
        pre { padding: 1rem; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; }
        .keyword { color: var(--purple); }
        .string { color: var(--green-bright); }
        .comment { color: var(--text-dim); }
        .func { color: var(--blue); }
        .type { color: var(--orange); }
        .number { color: var(--red); }
        .tip { background: rgba(0, 255, 157, 0.1); border-left: 3px solid var(--green-bright); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 0 8px 8px 0; }
        .tip-title { font-weight: 600; color: var(--green-bright); margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .warning { background: rgba(255, 157, 0, 0.1); border-left: 3px solid var(--orange); padding: 1rem 1.5rem; margin: 1.5rem 0; border-radius: 0 8px 8px 0; }
        .warning-title { font-weight: 600; color: var(--orange); margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        .nav-buttons { display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border); }
        .nav-btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.5rem; background: var(--bg-card); border: 1px solid var(--border); color: var(--text-main); text-decoration: none; border-radius: 8px; transition: all 0.3s; }
        .nav-btn:hover { border-color: var(--green-bright); box-shadow: 0 0 20px var(--green-glow); }
        .nav-btn.primary { background: var(--green-bright); color: var(--bg-dark); }
        ul, ol { margin: 1rem 0 1rem 1.5rem; color: var(--text-dim); }
        li { margin-bottom: 0.5rem; }
        li strong { color: var(--text-main); }
        .inline-code { background: var(--bg-code); padding: 0.15rem 0.5rem; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 0.85em; color: var(--green-bright); }
        .exercise { background: var(--bg-code); border: 1px solid var(--border); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; }
        .exercise h4 { color: var(--text-main); margin-bottom: 0.5rem; font-size: 1rem; }
        .exercise > p { color: var(--text-dim); margin-bottom: 0.75rem; }
        details { margin-top: 0.75rem; }
        details summary { cursor: pointer; color: var(--blue); font-size: 0.85rem; padding: 0.3rem 0; user-select: none; }
        details summary:hover { color: var(--green-bright); }
        details[open] summary { color: var(--green-bright); }
        .hint-content { margin-top: 0.5rem; padding: 0.75rem; background: var(--bg-dark); border-radius: 6px; font-size: 0.85rem; color: var(--text-dim); }
        .hint-content code { background: var(--bg-code); padding: 0.1rem 0.3rem; border-radius: 3px; font-family: 'JetBrains Mono', monospace; color: var(--green-bright); font-size: 0.85rem; }
        .hint-content pre { margin: 0.5rem 0; padding: 0.75rem; background: var(--bg-code); border-radius: 4px; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; line-height: 1.5; color: var(--text-main); }
        .expected { margin-top: 0.75rem; padding: 0.75rem; background: rgba(0, 255, 157, 0.05); border: 1px dashed var(--green-bright); border-radius: 6px; }
        .expected-title { font-size: 0.75rem; color: var(--green-bright); margin-bottom: 0.4rem; text-transform: uppercase; font-weight: 600; }
        .expected pre { margin: 0; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--text-dim); }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="module0.html">‚Üê Module 0</a>
            <a href="module2.html">Module 2 ‚Üí</a>
        </nav>

        <div class="module-header">
            <div class="module-tag">// MODULE 01</div>
            <h1>Go Fundamentals</h1>
            <p class="module-desc">Variables, types, functions, and control flow. Every concept mapped from Python.</p>
        </div>

        <div class="lesson">
            <h2>Your First Go Program</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="func">print</span>(<span class="string">"Hello, World!"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"fmt"</span>

<span class="keyword">func</span> <span class="func">main</span>() {
    fmt.<span class="func">Println</span>(<span class="string">"Hello, World!"</span>)
}</pre>
                </div>
            </div>
            <ul>
                <li><strong>package main</strong> ‚Äî Entry point package</li>
                <li><strong>import "fmt"</strong> ‚Äî Import formatting package</li>
                <li><strong>func main()</strong> ‚Äî Entry point function</li>
            </ul>
            <div class="tip">
                <div class="tip-title">Run it</div>
                <p>Save as <span class="inline-code">main.go</span>, run with <span class="inline-code">go run main.go</span></p>
            </div>
        </div>

        <div class="lesson">
            <h2>Variables & Types</h2>
            <p>Python is dynamically typed. Go is statically typed. This is the biggest shift.</p>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre>name = <span class="string">"Alice"</span>
age = <span class="number">30</span>
height = <span class="number">5.9</span>
is_cool = <span class="keyword">True</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="comment">// Explicit types</span>
<span class="keyword">var</span> name <span class="type">string</span> = <span class="string">"Alice"</span>
<span class="keyword">var</span> age <span class="type">int</span> = <span class="number">30</span>

<span class="comment">// Type inference with :=</span>
name := <span class="string">"Alice"</span>
age := <span class="number">30</span>
height := <span class="number">5.9</span>
isCool := <span class="keyword">true</span></pre>
                </div>
            </div>
            <div class="warning">
                <div class="warning-title">Gotcha</div>
                <p><span class="inline-code">:=</span> only works inside functions. At package level, use <span class="inline-code">var</span>.</p>
            </div>
            <h3>Common Types</h3>
            <div class="code-block">
                <div class="code-header go">Types</div>
                <pre><span class="type">string</span>   <span class="comment">// "hello"</span>
<span class="type">int</span>      <span class="comment">// 42 (platform-dependent size)</span>
<span class="type">int64</span>    <span class="comment">// 64-bit integer</span>
<span class="type">float64</span>  <span class="comment">// 3.14</span>
<span class="type">bool</span>     <span class="comment">// true, false</span>
<span class="type">byte</span>     <span class="comment">// alias for uint8</span>
<span class="type">rune</span>     <span class="comment">// alias for int32 (Unicode code point)</span></pre>
            </div>
            <div class="tip">
                <div class="tip-title">Zero Values</div>
                <p>Uninitialized variables get zero values: <span class="inline-code">""</span> for string, <span class="inline-code">0</span> for numbers, <span class="inline-code">false</span> for bool.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Functions</h2>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">def</span> <span class="func">add</span>(a, b):
    <span class="keyword">return</span> a + b

<span class="keyword">def</span> <span class="func">greet</span>(name):
    <span class="keyword">return</span> <span class="string">f"Hello, </span>{name}<span class="string">!"</span></pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">func</span> <span class="func">add</span>(a <span class="type">int</span>, b <span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> a + b
}

<span class="keyword">func</span> <span class="func">greet</span>(name <span class="type">string</span>) <span class="type">string</span> {
    <span class="keyword">return</span> fmt.<span class="func">Sprintf</span>(<span class="string">"Hello, %s!"</span>, name)
}</pre>
                </div>
            </div>
            <h3>Multiple Return Values</h3>
            <div class="code-block">
                <div class="code-header go">Multiple returns</div>
                <pre><span class="keyword">func</span> <span class="func">divide</span>(a, b <span class="type">float64</span>) (<span class="type">float64</span>, <span class="type">error</span>) {
    <span class="keyword">if</span> b == <span class="number">0</span> {
        <span class="keyword">return</span> <span class="number">0</span>, errors.<span class="func">New</span>(<span class="string">"division by zero"</span>)
    }
    <span class="keyword">return</span> a / b, <span class="keyword">nil</span>
}

result, err := divide(<span class="number">10</span>, <span class="number">2</span>)
<span class="keyword">if</span> err != <span class="keyword">nil</span> {
    fmt.<span class="func">Println</span>(err)
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Control Flow</h2>
            <h3>If Statements</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span>:
    <span class="func">print</span>(<span class="string">"Can drink"</span>)
<span class="keyword">elif</span> age >= <span class="number">18</span>:
    <span class="func">print</span>(<span class="string">"Can vote"</span>)
<span class="keyword">else</span>:
    <span class="func">print</span>(<span class="string">"Too young"</span>)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">if</span> age >= <span class="number">21</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can drink"</span>)
} <span class="keyword">else if</span> age >= <span class="number">18</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Can vote"</span>)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Too young"</span>)
}</pre>
                </div>
            </div>
            <h3>For Loops (The Only Loop)</h3>
            <div class="code-compare">
                <div class="code-block" style="margin:0">
                    <div class="code-header python">Python</div>
                    <pre><span class="keyword">for</span> i <span class="keyword">in</span> <span class="func">range</span>(<span class="number">5</span>):
    <span class="func">print</span>(i)

<span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="func">enumerate</span>(items):
    <span class="func">print</span>(i, item)</pre>
                </div>
                <div class="code-block" style="margin:0">
                    <div class="code-header go">Go</div>
                    <pre><span class="keyword">for</span> i := <span class="number">0</span>; i < <span class="number">5</span>; i++ {
    fmt.<span class="func">Println</span>(i)
}

<span class="keyword">for</span> i, item := <span class="keyword">range</span> items {
    fmt.<span class="func">Println</span>(i, item)
}</pre>
                </div>
            </div>
        </div>

        <div class="lesson">
            <h2>Slices & Maps</h2>
            <h3>Slices (Dynamic Arrays)</h3>
            <div class="code-block">
                <div class="code-header go">Slices</div>
                <pre>nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}
nums = <span class="func">append</span>(nums, <span class="number">4</span>)
fmt.<span class="func">Println</span>(nums[<span class="number">0</span>])     <span class="comment">// 1</span>
fmt.<span class="func">Println</span>(<span class="func">len</span>(nums))  <span class="comment">// 4</span>
fmt.<span class="func">Println</span>(nums[<span class="number">1</span>:<span class="number">3</span>])   <span class="comment">// [2 3]</span></pre>
            </div>
            <h3>Maps (Dictionaries)</h3>
            <div class="code-block">
                <div class="code-header go">Creating and using maps</div>
                <pre>ages := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{
    <span class="string">"alice"</span>: <span class="number">30</span>,
    <span class="string">"bob"</span>:   <span class="number">25</span>,
}
ages[<span class="string">"charlie"</span>] = <span class="number">35</span>  <span class="comment">// Add new key</span>

fmt.<span class="func">Println</span>(ages[<span class="string">"alice"</span>])  <span class="comment">// 30</span></pre>
            </div>
            <div class="warning">
                <div class="warning-title">The Missing Key Problem</div>
                <p>In Python, accessing a missing key raises <span class="inline-code">KeyError</span>. In Go, it returns the <strong>zero value</strong> (0 for int, "" for string, etc). This means you can't tell if a key is missing or just has a zero value!</p>
            </div>
            <div class="code-block">
                <div class="code-header go">The "comma ok" idiom - checking if a key exists</div>
                <pre><span class="comment">// Wrong: Can't tell if dave is missing or age is 0</span>
age := ages[<span class="string">"dave"</span>]  <span class="comment">// Returns 0 (zero value)</span>

<span class="comment">// Right: Use the "comma ok" pattern</span>
<span class="comment">// ORDER: value, exists := map[key]</span>
<span class="comment">//        ‚Üë      ‚Üë</span>
<span class="comment">//        ‚îÇ      ‚îî‚îÄ‚îÄ boolean: true if found, false if not</span>
<span class="comment">//        ‚îî‚îÄ‚îÄ the actual value (or zero value)</span>

age, ok := ages[<span class="string">"dave"</span>]
<span class="comment">// age = 0 (zero value for int)</span>
<span class="comment">// ok = false (key doesn't exist)</span>

<span class="keyword">if</span> ok {
    fmt.<span class="func">Println</span>(<span class="string">"Found:"</span>, age)
} <span class="keyword">else</span> {
    fmt.<span class="func">Println</span>(<span class="string">"Not found"</span>)  <span class="comment">// This prints</span>
}

<span class="comment">// Common shorthand: declare inside if statement</span>
<span class="keyword">if</span> age, ok := ages[<span class="string">"alice"</span>]; ok {
    <span class="comment">//   ‚Üë    ‚Üë</span>
    <span class="comment">//   30  true</span>
    fmt.<span class="func">Println</span>(<span class="string">"Alice is"</span>, age)  <span class="comment">// Prints: Alice is 30</span>
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header python">Python equivalent</div>
                <pre><span class="comment"># In Python, you might do:</span>
age = ages.get(<span class="string">"dave"</span>)  <span class="comment"># Returns None if missing</span>
<span class="keyword">if</span> age <span class="keyword">is not None</span>:
    <span class="func">print</span>(<span class="string">f"Found: </span>{age}<span class="string">"</span>)

<span class="comment"># Or check with 'in':</span>
<span class="keyword">if</span> <span class="string">"dave"</span> <span class="keyword">in</span> ages:
    <span class="func">print</span>(<span class="string">f"Found: </span>{ages[<span class="string">'dave'</span>]}<span class="string">"</span>)</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Remember the order!</div>
                <p><strong>First variable</strong> = the value you're looking for<br>
                <strong>Second variable</strong> = boolean (did we find it?)<br><br>
                Pattern: <span class="inline-code">value, found := map[key]</span><br>
                You can name them anything, but <span class="inline-code">ok</span> is conventional for the boolean.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            <p>Progress through each section in order. Each level introduces new concepts gradually.</p>
            
            <h3 style="color: var(--green-bright); margin-top: 1.5rem;">üî• Warmups</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice individual concepts you just learned.</p>
            
            <div class="exercise">
                <h4>Warmup 1: Simple Loop</h4>
                <p>Write a program that prints the numbers 1 to 10, one per line.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use a <code>for</code> loop with <code>i := 1; i <= 10; i++</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 10; i++ {
    fmt.Println(i)
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 2: If/Else Practice</h4>
                <p>Write a function <code>func checkNumber(n int) string</code> that returns "positive" if n > 0, "negative" if n < 0, and "zero" if n == 0.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use <code>if n > 0</code>, then <code>else if n < 0</code>, then <code>else</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func checkNumber(n int) string {
    if n > 0 {
        return "positive"
    } else if n < 0 {
        return "negative"
    } else {
        return "zero"
    }
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 3: Working with Slices</h4>
                <p>Create a slice of your three favorite numbers, then print each one using a <code>for</code> loop with <code>range</code>.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Create slice: <code>nums := []int{1, 2, 3}</code><br>
                        Loop: <code>for _, num := range nums</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>nums := []int{7, 42, 99}
for _, num := range nums {
    fmt.Println(num)
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 4: Simple Map</h4>
                <p>Create a map that stores the ages of three people, then print each person's name and age.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Map syntax: <code>map[string]int{"name": age}</code><br>
                        Loop: <code>for key, value := range mapName</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>ages := map[string]int{
    "alice": 30,
    "bob":   25,
    "carol": 35,
}
for name, age := range ages {
    fmt.Printf("%s is %d years old\n", name, age)
}</pre>
                    </div>
                </details>
            </div>

            <h3 style="color: var(--blue); margin-top: 2rem;">üìö Intermediate</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Each exercise introduces ONE new concept. Build your toolkit!</p>

            <div class="exercise">
                <h4>Intermediate 1: The make Function</h4>
                <p>Create an empty slice using <code>make([]int, 0)</code>, add three numbers to it with <code>append</code>, then print its length.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        <code>make()</code> creates an empty slice with space to grow.<br>
                        <code>make([]int, 0)</code> means: "make an int slice with 0 initial elements"<br>
                        Then use: <code>nums = append(nums, value)</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>nums := make([]int, 0)
nums = append(nums, 10)
nums = append(nums, 20)
nums = append(nums, 30)
fmt.Println(len(nums))  // prints 3</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>3</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 2: Checking Map Keys</h4>
                <p>Create a map of fruit prices. Check if "banana" exists in the map using the <code>value, ok := map[key]</code> pattern.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        The "comma ok" idiom: <code>value, ok := myMap[key]</code><br>
                        <code>ok</code> will be <code>true</code> if the key exists, <code>false</code> if not.<br>
                        Use it in an if statement: <code>if price, ok := prices["banana"]; ok { ... }</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>prices := map[string]float64{
    "apple":  1.50,
    "orange": 2.00,
}

if price, ok := prices["banana"]; ok {
    fmt.Printf("Banana costs $%.2f\n", price)
} else {
    fmt.Println("Banana not found")
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>Banana not found</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 3: Range with Index and Value</h4>
                <p>Create a slice of strings (your favorite foods). Loop through it and print both the index and value: "0: pizza", "1: tacos", etc.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        <code>range</code> returns TWO values: index and element<br>
                        <code>for i, food := range foods</code> where <code>i</code> is the index (0, 1, 2...) and <code>food</code> is the value
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>foods := []string{"pizza", "tacos", "sushi"}
for i, food := range foods {
    fmt.Printf("%d: %s\n", i, food)
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>0: pizza
1: tacos
2: sushi</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Intermediate 4: Building Slices in a Loop</h4>
                <p>Create an empty slice, then use a loop to add only the even numbers from 1-10 to it. Print the final slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Start with: <code>evens := []int{}</code> (or <code>make([]int, 0)</code>)<br>
                        Loop from 1 to 10, check <code>if i%2 == 0</code>, then <code>append</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>evens := []int{}
for i := 1; i <= 10; i++ {
    if i%2 == 0 {
        evens = append(evens, i)
    }
}
fmt.Println(evens)  // [2 4 6 8 10]</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>[2 4 6 8 10]</pre>
                </div>
            </div>

            <h3 style="color: var(--orange); margin-top: 2rem;">üí™ Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Combine multiple concepts to solve these.</p>
            
            <div class="exercise">
                <h4>Challenge 1: Sum of Slice</h4>
                <p>Write a function <code>func sum(numbers []int) int</code> that returns the sum of all numbers in a slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Create a <code>total</code> variable, loop through with <code>range</code>, add each number to total, return total.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func sum(numbers []int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>sum([]int{1, 2, 3, 4, 5}) ‚Üí 15
sum([]int{10, 20}) ‚Üí 30</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 2: Find in Slice</h4>
                <p>Write a function <code>func contains(items []string, target string) bool</code> that returns true if target is in the slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Loop through items, compare each to target using <code>==</code>, return true if found, return false after loop.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func contains(items []string, target string) bool {
    for _, item := range items {
        if item == target {
            return true
        }
    }
    return false
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>contains([]string{"a", "b", "c"}, "b") ‚Üí true
contains([]string{"a", "b", "c"}, "z") ‚Üí false</pre>
                </div>
            </div>
            
            <div class="exercise">
                <h4>Challenge 3: FizzBuzz</h4>
                <p>Print numbers 1-20. For multiples of 3 print "Fizz", multiples of 5 print "Buzz", multiples of both print "FizzBuzz".</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use <code>%</code> (modulo) to check divisibility. Check for 15 first (or check 3 AND 5), otherwise "FizzBuzz" won't print.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>for i := 1; i <= 20; i++ {
    if i%15 == 0 {
        fmt.Println("FizzBuzz")
    } else if i%3 == 0 {
        fmt.Println("Fizz")
    } else if i%5 == 0 {
        fmt.Println("Buzz")
    } else {
        fmt.Println(i)
    }
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output (partial)</div>
                    <pre>1
2
Fizz
4
Buzz
Fizz
7
...
FizzBuzz</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 4: Find Maximum</h4>
                <p>Write a function <code>func max(nums []int) int</code> that returns the largest number in a slice.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Start by assuming the first element is the max. Then loop through the rest and update if you find a bigger number.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func max(nums []int) int {
    maxNum := nums[0]  // Start with first element
    for _, num := range nums {
        if num > maxNum {
            maxNum = num  // Found a bigger one!
        }
    }
    return maxNum
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>max([]int{3, 7, 2, 9, 1}) ‚Üí 9
max([]int{-5, -2, -10}) ‚Üí -2</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 5: Swap Elements</h4>
                <p>Write a function <code>func swapElements(nums []int, i int, j int)</code> that swaps the elements at positions i and j in the slice.</p>
                
                <details>
                    <summary>üí° New Concept: Simultaneous Assignment</summary>
                    <div class="hint-content">
                        Go lets you swap two variables in one line without a temp variable:<br>
                        <code>a, b = b, a</code><br><br>
                        This works because Go evaluates the right side first, then assigns to the left side.<br><br>
                        For arrays: <code>nums[i], nums[j] = nums[j], nums[i]</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Use Go's simultaneous assignment to swap the values at the two positions in one line.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func swapElements(nums []int, i int, j int) {
    nums[i], nums[j] = nums[j], nums[i]
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Behavior</div>
                    <pre>nums := []int{1, 2, 3, 4, 5}
swapElements(nums, 0, 4)
fmt.Println(nums) ‚Üí [5, 2, 3, 4, 1]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 6: Palindrome Checker</h4>
                <p>A <strong>palindrome</strong> is something that reads the same forwards and backwards (like "racecar" or [1, 2, 3, 2, 1]). Write a function <code>func isPalindrome(nums []int) bool</code> that checks if a slice is a palindrome using two pointers.</p>
                
                <details>
                    <summary>üìñ What's a palindrome?</summary>
                    <div class="hint-content">
                        A <strong>palindrome</strong> is something that reads the same forwards and backwards.<br><br>
                        
                        <strong>String examples (most common):</strong><br>
                        ‚Ä¢ "racecar" ‚Üí reads the same both ways ‚úÖ<br>
                        ‚Ä¢ "level" ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ "noon" ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ "A man a plan a canal Panama" ‚Üí if you ignore spaces/capitals ‚úÖ<br>
                        ‚Ä¢ "hello" ‚Üí reads "olleh" backwards ‚ùå<br><br>
                        
                        <strong>Number examples:</strong><br>
                        ‚Ä¢ 121 ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ 12321 ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ 123 ‚Üí reads 321 backwards ‚ùå<br><br>
                        
                        <strong>Slice examples (what we're doing):</strong><br>
                        ‚Ä¢ [1, 2, 3, 2, 1] ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ [5, 5] ‚Üí palindrome ‚úÖ<br>
                        ‚Ä¢ [7] ‚Üí single element is always a palindrome ‚úÖ<br>
                        ‚Ä¢ [1, 2, 3] ‚Üí reads [3, 2, 1] backwards ‚ùå<br><br>
                        
                        <strong>Note:</strong> Palindromes are usually words or phrases, but for this exercise we're using a slice of integers to keep it simple. You'll learn how to work with string palindromes in the Advanced section!<br><br>
                        
                        <strong>How to check:</strong><br>
                        Compare elements from both ends moving inward. If they're all equal, it's a palindrome!
                    </div>
                </details>
                
                <details>
                    <summary>üí° New Concept: Two-Pointer Comparison</summary>
                    <div class="hint-content">
                        Instead of swapping (like Challenge 5), we <strong>compare</strong> elements from both ends.<br><br>
                        
                        <strong>The pattern:</strong><br>
                        1. Start with <code>i</code> at the beginning, <code>j</code> at the end<br>
                        2. If <code>nums[i] != nums[j]</code>, return <code>false</code> (not a palindrome!)<br>
                        3. Move pointers toward middle: <code>i++</code>, <code>j--</code><br>
                        4. If we make it through the whole loop, return <code>true</code><br><br>
                        
                        <strong>Example:</strong> [1, 2, 3, 2, 1]<br>
                        ‚Ä¢ Compare nums[0] and nums[4]: 1 == 1 ‚úì<br>
                        ‚Ä¢ Compare nums[1] and nums[3]: 2 == 2 ‚úì<br>
                        ‚Ä¢ Middle element nums[2] = 3 (no need to compare with itself)<br>
                        ‚Ä¢ It's a palindrome! ‚úÖ
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: Loop structure</summary>
                    <div class="hint-content">
                        Use the same two-pointer loop as Challenge 5's swap:<br>
                        <code>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1</code><br><br>
                        But instead of swapping, you'll <strong>compare</strong> the values.
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: When to return false</summary>
                    <div class="hint-content">
                        Inside the loop, check: <code>if nums[i] != nums[j]</code><br>
                        If they don't match, immediately return <code>false</code> - it's not a palindrome!<br><br>
                        If the loop completes without returning false, return <code>true</code> at the end.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>func isPalindrome(nums []int) bool {
    // Two pointers: start from both ends
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        // If any pair doesn't match, not a palindrome
        if nums[i] != nums[j] {
            return false
        }
    }
    // Made it through - it's a palindrome!
    return true
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>isPalindrome([]int{1, 2, 3, 2, 1}) ‚Üí true
isPalindrome([]int{1, 2, 3, 4, 5}) ‚Üí false
isPalindrome([]int{5, 5}) ‚Üí true
isPalindrome([]int{7}) ‚Üí true</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 7: Reverse a Slice</h4>
                <p>Write a function <code>func reverseSlice(nums []int) []int</code> that returns a new slice with elements in reverse order. This combines the two-pointer technique from Challenge 6 with swapping from Challenge 5!</p>
                
                <details>
                    <summary>üìñ Pre-reading: The Two-Pointer Technique</summary>
                    <div class="hint-content">
                        <strong>What is it?</strong> A common algorithm pattern where you use two variables (pointers) starting at different positions, moving toward each other.<br><br>
                        <strong>For reversing:</strong><br>
                        ‚Ä¢ Start one pointer at the beginning (index 0)<br>
                        ‚Ä¢ Start another at the end (index len-1)<br>
                        ‚Ä¢ Swap the elements they point to<br>
                        ‚Ä¢ Move pointers toward the middle<br>
                        ‚Ä¢ Stop when they meet<br><br>
                        <strong>Example:</strong> [1, 2, 3, 4, 5]<br>
                        Step 1: Swap positions 0 and 4 ‚Üí [5, 2, 3, 4, 1]<br>
                        Step 2: Swap positions 1 and 3 ‚Üí [5, 4, 3, 2, 1]<br>
                        Step 3: Position 2 stays (middle) ‚Üí Done!
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Combine what you learned:<br>
                        ‚Ä¢ Use the two-pointer loop from Challenge 6: <code>for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1</code><br>
                        ‚Ä¢ Use the swap syntax from Challenge 5: <code>nums[i], nums[j] = nums[j], nums[i]</code><br><br>
                        The key difference from palindrome checking: instead of <strong>comparing</strong>, you <strong>swap</strong>!<br>
                        You can modify the slice in place - no need to create a copy.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func reverseSlice(nums []int) []int {
    // Two-pointer swap - reverse in place
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        // Swap elements at positions i and j
        nums[i], nums[j] = nums[j], nums[i]
    }
    return nums
}</pre>
                        <strong>Breaking down the for loop:</strong><br>
                        <code>i, j := 0, len(nums)-1</code> - Initialize TWO variables at once<br>
                        <code>i < j</code> - Continue while pointers haven't crossed<br>
                        <code>i, j = i+1, j-1</code> - Move BOTH pointers (i forward, j backward)<br><br>
                        
                        <strong>The swap:</strong><br>
                        <code>nums[i], nums[j] = nums[j], nums[i]</code><br>
                        This is Go's simultaneous assignment - it swaps values in one line!<br><br>
                        
                        <strong>Why this works:</strong><br>
                        We reverse the slice <strong>in place</strong> by swapping elements from both ends moving toward the middle. No need to create a copy!<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/tour/moretypes/7" target="_blank" style="color: var(--green-bright);">Go slices (official tour)</a><br>
                        ‚Ä¢ <a href="https://go.dev/blog/slices-intro" target="_blank" style="color: var(--green-bright);">Slices introduction (Go blog)</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverseSlice([]int{1, 2, 3, 4, 5}) ‚Üí [5, 4, 3, 2, 1]
reverseSlice([]int{10, 20}) ‚Üí [20, 10]</pre>
                </div>
            </div>

            <h3 style="color: var(--purple); margin-top: 2rem;">üöÄ Advanced</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">These combine many concepts and introduce new Go features. Complete challenges first!</p>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-btn" onclick="shuffleVariants()" style="background: var(--bg-card); border: 1px solid var(--purple); color: var(--purple); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    üé≤ Shuffle Variants
                </button>
            </div>

            <!-- Pre-exercises for Advanced 1 -->
            <div id="pre-exercises-container"></div>

            <!-- Advanced exercises will be dynamically loaded -->
            <div id="advanced-exercises-container">

            <!-- Fallback: Static exercise shown if JS fails -->
            <noscript>
            <div class="exercise">
                <h4>Advanced 1: Contains Duplicate</h4>
                <p>Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.</p>
                
                <details>
                    <summary>üìñ Pre-reading: The "Have I Seen This?" Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                        
                        <strong>Naive approach (slow):</strong><br>
                        For each number, check every other number to see if it matches ‚Üí O(n¬≤)<br>
                        For 1000 numbers, that's 1,000,000 comparisons! üêå<br><br>
                        
                        <strong>Smart approach (fast):</strong><br>
                        Use a map to remember what you've seen ‚Üí O(n)<br>
                        For 1000 numbers, that's just 1000 operations! üöÄ<br><br>
                        
                        <strong>The Pattern:</strong><br>
                        1. Create an empty map to track what you've seen<br>
                        2. For each element, check: "Have I seen this before?"<br>
                        3. If yes ‚Üí found a duplicate!<br>
                        4. If no ‚Üí remember it and continue
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: What to track</summary>
                    <div class="hint-content">
                        You need a map to remember which numbers you've already seen.<br><br>
                        
                        What should the map store?<br>
                        ‚Ä¢ <strong>Key:</strong> the number itself (<code>int</code>)<br>
                        ‚Ä¢ <strong>Value:</strong> we just need to know it exists... so <code>bool</code> works!<br><br>
                        
                        Create it with: <code>seen := make(map[int]bool)</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: Checking if you've seen it</summary>
                    <div class="hint-content">
                        For each number in the slice:<br>
                        ‚Ä¢ Check: <code>if seen[num]</code> - is it in the map?<br>
                        ‚Ä¢ If <code>true</code>, you've seen it before ‚Üí return <code>true</code> (found duplicate!)<br>
                        ‚Ä¢ If <code>false</code>, mark it as seen: <code>seen[num] = true</code><br><br>
                        
                        This works because when a key doesn't exist in a map, Go returns the zero value for that type. For <code>bool</code>, the zero value is <code>false</code>.
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 3: What to return</summary>
                    <div class="hint-content">
                        If you make it through the entire loop without finding a duplicate, what does that mean?<br><br>
                        
                        All numbers are unique! Return <code>false</code> at the end.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func containsDuplicate(nums []int) bool {
    // Map to track what we've seen
    seen := make(map[int]bool)
    
    // Check each number
    for _, num := range nums {
        // Have we seen this before?
        if seen[num] {
            // Yes! Found a duplicate
            return true
        }
        // No, remember it for later
        seen[num] = true
    }
    
    // Made it through - no duplicates
    return false
}</pre>
                        <strong>Why this works:</strong><br>
                        The map acts as our "memory". Each time we see a number, we check our memory. If it's already there, we found a duplicate!<br><br>
                        
                        <strong>Note:</strong> We can simplify <code>if seen[num]</code> instead of <code>if _, ok := seen[num]; ok</code> because:<br>
                        ‚Ä¢ If the key exists, <code>seen[num]</code> returns <code>true</code><br>
                        ‚Ä¢ If the key doesn't exist, <code>seen[num]</code> returns <code>false</code> (the zero value for bool)<br>
                        ‚Ä¢ This works perfectly for our use case!<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - we only loop through once<br>
                        <strong>Space complexity:</strong> O(n) - worst case, store all unique numbers in map
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>containsDuplicate([]int{1, 2, 3, 1}) ‚Üí true
containsDuplicate([]int{1, 2, 3, 4}) ‚Üí false
containsDuplicate([]int{1, 1, 1, 1}) ‚Üí true</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 2: Remove Duplicates from Sorted Array</h4>
                <p>Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first part of the slice should contain the unique elements.</p>
                
                <details>
                    <summary>üìñ Pre-reading: The Slow/Fast Pointer Pattern</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> Given <code>[1,1,2,2,3]</code>, modify it to <code>[1,2,3,_,_]</code> and return <code>3</code><br><br>
                        
                        <strong>Key insight:</strong> The array is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                        
                        <strong>The Slow/Fast Pattern:</strong><br>
                        This is a NEW variant of two-pointers you haven't seen yet:<br>
                        ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                        ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                        ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                        
                        <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(nums); fast++ {  // Initialize IN loop (read position)
    // Compare nums[fast] with nums[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>
                        
                        <strong>Why this structure?</strong><br>
                        ‚Ä¢ <code>slow</code> only moves when we find something to write (conditional)<br>
                        ‚Ä¢ <code>fast</code> always moves to keep reading (automatic)<br>
                        ‚Ä¢ This is different from <code>i, j</code> in challenges where both moved together!<br><br>
                        
                        <strong>Example walkthrough:</strong> [1,1,2,2,3]<br>
                        ‚Ä¢ Start: slow=0, fast=1<br>
                        ‚Ä¢ nums[1]=1 same as nums[0]=1? Yes ‚Üí skip (only fast moves)<br>
                        ‚Ä¢ fast=2: nums[2]=2 different from nums[0]=1? Yes ‚Üí slow++, write nums[2] to nums[1]<br>
                        ‚Ä¢ fast=3: nums[3]=2 same as nums[1]=2? Yes ‚Üí skip<br>
                        ‚Ä¢ fast=4: nums[4]=3 different from nums[1]=2? Yes ‚Üí slow++, write nums[4] to nums[2]<br>
                        ‚Ä¢ Result: [1,2,3,2,3], return slow+1 = 3
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 1: Edge cases and setup</summary>
                    <div class="hint-content">
                        <strong>Handle edge cases first:</strong><br>
                        What if the array is empty? Add this at the start:<br>
                        <code>if len(nums) == 0 { return 0 }</code><br><br>
                        
                        <strong>Setup:</strong><br>
                        Initialize <code>slow := 0</code> before the loop (first element is always unique)<br>
                        Start your loop with <code>fast := 1</code> (compare from second element onward)
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 2: When to write</summary>
                    <div class="hint-content">
                        Loop while <code>fast < len(nums)</code><br><br>
                        
                        At each step, compare <code>nums[fast]</code> with <code>nums[slow]</code>:<br>
                        ‚Ä¢ If they're <strong>different</strong>: found a new unique value!<br>
                          - Increment <code>slow</code><br>
                          - Write <code>nums[fast]</code> to <code>nums[slow]</code><br>
                        ‚Ä¢ If they're the <strong>same</strong>: it's a duplicate, skip it<br>
                        ‚Ä¢ Always increment <code>fast</code> to keep reading
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint 3: What to return</summary>
                    <div class="hint-content">
                        After the loop, <code>slow</code> points to the last unique element's index.<br><br>
                        
                        How many unique elements are there?<br>
                        Return <code>slow + 1</code> (because indices start at 0!)
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Explanation</summary>
                    <div class="hint-content">
<pre>func removeDuplicates(nums []int) int {
    // Handle edge cases
    if len(nums) == 0 {
        return 0
    }
    
    // slow tracks where to write next unique value
    slow := 0
    
    // fast reads through the array
    for fast := 1; fast < len(nums); fast++ {
        // Found a new unique value?
        if nums[fast] != nums[slow] {
            slow++                    // Move write position
            nums[slow] = nums[fast]   // Write the unique value
        }
        // If same, just skip (fast++ happens automatically)
    }
    
    // slow points to last unique element
    // Number of unique elements is slow + 1
    return slow + 1
}</pre>
                        <strong>Visual walkthrough for [1,1,2,2,3]:</strong><br><br>
                        
                        <strong>Start:</strong> slow=0, fast=1<br>
                        Array: [<strong>1</strong>,1,2,2,3]<br><br>
                        
                        <strong>Step 1:</strong> nums[1]=1, nums[0]=1 ‚Üí same, skip<br>
                        slow=0, fast=2<br><br>
                        
                        <strong>Step 2:</strong> nums[2]=2, nums[0]=1 ‚Üí different!<br>
                        slow++ ‚Üí slow=1<br>
                        nums[1] = nums[2] ‚Üí nums[1] = 2<br>
                        Array: [1,<strong>2</strong>,2,2,3]<br>
                        fast=3<br><br>
                        
                        <strong>Step 3:</strong> nums[3]=2, nums[1]=2 ‚Üí same, skip<br>
                        slow=1, fast=4<br><br>
                        
                        <strong>Step 4:</strong> nums[4]=3, nums[1]=2 ‚Üí different!<br>
                        slow++ ‚Üí slow=2<br>
                        nums[2] = nums[4] ‚Üí nums[2] = 3<br>
                        Array: [1,2,<strong>3</strong>,2,3]<br><br>
                        
                        <strong>Done:</strong> return slow+1 = 3<br>
                        First 3 elements are unique: [1,2,3]<br><br>
                        
                        <strong>Time complexity:</strong> O(n) - one pass through array<br>
                        <strong>Space complexity:</strong> O(1) - only use two pointers
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>removeDuplicates([]int{1, 1, 2}) ‚Üí 2 (array becomes [1, 2, _])
removeDuplicates([]int{0, 0, 1, 1, 2, 2, 3}) ‚Üí 4 (array becomes [0, 1, 2, 3, _, _, _])
removeDuplicates([]int{1, 2, 3}) ‚Üí 3 (no duplicates)</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 3: Reverse a String</h4>
                <p>Now write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.</p>
                
                <details>
                    <summary>üìñ Pre-reading: Strings vs Runes in Go</summary>
                    <div class="hint-content">
                        <strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                        
                        For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                        But for Unicode (emoji üéâ, Chinese ‰∏ñÁïå, Arabic, etc.), one character can be 2-4 bytes.<br><br>
                        
                        <strong>Example:</strong><br>
                        <code>"Hello"</code> = 5 bytes = 5 characters ‚úÖ<br>
                        <code>"‰∏ñÁïå"</code> = 6 bytes but only 2 characters! ‚ö†Ô∏è<br>
                        <code>"üéâ"</code> = 4 bytes but only 1 character! ‚ö†Ô∏è<br><br>
                        
                        <strong>The Solution: Runes</strong><br>
                        A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                        Converting to <code>[]rune</code> splits the string into actual characters, not bytes.<br><br>
                        
                        <strong>Why you can't just reverse bytes:</strong><br>
                        "Hiüéâ" as bytes = [72, 105, 240, 159, 142, 137]<br>
                        Reverse bytes = [137, 142, 159, 240, 105, 72] = gibberish! ‚ùå<br>
                        Must reverse as runes = ['üéâ', 'i', 'H'] = "üéâiH" ‚úÖ<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/blog/strings" target="_blank" style="color: var(--green-bright);">Strings, bytes, runes (Go blog)</a>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Combine what you learned:<br>
                        1. Convert string to <code>[]rune</code> with <code>[]rune(s)</code> - this handles Unicode properly<br>
                        2. Use the two-pointer reversal technique from Challenge 7: <code>for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1</code><br>
                        3. Swap elements: <code>runes[i], runes[j] = runes[j], runes[i]</code><br>
                        4. Convert back to string with <code>string(runes)</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Step-by-Step Explanation</summary>
                    <div class="hint-content">
<pre>func reverse(s string) string {
    // Step 1: Convert to runes (handles Unicode properly)
    runes := []rune(s)
    
    // Step 2: Two-pointer reversal
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        // Swap characters at positions i and j
        runes[i], runes[j] = runes[j], runes[i]
    }
    
    // Step 3: Convert back to string
    return string(runes)
}</pre>
                        <strong>Visual walkthrough for "Go":</strong><br>
                        Start: <code>['G', 'o']</code>, i=0, j=1<br>
                        Swap: <code>['o', 'G']</code><br>
                        Update: i=1, j=0 ‚Üí i < j is false, stop ‚úÖ<br><br>
                        
                        <strong>Visual walkthrough for "Hiüéâ":</strong><br>
                        Start: <code>['H', 'i', 'üéâ']</code>, i=0, j=2<br>
                        Iteration 1: Swap positions 0,2 ‚Üí <code>['üéâ', 'i', 'H']</code><br>
                        Update: i=1, j=1 ‚Üí i < j is false, stop ‚úÖ<br><br>
                        
                        <strong>Key Go syntax:</strong><br>
                        ‚Ä¢ <code>for a, b := x, y</code> - declare multiple variables<br>
                        ‚Ä¢ <code>a, b = b, a</code> - simultaneous swap (no temp variable needed!)<br>
                        ‚Ä¢ <code>string(runes)</code> - convert []rune back to string<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/ref/spec#For_statements" target="_blank" style="color: var(--green-bright);">For loop syntax (Go spec)</a><br>
                        ‚Ä¢ <a href="https://go.dev/ref/spec#Assignments" target="_blank" style="color: var(--green-bright);">Assignment statements</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>reverse("hello") ‚Üí "olleh"
reverse("‰∏ñÁïå") ‚Üí "Áïå‰∏ñ"
reverse("GoüöÄ") ‚Üí "üöÄoG"</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 4: Word Counter</h4>
                <p>Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.</p>
                
                <details>
                    <summary>üí° New Concept: strings.Fields()</summary>
                    <div class="hint-content">
                        Go's <code>strings</code> package has useful functions. You need to import it:<br>
                        <code>import "strings"</code><br><br>
                        <code>strings.Fields(s)</code> splits a string on any whitespace and returns <code>[]string</code><br>
                        Example: <code>strings.Fields("hello world")</code> ‚Üí <code>["hello", "world"]</code>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        1. Create a map with <code>make(map[string]int)</code><br>
                        2. Split the string with <code>strings.Fields(s)</code><br>
                        3. Loop through words and increment the count: <code>counts[word]++</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>import "strings"

func wordCount(s string) map[string]int {
    counts := make(map[string]int)
    for _, word := range strings.Fields(s) {
        counts[word]++
    }
    return counts
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>wordCount("the quick brown fox jumps over the lazy dog")
‚Üí map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Advanced 5: Two Sum</h4>
                <p>Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code></p>
                
                <details>
                    <summary>üìñ Pre-reading: The Hash Map Pattern</summary>
                    <div class="hint-content">
                        <strong>The Naive Approach (slow):</strong><br>
                        Check every pair of numbers - requires nested loops O(n¬≤)<br>
                        For 1000 numbers, that's 1,000,000 comparisons! üêå<br><br>
                        
                        <strong>The Smart Approach (fast):</strong><br>
                        Use a map to remember what you've seen - only one loop O(n)<br>
                        For 1000 numbers, that's just 1000 operations! üöÄ<br><br>
                        
                        <strong>The Key Insight:</strong><br>
                        If target = 9 and current number = 2, we need to find 7.<br>
                        Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                        Maps make this lookup instant!<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://www.youtube.com/watch?v=KLlXCFG5TnA" target="_blank" style="color: var(--green-bright);">Two Sum explained (video)</a><br>
                        ‚Ä¢ <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" style="color: var(--green-bright);">Hash tables (Wikipedia)</a>
                    </div>
                </details>
                
                <details>
                    <summary>üí° Strategy: The Map Lookup Pattern</summary>
                    <div class="hint-content">
                        This is a classic algorithm pattern. Instead of checking every pair (slow), use a map to remember what you've seen.<br><br>
                        For each number, ask: "Have I seen the number that would complete this sum?"<br>
                        If target is 9 and current number is 2, look for 7 in your map.<br>
                        If found ‚Üí return both indices!<br>
                        If not ‚Üí remember 2 and its index for later
                    </div>
                </details>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        1. Create a map: <code>seen := make(map[int]int)</code> (number ‚Üí index)<br>
                        2. For each number, calculate: <code>complement := target - num</code><br>
                        3. Check: <code>if j, ok := seen[complement]; ok { return []int{j, i} }</code><br>
                        4. Store current: <code>seen[num] = i</code>
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution with Visual Walkthrough</summary>
                    <div class="hint-content">
<pre>func twoSum(nums []int, target int) []int {
    // Map to remember: number ‚Üí its index
    seen := make(map[int]int)
    
    // Loop through each number
    for i, num := range nums {
        // What number would complete the sum?
        complement := target - num
        
        // Have we seen that number before?
        if j, ok := seen[complement]; ok {
            // Yes! Return both indices
            return []int{j, i}
        }
        
        // No, remember this number for later
        seen[num] = i
    }
    
    // No solution found
    return nil
}</pre>
                        <strong>Visual walkthrough:</strong><br>
                        Input: <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code><br><br>
                        
                        <strong>Iteration 1:</strong> i=0, num=2<br>
                        ‚Ä¢ complement = 9 - 2 = 7<br>
                        ‚Ä¢ Is 7 in seen? No<br>
                        ‚Ä¢ Add to map: seen = {2: 0}<br><br>
                        
                        <strong>Iteration 2:</strong> i=1, num=7<br>
                        ‚Ä¢ complement = 9 - 7 = 2<br>
                        ‚Ä¢ Is 2 in seen? Yes! (at index 0) ‚úÖ<br>
                        ‚Ä¢ Return [0, 1]<br><br>
                        
                        <strong>Why this works:</strong><br>
                        When we're at 7, we look back and say "I've seen 2 before at index 0"<br>
                        2 + 7 = 9, so we return indices [0, 1]!<br><br>
                        
                        <strong>Key concepts used:</strong><br>
                        ‚Ä¢ <code>make(map[int]int)</code> - create empty map<br>
                        ‚Ä¢ <code>if j, ok := map[key]; ok</code> - check if key exists<br>
                        ‚Ä¢ <code>map[key] = value</code> - store in map<br>
                        ‚Ä¢ <code>[]int{a, b}</code> - create slice literal<br><br>
                        
                        üìö <strong>Learn more:</strong><br>
                        ‚Ä¢ <a href="https://go.dev/blog/maps" target="_blank" style="color: var(--green-bright);">Go maps in action</a><br>
                        ‚Ä¢ <a href="https://pkg.go.dev/builtin#make" target="_blank" style="color: var(--green-bright);">The make function</a>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>twoSum([]int{2, 7, 11, 15}, 9) ‚Üí [0, 1]
twoSum([]int{3, 2, 4}, 6) ‚Üí [1, 2]
twoSum([]int{3, 3}, 6) ‚Üí [0, 1]</pre>
                </div>
            </div>
            </noscript>
            </div><!-- end advanced-exercises-container -->

            <div class="tip">
                <div class="tip-title">Learning Path</div>
                <p><strong>Warmups</strong> ‚Üí master basic syntax<br>
                <strong>Intermediate</strong> ‚Üí learn one new concept at a time<br>
                <strong>Challenges</strong> ‚Üí combine what you know in small steps<br>
                <strong>Advanced</strong> ‚Üí tackle algorithms with proper scaffolding<br><br>
                Challenge 6 (palindrome) teaches you the two-pointer <strong>comparison</strong> pattern, then Challenge 7 (reverse) uses the same pattern but with <strong>swapping</strong> instead. This builds understanding step by step!<br><br>
                Stuck? Check the hint. Still stuck after 5 minutes? Check the solution and study it!</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 1 Summary</h2>
            <h3>Core Concepts</h3>
            <ul>
                <li><strong>:=</strong> for declaration + assignment inside functions</li>
                <li><strong>Types:</strong> string, int, float64, bool (statically typed!)</li>
                <li><strong>Functions:</strong> <span class="inline-code">func name(params) returnType { }</span></li>
                <li><strong>Multiple returns:</strong> <span class="inline-code">func f() (int, error)</span></li>
                <li><strong>Slices:</strong> <span class="inline-code">[]Type{}</span> - dynamic arrays</li>
                <li><strong>Maps:</strong> <span class="inline-code">map[KeyType]ValueType{}</span> - like dictionaries</li>
            </ul>
            
            <h3>Key Patterns You Learned</h3>
            <ul>
                <li><strong>The "comma ok" idiom:</strong> <span class="inline-code">value, ok := map[key]</span> - check if a map key exists</li>
                <li><strong>Simultaneous assignment:</strong> <span class="inline-code">a, b = b, a</span> - swap without temp variable</li>
            </ul>
            
            <h3>Algorithm Patterns & When to Use Them</h3>
            <ul>
                <li><strong>Two-pointer (opposite ends):</strong> When you need to work from both ends toward the middle
                    <ul style="margin-top: 0.5rem;">
                        <li>Palindrome checking</li>
                        <li>Reversing arrays/strings</li>
                        <li>Pattern: <span class="inline-code">for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1</span></li>
                    </ul>
                </li>
                <li><strong>Slow/fast pointers:</strong> When one pointer reads and another writes, moving at different speeds
                    <ul style="margin-top: 0.5rem;">
                        <li>Removing duplicates from sorted arrays</li>
                        <li>In-place array modifications</li>
                        <li>Pattern: <span class="inline-code">slow := 0</span> outside, <span class="inline-code">for fast := 1; ...</span> inside</li>
                    </ul>
                </li>
                <li><strong>Map for tracking:</strong> When you need to remember "have I seen this before?"
                    <ul style="margin-top: 0.5rem;">
                        <li>Finding duplicates</li>
                        <li>Counting occurrences</li>
                        <li>Two Sum (storing complements)</li>
                        <li>Pattern: Check map first, then add to map if not found</li>
                    </ul>
                </li>
                <li><strong>Building slices with append:</strong> When you need to filter or transform data
                    <ul style="margin-top: 0.5rem;">
                        <li>Filtering even numbers</li>
                        <li>Collecting results dynamically</li>
                        <li>Pattern: Start with <span class="inline-code">result := []Type{}</span>, then <span class="inline-code">result = append(result, item)</span></li>
                    </ul>
                </li>
            </ul>
            
            <h3>Common Gotchas</h3>
            <ul>
                <li><strong>Missing map keys return zero values</strong> - use "comma ok" to check if key exists</li>
                <li><strong>Strings are bytes, not characters</strong> - use <span class="inline-code">[]rune(s)</span> for Unicode</li>
                <li><strong>Slices are references</strong> - modifying a slice modifies the original</li>
                <li><strong>:= only works inside functions</strong> - use <span class="inline-code">var</span> at package level</li>
            </ul>
            
            <h3>Next Steps</h3>
            <p style="color: var(--text-dim);">You now have the fundamentals to solve many LeetCode Easy problems! Module 2 will cover pointers, structs, and methods - the building blocks for more complex programs.</p>
        </div>

        <div class="nav-buttons">
            <a href="module0.html" class="nav-btn">‚Üê Module 0</a>
            <a href="module2.html" class="nav-btn primary">Module 2: Pointers ‚Üí</a>
        </div>
    </div>

    <script>
    // Variant system for Advanced exercises
    let variantsData = null;
    let currentVariants = {};

    // Shared hints/pre-reading for each exercise type (these are the same across variants)
    const sharedContent = {
        advanced_1: {
            preReading: {
                title: 'üìñ Pre-reading: The "Have I Seen This?" Pattern',
                content: `<strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                    <strong>Naive approach (slow):</strong><br>
                    For each element, check every other element to see if it matches ‚Üí O(n¬≤)<br>
                    For 1000 elements, that's 1,000,000 comparisons! üêå<br><br>
                    <strong>Smart approach (fast):</strong><br>
                    Use a map to remember what you've seen ‚Üí O(n)<br>
                    For 1000 elements, that's just 1000 operations! üöÄ<br><br>
                    <strong>The Pattern:</strong><br>
                    1. Create an empty map to track what you've seen<br>
                    2. For each element, check: "Have I seen this before?"<br>
                    3. If yes ‚Üí found a duplicate!<br>
                    4. If no ‚Üí remember it and continue`
            },
            hints: [
                {
                    title: 'üí° Hint 1: What to track',
                    content: `You need a map to remember which elements you've already seen.<br><br>
                        What should the map store?<br>
                        ‚Ä¢ <strong>Key:</strong> the element itself<br>
                        ‚Ä¢ <strong>Value:</strong> we just need to know it exists... so <code>bool</code> works!<br><br>
                        Create it with: <code>seen := make(map[T]bool)</code> where T is your element type`
                },
                {
                    title: 'üí° Hint 2: Checking if you\'ve seen it',
                    content: `For each element in the collection:<br>
                        ‚Ä¢ Check: <code>if seen[element]</code> - is it in the map?<br>
                        ‚Ä¢ If <code>true</code>, you've seen it before ‚Üí found duplicate!<br>
                        ‚Ä¢ If <code>false</code>, mark it as seen: <code>seen[element] = true</code><br><br>
                        This works because when a key doesn't exist in a map, Go returns the zero value. For <code>bool</code>, that's <code>false</code>.`
                },
                {
                    title: 'üí° Hint 3: What to return',
                    content: `If you make it through the entire loop without finding a duplicate, what does that mean?<br><br>
                        All elements are unique! Return the appropriate boolean based on what the function asks.`
                }
            ]
        },
        advanced_2: {
            preReading: {
                title: 'üìñ Pre-reading: The Slow/Fast Pointer Pattern',
                content: `<strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>
                    <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                    <strong>The Slow/Fast Pattern:</strong><br>
                    ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                    ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                    ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                    <strong>Code structure pattern:</strong><br>
<pre>slow := 0  // Initialize OUTSIDE loop (write position)

for fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)
    // Compare items[fast] with items[slow]
    // If different: move slow, write value
    // If same: do nothing
    // fast moves automatically every iteration
}</pre>`
            },
            hints: [
                {
                    title: 'üí° Hint 1: Edge cases and setup',
                    content: `<strong>Handle edge cases first:</strong><br>
                        What if the collection is empty? Return 0<br><br>
                        <strong>Setup:</strong><br>
                        Initialize <code>slow := 0</code> before the loop (first element is always unique)<br>
                        Start your loop with <code>fast := 1</code> (compare from second element onward)`
                },
                {
                    title: 'üí° Hint 2: When to write',
                    content: `At each step, compare the element at <code>fast</code> with element at <code>slow</code>:<br>
                        ‚Ä¢ If they're <strong>different</strong>: found a new unique value!<br>
                          - Increment <code>slow</code><br>
                          - Write element at <code>fast</code> to position <code>slow</code><br>
                        ‚Ä¢ If they're the <strong>same</strong>: it's a duplicate, skip it`
                },
                {
                    title: 'üí° Hint 3: What to return',
                    content: `After the loop, <code>slow</code> points to the last unique element's index.<br><br>
                        How many unique elements are there?<br>
                        Return <code>slow + 1</code> (because indices start at 0!)`
                }
            ]
        },
        advanced_3: {
            preReading: {
                title: 'üìñ Pre-reading: Strings vs Runes in Go',
                content: `<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>
                    For ASCII (a-z, 0-9), one character = one byte. Easy!<br>
                    But for Unicode (emoji üéâ, Chinese ‰∏ñÁïå, etc.), one character can be 2-4 bytes.<br><br>
                    <strong>Example:</strong><br>
                    <code>"Hello"</code> = 5 bytes = 5 characters ‚úÖ<br>
                    <code>"‰∏ñÁïå"</code> = 6 bytes but only 2 characters! ‚ö†Ô∏è<br>
                    <code>"üéâ"</code> = 4 bytes but only 1 character! ‚ö†Ô∏è<br><br>
                    <strong>The Solution: Runes</strong><br>
                    A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>
                    Converting to <code>[]rune</code> splits the string into actual characters, not bytes.`
            },
            hints: [
                {
                    title: 'üí° Hint',
                    content: `Combine what you learned:<br>
                        1. Convert string to <code>[]rune</code> with <code>[]rune(s)</code> - this handles Unicode properly<br>
                        2. Use the two-pointer reversal technique: <code>for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1</code><br>
                        3. Swap elements: <code>runes[i], runes[j] = runes[j], runes[i]</code><br>
                        4. Convert back to string with <code>string(runes)</code>`
                }
            ]
        },
        advanced_4: {
            hints: [
                {
                    title: 'üí° New Concept: strings.Fields()',
                    content: `Go's <code>strings</code> package has useful functions. You need to import it:<br>
                        <code>import "strings"</code><br><br>
                        <code>strings.Fields(s)</code> splits a string on any whitespace and returns <code>[]string</code><br>
                        Example: <code>strings.Fields("hello world")</code> ‚Üí <code>["hello", "world"]</code>`
                },
                {
                    title: 'üí° Hint',
                    content: `1. Create a map with the appropriate types<br>
                        2. Loop through your collection<br>
                        3. Increment the count: <code>counts[item]++</code>`
                }
            ]
        },
        advanced_5: {
            preReading: {
                title: 'üìñ Pre-reading: The Hash Map Complement Pattern',
                content: `<strong>The Naive Approach (slow):</strong><br>
                    Check every pair of numbers - requires nested loops O(n¬≤)<br><br>
                    <strong>The Smart Approach (fast):</strong><br>
                    Use a map to remember what you've seen - only one loop O(n)<br><br>
                    <strong>The Key Insight:</strong><br>
                    If target = 9 and current number = 2, we need to find 7.<br>
                    Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                    Maps make this lookup instant!`
            },
            hints: [
                {
                    title: 'üí° Strategy: The Map Lookup Pattern',
                    content: `For each element, ask: "Have I seen the element that would complete this sum?"<br>
                        If target is 9 and current element is 2, look for 7 in your map.<br>
                        If found ‚Üí return both indices!<br>
                        If not ‚Üí remember this element and its index for later`
                },
                {
                    title: 'üí° Hint',
                    content: `1. Create a map: <code>seen := make(map[int]int)</code> (element ‚Üí index)<br>
                        2. For each element, calculate: <code>complement := target - element</code><br>
                        3. Check: <code>if j, ok := seen[complement]; ok { return []int{j, i} }</code><br>
                        4. Store current: <code>seen[element] = i</code>`
                }
            ]
        }
    };

    // Embedded variants data (works with file:// protocol)
    // These are DIFFERENT problems that test the same concepts, not just renamed variables
    const variantsDataEmbedded = {
      "advanced": [
        {
          "id": "advanced_1",
          "baseTitle": "Map as Set",
          "concept": "Map as Set - Have I Seen This?",
          "variants": [
            {
              "id": "v1",
              "title": "Contains Duplicate",
              "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
              "functionSignature": "func containsDuplicate(nums []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3, 1}", "output": "true" },
                { "input": "[]int{1, 2, 3, 4}", "output": "false" },
                { "input": "[]int{1, 1, 1, 1}", "output": "true" }
              ],
              "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}"
            },
            {
              "id": "v2",
              "title": "First Duplicate Value",
              "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
              "functionSignature": "func firstDuplicate(nums []int) int",
              "testCases": [
                { "input": "[]int{2, 1, 3, 5, 3, 2}", "output": "3", "note": "3 is seen again before 2 is" },
                { "input": "[]int{1, 2, 3, 4}", "output": "-1" },
                { "input": "[]int{1, 1, 2, 2}", "output": "1" }
              ],
              "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num  // Return the value, not just true\n        }\n        seen[num] = true\n    }\n    return -1\n}",
              "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!"
            },
            {
              "id": "v3",
              "title": "Count Unique Elements",
              "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
              "functionSignature": "func countUnique(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 3, 3, 3}", "output": "3", "note": "unique values: 1, 2, 3" },
                { "input": "[]int{5, 5, 5, 5}", "output": "1" },
                { "input": "[]int{1, 2, 3, 4, 5}", "output": "5" }
              ],
              "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
              "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!"
            },
            {
              "id": "v4",
              "title": "Find All Duplicates",
              "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
              "functionSignature": "func findDuplicates(nums []int) []int",
              "testCases": [
                { "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}", "output": "[2, 3]" },
                { "input": "[]int{1, 1, 2, 2, 3, 3}", "output": "[1, 2, 3]" },
                { "input": "[]int{1, 2, 3}", "output": "[]" }
              ],
              "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)  // Track what we've added to result\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
              "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result."
            },
            {
              "id": "v5",
              "title": "Common Elements",
              "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
              "functionSignature": "func hasCommon(a, b []int) bool",
              "testCases": [
                { "input": "[]int{1, 2, 3}, []int{3, 4, 5}", "output": "true", "note": "3 is common" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "false" },
                { "input": "[]int{1}, []int{1}", "output": "true" }
              ],
              "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
              "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!"
            },
            {
              "id": "v6",
              "title": "Find Intersection",
              "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
              "functionSignature": "func intersection(a, b []int) []int",
              "testCases": [
                { "input": "[]int{1, 2, 2, 1}, []int{2, 2}", "output": "[2]" },
                { "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}", "output": "[9, 4]", "note": "or [4, 9] - order doesn't matter" },
                { "input": "[]int{1, 2}, []int{3, 4}", "output": "[]" }
              ],
              "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)  // Avoid duplicates in result\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
              "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result."
            }
          ]
        },
        {
          "id": "advanced_2",
          "baseTitle": "Two-Pointer In-Place",
          "concept": "Slow/Fast Pointer Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Remove Duplicates from Sorted Array",
              "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
              "functionSignature": "func removeDuplicates(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 2}", "output": "2", "note": "array becomes [1, 2, _]" },
                { "input": "[]int{0, 0, 1, 1, 2, 2, 3}", "output": "4", "note": "array becomes [0, 1, 2, 3, _, _, _]" },
                { "input": "[]int{1, 2, 3}", "output": "3" }
              ],
              "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}"
            },
            {
              "id": "v2",
              "title": "Remove Element",
              "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
              "functionSignature": "func removeElement(nums []int, val int) int",
              "testCases": [
                { "input": "[]int{3, 2, 2, 3}, 3", "output": "2", "note": "array becomes [2, 2, _, _]" },
                { "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2", "output": "5" },
                { "input": "[]int{1}, 1", "output": "0" }
              ],
              "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0."
            },
            {
              "id": "v3",
              "title": "Move Zeroes",
              "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
              "functionSignature": "func moveZeroes(nums []int)",
              "testCases": [
                { "input": "[]int{0, 1, 0, 3, 12}", "output": "[1, 3, 12, 0, 0]" },
                { "input": "[]int{0, 0, 1}", "output": "[1, 0, 0]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 2, 3]", "note": "no zeroes" }
              ],
              "solution": "func moveZeroes(nums []int) {\n    slow := 0  // Position to place next non-zero\n    \n    // Move all non-zeroes to the front\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    // Fill the rest with zeroes\n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
              "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!"
            },
            {
              "id": "v4",
              "title": "Remove Duplicates II (Allow 2)",
              "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
              "functionSignature": "func removeDuplicatesII(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1, 2, 2, 3}", "output": "5", "note": "becomes [1, 1, 2, 2, 3, _]" },
                { "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}", "output": "7" },
                { "input": "[]int{1, 1}", "output": "2" }
              ],
              "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2  // First two elements always kept\n    for fast := 2; fast < len(nums); fast++ {\n        // Compare with element two positions back\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
              "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2."
            },
            {
              "id": "v5",
              "title": "Sorted Squares",
              "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
              "functionSignature": "func sortedSquares(nums []int) []int",
              "testCases": [
                { "input": "[]int{-4, -1, 0, 3, 10}", "output": "[0, 1, 9, 16, 100]" },
                { "input": "[]int{-7, -3, 2, 3, 11}", "output": "[4, 9, 9, 49, 121]" },
                { "input": "[]int{1, 2, 3}", "output": "[1, 4, 9]" }
              ],
              "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1  // Fill from the end\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
              "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back."
            },
            {
              "id": "v6",
              "title": "Merge Sorted Array",
              "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
              "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
              "testCases": [
                { "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3", "output": "[1, 2, 2, 3, 5, 6]" },
                { "input": "[]int{1}, 1, []int{}, 0", "output": "[1]" },
                { "input": "[]int{0}, 0, []int{1}, 1", "output": "[1]" }
              ],
              "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    // Start from the end of both arrays\n    p1 := m - 1      // Last element in nums1's data\n    p2 := n - 1      // Last element in nums2\n    pos := m + n - 1 // Last position in nums1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
              "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place."
            }
          ]
        },
        {
          "id": "advanced_3",
          "baseTitle": "String Manipulation",
          "concept": "Runes + Two-Pointer Swap",
          "variants": [
            {
              "id": "v1",
              "title": "Reverse a String",
              "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
              "functionSignature": "func reverse(s string) string",
              "testCases": [
                { "input": "\"hello\"", "output": "\"olleh\"" },
                { "input": "\"‰∏ñÁïå\"", "output": "\"Áïå‰∏ñ\"" },
                { "input": "\"GoüöÄ\"", "output": "\"üöÄoG\"" }
              ],
              "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
            },
            {
              "id": "v2",
              "title": "Is Palindrome",
              "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
              "functionSignature": "func isPalindrome(s string) bool",
              "testCases": [
                { "input": "\"A man, a plan, a canal: Panama\"", "output": "true" },
                { "input": "\"race a car\"", "output": "false" },
                { "input": "\"Was it a car or a cat I saw?\"", "output": "true" }
              ],
              "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification."
            },
            {
              "id": "v3",
              "title": "Reverse Words in String",
              "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
              "functionSignature": "func reverseWords(s string) string",
              "testCases": [
                { "input": "\"hello world\"", "output": "\"world hello\"" },
                { "input": "\"the sky is blue\"", "output": "\"blue is sky the\"" },
                { "input": "\"Go\"", "output": "\"Go\"" }
              ],
              "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    // Reverse the words slice\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
              "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together."
            },
            {
              "id": "v4",
              "title": "Reverse Only Letters",
              "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
              "functionSignature": "func reverseOnlyLetters(s string) string",
              "testCases": [
                { "input": "\"a-bC-dEf-ghIj\"", "output": "\"j-Ih-gfE-dCba\"" },
                { "input": "\"ab-cd\"", "output": "\"dc-ba\"" },
                { "input": "\"Test1ng-Leet=code-Q!\"", "output": "\"Qedo1teleC-test=gnin-T!\"", "note": "wait that's wrong" }
              ],
              "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        // Skip non-letters on left\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        // Skip non-letters on right\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        // Swap letters\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
              "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic."
            },
            {
              "id": "v5",
              "title": "Valid Palindrome II",
              "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
              "functionSignature": "func validPalindromeII(s string) bool",
              "testCases": [
                { "input": "\"aba\"", "output": "true", "note": "already palindrome" },
                { "input": "\"abca\"", "output": "true", "note": "remove 'c' or 'b'" },
                { "input": "\"abc\"", "output": "false" }
              ],
              "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            // Try skipping either character\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
              "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true."
            },
            {
              "id": "v6",
              "title": "Rotate String Left",
              "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
              "functionSignature": "func rotateLeft(s string, k int) string",
              "testCases": [
                { "input": "\"abcdef\", 2", "output": "\"cdefab\"" },
                { "input": "\"hello\", 1", "output": "\"elloh\"" },
                { "input": "\"Go\", 4", "output": "\"Go\"", "note": "k=4 is same as k=0 for len=2" }
              ],
              "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)  // Handle k > length\n    \n    // Reverse first k, reverse rest, reverse all\n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
              "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!"
            }
          ]
        },
        {
          "id": "advanced_4",
          "baseTitle": "Map Counting",
          "concept": "Map Counting Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Word Counter",
              "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
              "functionSignature": "func wordCount(s string) map[string]int",
              "testCases": [
                { "input": "\"the quick brown fox jumps over the lazy dog\"", "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]" }
              ],
              "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}"
            },
            {
              "id": "v2",
              "title": "Most Frequent Element",
              "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
              "functionSignature": "func mostFrequent(nums []int) int",
              "testCases": [
                { "input": "[]int{1, 3, 2, 1, 4, 1}", "output": "1", "note": "1 appears 3 times" },
                { "input": "[]int{5, 5, 4, 4, 4}", "output": "4" },
                { "input": "[]int{7}", "output": "7" }
              ],
              "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
              "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures."
            },
            {
              "id": "v3",
              "title": "First Unique Character",
              "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
              "functionSignature": "func firstUniqChar(s string) int",
              "testCases": [
                { "input": "\"leetcode\"", "output": "0", "note": "'l' is first unique" },
                { "input": "\"loveleetcode\"", "output": "2", "note": "'v' is first unique" },
                { "input": "\"aabb\"", "output": "-1" }
              ],
              "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    // First pass: count all characters\n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    // Second pass: find first with count 1\n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
              "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order."
            },
            {
              "id": "v4",
              "title": "Is Anagram",
              "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
              "functionSignature": "func isAnagram(s, t string) bool",
              "testCases": [
                { "input": "\"anagram\", \"nagaram\"", "output": "true" },
                { "input": "\"rat\", \"car\"", "output": "false" },
                { "input": "\"listen\", \"silent\"", "output": "true" }
              ],
              "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have."
            },
            {
              "id": "v5",
              "title": "Can Construct",
              "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
              "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
              "testCases": [
                { "input": "\"a\", \"b\"", "output": "false" },
                { "input": "\"aa\", \"aab\"", "output": "true" },
                { "input": "\"aa\", \"ab\"", "output": "false", "note": "need 2 a's but only 1" }
              ],
              "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    // Count available letters\n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    // Try to use letters\n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
              "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa."
            },
            {
              "id": "v6",
              "title": "Majority Element",
              "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
              "functionSignature": "func majorityElement(nums []int) int",
              "testCases": [
                { "input": "[]int{3, 2, 3}", "output": "3" },
                { "input": "[]int{2, 2, 1, 1, 1, 2, 2}", "output": "2" },
                { "input": "[]int{1, 1, 1, 1}", "output": "1" }
              ],
              "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1  // Won't reach here per problem guarantee\n}",
              "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!"
            }
          ]
        },
        {
          "id": "advanced_5",
          "baseTitle": "Hash Map Lookup",
          "concept": "Hash Map Complement Pattern",
          "variants": [
            {
              "id": "v1",
              "title": "Two Sum",
              "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
              "functionSignature": "func twoSum(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[0, 1]" },
                { "input": "[]int{3, 2, 4}, 6", "output": "[1, 2]" },
                { "input": "[]int{3, 3}, 6", "output": "[0, 1]" }
              ],
              "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}"
            },
            {
              "id": "v2",
              "title": "Two Sum II (Sorted Input)",
              "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
              "functionSignature": "func twoSumSorted(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{2, 7, 11, 15}, 9", "output": "[1, 2]", "note": "1-indexed!" },
                { "input": "[]int{2, 3, 4}, 6", "output": "[1, 3]" },
                { "input": "[]int{-1, 0}, -1", "output": "[1, 2]" }
              ],
              "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}  // 1-indexed\n        } else if sum < target {\n            left++  // Need bigger sum\n        } else {\n            right--  // Need smaller sum\n        }\n    }\n    return nil\n}",
              "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum."
            },
            {
              "id": "v3",
              "title": "Pair with Difference",
              "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
              "functionSignature": "func pairWithDiff(nums []int, target int) []int",
              "testCases": [
                { "input": "[]int{5, 20, 3, 2, 50, 80}, 78", "output": "[1, 5]", "note": "80 - 2 = 78... wait" },
                { "input": "[]int{1, 5, 3}, 2", "output": "[0, 2]", "note": "3 - 1 = 2" },
                { "input": "[]int{1, 2, 3}, 10", "output": "nil" }
              ],
              "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)  // value -> index\n    \n    for i, num := range nums {\n        // Check if num - target exists (num is larger)\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        // Check if num + target exists (num is smaller)\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
              "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k)."
            },
            {
              "id": "v4",
              "title": "Count Pairs with Sum",
              "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
              "functionSignature": "func countPairs(nums []int, target int) int",
              "testCases": [
                { "input": "[]int{1, 5, 7, 1}, 6", "output": "2", "note": "(1,5) and (1,5)" },
                { "input": "[]int{1, 1, 1, 1}, 2", "output": "2", "note": "two pairs of 1+1" },
                { "input": "[]int{1, 2, 3}, 10", "output": "0" }
              ],
              "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            // Same number: count pairs within this group\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            // Different numbers: multiply counts (only count once via complement > num)\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
              "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting."
            },
            {
              "id": "v5",
              "title": "Three Sum Exists",
              "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
              "functionSignature": "func threeSumExists(nums []int) bool",
              "testCases": [
                { "input": "[]int{-1, 0, 1, 2}", "output": "true", "note": "-1 + 0 + 1 = 0" },
                { "input": "[]int{1, 2, 3}", "output": "false" },
                { "input": "[]int{0, 0, 0}", "output": "true" }
              ],
              "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        // Skip duplicates for i\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        // Two-pointer for remaining two numbers\n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
              "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n¬≤) total."
            },
            {
              "id": "v6",
              "title": "Subarray Sum Equals K",
              "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
              "functionSignature": "func subarraySum(nums []int, k int) int",
              "testCases": [
                { "input": "[]int{1, 1, 1}, 2", "output": "2", "note": "[1,1] at positions 0-1 and 1-2" },
                { "input": "[]int{1, 2, 3}, 3", "output": "2", "note": "[1,2] and [3]" },
                { "input": "[]int{1, -1, 0}, 0", "output": "3" }
              ],
              "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1  // Empty prefix has sum 0\n    \n    for _, num := range nums {\n        prefixSum += num\n        // If prefixSum - k exists, we found subarrays\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
              "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred."
            }
          ]
        }
      ],
      "preExercises": {
        "advanced_1": {
          "title": "Pre-exercise: Map as a Set",
          "description": "Before tackling the algorithm, let's practice the core pattern: using a map to track what you've seen.",
          "exercises": [
            {
              "id": "pre1",
              "title": "Track Visited Pages",
              "problem": "You're building a browser history tracker. Write code that creates a <code>map[string]bool</code> called <code>visited</code>, marks three pages as visited, then checks if \"google.com\" has been visited.",
              "hints": [
                {
                  "title": "Creating the map",
                  "content": "Create with: <code>visited := make(map[string]bool)</code><br>This creates an empty map where keys are strings and values are booleans."
                },
                {
                  "title": "Marking as visited",
                  "content": "To mark a page as visited: <code>visited[\"google.com\"] = true</code><br>Do this for three different pages."
                },
                {
                  "title": "Checking if visited",
                  "content": "The simple way: <code>if visited[\"google.com\"]</code><br>This works because if the key doesn't exist, Go returns <code>false</code> (the zero value for bool)!"
                }
              ],
              "solution": "visited := make(map[string]bool)\n\n// Mark pages as visited\nvisited[\"google.com\"] = true\nvisited[\"github.com\"] = true\nvisited[\"go.dev\"] = true\n\n// Check if google.com was visited\nif visited[\"google.com\"] {\n    fmt.Println(\"You've been to google.com\")\n}\n\n// Check something NOT visited\nif visited[\"facebook.com\"] {\n    fmt.Println(\"You've been to facebook.com\")\n} else {\n    fmt.Println(\"Never visited facebook.com\")\n}",
              "expectedOutput": "You've been to google.com\nNever visited facebook.com",
              "keyInsight": "When you access a key that doesn't exist in a <code>map[T]bool</code>, Go returns <code>false</code>. This makes <code>if visited[key]</code> a clean way to check membership - no need for the comma-ok pattern here!"
            },
            {
              "id": "pre2",
              "title": "Unique Letter Collector",
              "problem": "Write code that loops through the string \"banana\" and collects each unique letter into a <code>map[rune]bool</code>. Print how many unique letters there are.",
              "hints": [
                {
                  "title": "Setup",
                  "content": "Create the map: <code>letters := make(map[rune]bool)</code><br>Loop with: <code>for _, char := range \"banana\"</code>"
                },
                {
                  "title": "Collecting",
                  "content": "For each character, just mark it as seen: <code>letters[char] = true</code><br>Maps automatically handle duplicates - setting the same key twice just overwrites."
                },
                {
                  "title": "Counting",
                  "content": "The number of unique letters is: <code>len(letters)</code>"
                }
              ],
              "solution": "letters := make(map[rune]bool)\n\nfor _, char := range \"banana\" {\n    letters[char] = true\n}\n\nfmt.Printf(\"Unique letters: %d\\n\", len(letters))  // 3: b, a, n",
              "expectedOutput": "Unique letters: 3",
              "keyInsight": "A map automatically handles duplicates - you can set the same key multiple times and it just overwrites. This is why <code>len(map)</code> gives you the count of unique keys!"
            }
          ]
        }
      }
    };

    function loadVariants() {
        variantsData = variantsDataEmbedded;
        shuffleVariants();
    }

    function shuffleVariants() {
        if (!variantsData) return;

        // Pick a DIFFERENT random variant for each exercise
        variantsData.advanced.forEach(exercise => {
            const currentVariant = currentVariants[exercise.id];
            const availableVariants = exercise.variants.filter(v =>
                !currentVariant || v.id !== currentVariant.id
            );
            // If all variants exhausted (only 1), just pick randomly
            const pool = availableVariants.length > 0 ? availableVariants : exercise.variants;
            const randomIndex = Math.floor(Math.random() * pool.length);
            currentVariants[exercise.id] = pool[randomIndex];
        });

        renderExercises();

        // Visual feedback - flash the button
        const btn = document.getElementById('shuffle-btn');
        if (btn) {
            btn.textContent = '‚úì Shuffled!';
            btn.style.background = 'var(--green-bright)';
            btn.style.color = 'var(--bg-dark)';
            btn.style.borderColor = 'var(--green-bright)';
            setTimeout(() => {
                btn.textContent = 'üé≤ Shuffle Variants';
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--purple)';
                btn.style.borderColor = 'var(--purple)';
            }, 800);
        }
    }

    function renderExercises() {
        const container = document.getElementById('advanced-exercises-container');
        if (!container) return;

        let html = '';

        // Render pre-exercises first
        html += renderPreExercises();

        // Render each advanced exercise
        variantsData.advanced.forEach((exercise, idx) => {
            const variant = currentVariants[exercise.id];
            const shared = sharedContent[exercise.id];
            const num = idx + 1;

            html += `<div class="exercise">
                <h4>Advanced ${num}: ${variant.title}</h4>
                <p>${variant.description}</p>`;

            // Add pre-reading if available
            if (shared && shared.preReading) {
                html += `<details>
                    <summary>${shared.preReading.title}</summary>
                    <div class="hint-content">${shared.preReading.content}</div>
                </details>`;
            }

            // Add hints
            if (shared && shared.hints) {
                shared.hints.forEach(hint => {
                    html += `<details>
                        <summary>${hint.title}</summary>
                        <div class="hint-content">${hint.content}</div>
                    </details>`;
                });
            }

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution with Explanation</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(variant.solution)}</pre>
                    ${variant.solutionNotes ? `<br>${variant.solutionNotes}` : ''}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${variant.testCases.map(tc =>
                    `${variant.functionSignature.match(/func (\w+)/)[1]}(${tc.input}) ‚Üí ${tc.output}${tc.note ? ` (${tc.note})` : ''}`
                ).join('\n')}</pre>
            </div>`;

            html += '</div>';
        });

        container.innerHTML = html;
    }

    function renderPreExercises() {
        if (!variantsData.preExercises || !variantsData.preExercises.advanced_1) {
            return '';
        }

        const preEx = variantsData.preExercises.advanced_1;
        let html = `
            <div class="tip" style="background: rgba(157, 0, 255, 0.1); border-left-color: var(--purple); margin-bottom: 1.5rem;">
                <div class="tip-title" style="color: var(--purple);">üéØ ${preEx.title}</div>
                <p style="color: var(--text-dim); margin-bottom: 1rem;">${preEx.description}</p>
            </div>`;

        preEx.exercises.forEach((ex, idx) => {
            html += `<div class="exercise" style="border-color: var(--purple); margin-bottom: 1.5rem;">
                <h4 style="color: var(--purple);">Pre-${idx + 1}: ${ex.title}</h4>
                <p>${ex.problem}</p>`;

            // Add hints
            ex.hints.forEach(hint => {
                html += `<details>
                    <summary>üí° ${hint.title}</summary>
                    <div class="hint-content">${hint.content}</div>
                </details>`;
            });

            // Add solution
            html += `<details>
                <summary>‚úÖ Solution</summary>
                <div class="hint-content">
                    <pre>${escapeHtml(ex.solution)}</pre>
                    <br><strong>Key insight:</strong> ${ex.keyInsight}
                </div>
            </details>`;

            // Add expected output
            html += `<div class="expected">
                <div class="expected-title">Expected Output</div>
                <pre>${escapeHtml(ex.expectedOutput)}</pre>
            </div>`;

            html += '</div>';
        });

        return html;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Load variants on page load
    document.addEventListener('DOMContentLoaded', loadVariants);

    // Style the shuffle button hover
    document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('shuffle-btn');
        if (btn) {
            btn.addEventListener('mouseenter', () => {
                btn.style.background = 'var(--purple)';
                btn.style.color = 'white';
            });
            btn.addEventListener('mouseleave', () => {
                btn.style.background = 'var(--bg-card)';
                btn.style.color = 'var(--purple)';
            });
        }
    });
    </script>
</body>
</html>

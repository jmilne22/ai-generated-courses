<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 10: Design Patterns | Go From Python</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=20260125">
</head>
<body>
    <div class="container">
        <nav><a href="module9.html">‚Üê Module 9</a><a href="module11.html">Module 11 ‚Üí</a></nav>
        <div class="module-tag">// MODULE 10</div>
        <h1>Design Patterns in Go</h1>
        <p class="module-desc">Patterns that actually matter. Factory, options, strategy, and builder.</p>

        <div class="lesson">
            <h2>The Functional Options Pattern</h2>
            <p>The most "Go" pattern. Flexible configuration without breaking APIs.</p>
            <div class="code-block">
                <div class="code-header">Functional options</div>
                <pre><span class="keyword">type</span> <span class="type">Server</span> <span class="keyword">struct</span> {
    host    <span class="type">string</span>
    port    <span class="type">int</span>
    timeout time.Duration
    maxConn <span class="type">int</span>
}

<span class="comment">// Option is a function that configures Server</span>
<span class="keyword">type</span> <span class="type">Option</span> <span class="keyword">func</span>(*<span class="type">Server</span>)

<span class="comment">// Option functions</span>
<span class="keyword">func</span> <span class="func">WithPort</span>(port <span class="type">int</span>) <span class="type">Option</span> {
    <span class="keyword">return</span> <span class="keyword">func</span>(s *<span class="type">Server</span>) {
        s.port = port
    }
}

<span class="keyword">func</span> <span class="func">WithTimeout</span>(d time.Duration) <span class="type">Option</span> {
    <span class="keyword">return</span> <span class="keyword">func</span>(s *<span class="type">Server</span>) {
        s.timeout = d
    }
}

<span class="keyword">func</span> <span class="func">WithMaxConnections</span>(n <span class="type">int</span>) <span class="type">Option</span> {
    <span class="keyword">return</span> <span class="keyword">func</span>(s *<span class="type">Server</span>) {
        s.maxConn = n
    }
}

<span class="comment">// Constructor with variadic options</span>
<span class="keyword">func</span> <span class="func">NewServer</span>(host <span class="type">string</span>, opts ...<span class="type">Option</span>) *<span class="type">Server</span> {
    s := &<span class="type">Server</span>{
        host:    host,
        port:    <span class="number">8080</span>,          <span class="comment">// defaults</span>
        timeout: <span class="number">30</span> * time.Second,
        maxConn: <span class="number">100</span>,
    }
    
    <span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts {
        opt(s)
    }
    
    <span class="keyword">return</span> s
}

<span class="comment">// Usage ‚Äî clean and extensible!</span>
server := <span class="func">NewServer</span>(<span class="string">"localhost"</span>)
server := <span class="func">NewServer</span>(<span class="string">"localhost"</span>, <span class="func">WithPort</span>(<span class="number">9000</span>))
server := <span class="func">NewServer</span>(<span class="string">"localhost"</span>,
    <span class="func">WithPort</span>(<span class="number">9000</span>),
    <span class="func">WithTimeout</span>(<span class="number">60</span>*time.Second),
    <span class="func">WithMaxConnections</span>(<span class="number">500</span>),
)</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Why This Rules</div>
                <p>Add new options without breaking existing code. Clear defaults. Self-documenting API.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Factory Pattern</h2>
            <div class="code-block">
                <div class="code-header">Factory functions</div>
                <pre><span class="comment">// Interface</span>
<span class="keyword">type</span> <span class="type">Storage</span> <span class="keyword">interface</span> {
    <span class="func">Save</span>(key <span class="type">string</span>, data []<span class="type">byte</span>) <span class="type">error</span>
    <span class="func">Load</span>(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)
}

<span class="comment">// Implementations</span>
<span class="keyword">type</span> <span class="type">FileStorage</span> <span class="keyword">struct</span> { dir <span class="type">string</span> }
<span class="keyword">type</span> <span class="type">S3Storage</span> <span class="keyword">struct</span> { bucket <span class="type">string</span> }
<span class="keyword">type</span> <span class="type">MemoryStorage</span> <span class="keyword">struct</span> { data <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span> }

<span class="comment">// Factory function</span>
<span class="keyword">func</span> <span class="func">NewStorage</span>(storageType <span class="type">string</span>, config <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) (<span class="type">Storage</span>, <span class="type">error</span>) {
    <span class="keyword">switch</span> storageType {
    <span class="keyword">case</span> <span class="string">"file"</span>:
        <span class="keyword">return</span> &<span class="type">FileStorage</span>{dir: config[<span class="string">"dir"</span>]}, <span class="keyword">nil</span>
    <span class="keyword">case</span> <span class="string">"s3"</span>:
        <span class="keyword">return</span> &<span class="type">S3Storage</span>{bucket: config[<span class="string">"bucket"</span>]}, <span class="keyword">nil</span>
    <span class="keyword">case</span> <span class="string">"memory"</span>:
        <span class="keyword">return</span> &<span class="type">MemoryStorage</span>{data: <span class="keyword">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">byte</span>)}, <span class="keyword">nil</span>
    <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="keyword">nil</span>, fmt.<span class="func">Errorf</span>(<span class="string">"unknown storage type: %s"</span>, storageType)
    }
}

<span class="comment">// Usage</span>
storage, err := <span class="func">NewStorage</span>(<span class="string">"s3"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>{<span class="string">"bucket"</span>: <span class="string">"my-bucket"</span>})</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Strategy Pattern</h2>
            <p>Swap algorithms at runtime using interfaces.</p>
            <div class="code-block">
                <div class="code-header">Strategy pattern</div>
                <pre><span class="comment">// Strategy interface</span>
<span class="keyword">type</span> <span class="type">Compressor</span> <span class="keyword">interface</span> {
    <span class="func">Compress</span>(data []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)
    <span class="func">Decompress</span>(data []<span class="type">byte</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)
}

<span class="comment">// Strategies</span>
<span class="keyword">type</span> <span class="type">GzipCompressor</span> <span class="keyword">struct</span>{}
<span class="keyword">type</span> <span class="type">ZstdCompressor</span> <span class="keyword">struct</span>{}
<span class="keyword">type</span> <span class="type">NoCompressor</span> <span class="keyword">struct</span>{}

<span class="comment">// Context that uses strategy</span>
<span class="keyword">type</span> <span class="type">FileProcessor</span> <span class="keyword">struct</span> {
    compressor <span class="type">Compressor</span>
}

<span class="keyword">func</span> (p *<span class="type">FileProcessor</span>) <span class="func">SaveFile</span>(path <span class="type">string</span>, data []<span class="type">byte</span>) <span class="type">error</span> {
    compressed, err := p.compressor.<span class="func">Compress</span>(data)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> {
        <span class="keyword">return</span> err
    }
    <span class="keyword">return</span> os.<span class="func">WriteFile</span>(path, compressed, <span class="number">0644</span>)
}

<span class="comment">// Swap strategy at runtime</span>
processor := &<span class="type">FileProcessor</span>{compressor: &<span class="type">GzipCompressor</span>{}}
processor.compressor = &<span class="type">ZstdCompressor</span>{}  <span class="comment">// Change strategy</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Builder Pattern</h2>
            <div class="code-block">
                <div class="code-header">Builder pattern</div>
                <pre><span class="keyword">type</span> <span class="type">Query</span> <span class="keyword">struct</span> {
    table   <span class="type">string</span>
    columns []<span class="type">string</span>
    where   []<span class="type">string</span>
    orderBy <span class="type">string</span>
    limit   <span class="type">int</span>
}

<span class="keyword">type</span> <span class="type">QueryBuilder</span> <span class="keyword">struct</span> {
    query <span class="type">Query</span>
}

<span class="keyword">func</span> <span class="func">NewQueryBuilder</span>(table <span class="type">string</span>) *<span class="type">QueryBuilder</span> {
    <span class="keyword">return</span> &<span class="type">QueryBuilder</span>{query: <span class="type">Query</span>{table: table}}
}

<span class="keyword">func</span> (b *<span class="type">QueryBuilder</span>) <span class="func">Select</span>(cols ...<span class="type">string</span>) *<span class="type">QueryBuilder</span> {
    b.query.columns = cols
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *<span class="type">QueryBuilder</span>) <span class="func">Where</span>(condition <span class="type">string</span>) *<span class="type">QueryBuilder</span> {
    b.query.where = <span class="func">append</span>(b.query.where, condition)
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *<span class="type">QueryBuilder</span>) <span class="func">OrderBy</span>(col <span class="type">string</span>) *<span class="type">QueryBuilder</span> {
    b.query.orderBy = col
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *<span class="type">QueryBuilder</span>) <span class="func">Limit</span>(n <span class="type">int</span>) *<span class="type">QueryBuilder</span> {
    b.query.limit = n
    <span class="keyword">return</span> b
}

<span class="keyword">func</span> (b *<span class="type">QueryBuilder</span>) <span class="func">Build</span>() <span class="type">string</span> {
    <span class="comment">// Build SQL string from query struct</span>
    <span class="keyword">return</span> <span class="string">"..."</span>
}

<span class="comment">// Usage ‚Äî fluent API</span>
sql := <span class="func">NewQueryBuilder</span>(<span class="string">"users"</span>).
    <span class="func">Select</span>(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"email"</span>).
    <span class="func">Where</span>(<span class="string">"active = true"</span>).
    <span class="func">Where</span>(<span class="string">"age > 18"</span>).
    <span class="func">OrderBy</span>(<span class="string">"created_at DESC"</span>).
    <span class="func">Limit</span>(<span class="number">10</span>).
    <span class="func">Build</span>()</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            
            <div class="exercise">
                <h4>Exercise 1: HTTP Client with Options</h4>
                <p>Create <code>HTTPClient</code> using functional options: <code>WithTimeout</code>, <code>WithRetries</code>, <code>WithBaseURL</code>.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Define <code>type Option func(*HTTPClient)</code>. Each With function returns an Option. Apply in constructor.
                    </div>
                </details>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>type HTTPClient struct {
    timeout time.Duration
    retries int
    baseURL string
}

type Option func(*HTTPClient)

func WithTimeout(d time.Duration) Option {
    return func(c *HTTPClient) { c.timeout = d }
}

func WithRetries(n int) Option {
    return func(c *HTTPClient) { c.retries = n }
}

func WithBaseURL(url string) Option {
    return func(c *HTTPClient) { c.baseURL = url }
}

func NewHTTPClient(opts ...Option) *HTTPClient {
    c := &HTTPClient{timeout: 30 * time.Second}
    for _, opt := range opts {
        opt(c)
    }
    return c
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Usage</div>
                    <pre>client := NewHTTPClient(
    WithTimeout(10*time.Second),
    WithRetries(3),
    WithBaseURL("https://api.example.com"),
)</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Exercise 2: Logger Factory</h4>
                <p>Create factory returning different loggers: "console" ‚Üí stdout, "file" ‚Üí file, "null" ‚Üí discard.</p>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>type Logger interface {
    Log(msg string)
}

func NewLogger(logType string) Logger {
    switch logType {
    case "console":
        return &ConsoleLogger{}
    case "file":
        return &FileLogger{file: "app.log"}
    case "null":
        return &NullLogger{}
    default:
        return &ConsoleLogger{}
    }
}</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Exercise 3: Sort Strategy</h4>
                <p>Define <code>Sorter</code> interface. Implement <code>BubbleSort</code>, <code>QuickSort</code>. Create <code>DataProcessor</code> that accepts any Sorter.</p>
                
                <details>
                    <summary>üí° Hint</summary>
                    <div class="hint-content">
                        Interface: <code>Sort([]int) []int</code>. DataProcessor has a Sorter field. Can swap strategies at runtime.
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Exercise 4: SQL Builder</h4>
                <p>Build fluent SQL query builder: <code>NewQuery("users").Select("name").Where("active = ?", true).Limit(10).String()</code></p>
                
                <details>
                    <summary>‚úÖ Solution</summary>
                    <div class="hint-content">
<pre>type Query struct {
    table   string
    cols    []string
    wheres  []string
    limit   int
}

func NewQuery(table string) *Query {
    return &Query{table: table, cols: []string{"*"}}
}

func (q *Query) Select(cols ...string) *Query {
    q.cols = cols
    return q
}

func (q *Query) Where(cond string, args ...any) *Query {
    q.wheres = append(q.wheres, fmt.Sprintf(cond, args...))
    return q
}

func (q *Query) Limit(n int) *Query {
    q.limit = n
    return q
}

func (q *Query) String() string {
    sql := fmt.Sprintf("SELECT %s FROM %s", 
        strings.Join(q.cols, ", "), q.table)
    if len(q.wheres) > 0 {
        sql += " WHERE " + strings.Join(q.wheres, " AND ")
    }
    if q.limit > 0 {
        sql += fmt.Sprintf(" LIMIT %d", q.limit)
    }
    return sql
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>NewQuery("users").Select("name", "email").Where("active = %t", true).Limit(10).String()
// "SELECT name, email FROM users WHERE active = true LIMIT 10"</pre>
                </div>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 10 Summary</h2>
            <ul>
                <li><strong>Functional Options</strong> ‚Äî flexible config with defaults</li>
                <li><strong>Factory</strong> ‚Äî create objects without specifying concrete types</li>
                <li><strong>Strategy</strong> ‚Äî swap algorithms via interfaces</li>
                <li><strong>Builder</strong> ‚Äî fluent API for complex object construction</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="module9.html" class="nav-btn">‚Üê Module 9</a>
            <a href="module11.html" class="nav-btn primary">Module 11: HTTP & APIs ‚Üí</a>
        </div>
    </div>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 5: Data Structures | Go From Python</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="themes/oled-dark.css">
    <link rel="stylesheet" href="themes/light.css">
    <link rel="stylesheet" href="themes/gruvbox-dark.css">
    <link rel="stylesheet" href="themes/gruvbox-light.css">
    <link rel="stylesheet" href="themes/solarized-dark.css">
    <link rel="stylesheet" href="themes/solarized-light.css">
    <link rel="stylesheet" href="themes/everforest-dark.css">
    <link rel="stylesheet" href="themes/everforest-light.css">
    <link rel="stylesheet" href="themes/persona5-dark.css">
    <link rel="stylesheet" href="themes/factorio-dark.css">
</head>
<body data-module="5">
    <div class="container">
        <nav>
            <a href="module4.html">‚Üê Module 4</a>
            <a href="module6.html">Module 6 ‚Üí</a>
        </nav>
        <div class="module-tag">// MODULE 05</div>
        <h1>Data Structures</h1>
        <p class="module-desc">Slices deep dive, maps, and building your own data structures with generics.</p>

        <div class="lesson">
            <h2>Slices: The Deep Dive</h2>
            <p>Slices are Go's workhorse. They're more complex than Python lists under the hood.</p>
            <div class="code-block">
                <div class="code-header">Slice internals</div>
                <pre><span class="comment">// A slice is a struct with 3 fields:</span>
<span class="comment">// - pointer to underlying array</span>
<span class="comment">// - length (current elements)</span>
<span class="comment">// - capacity (max before realloc)</span>

s := <span class="keyword">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>)  <span class="comment">// len=3, cap=10</span>
fmt.<span class="func">Println</span>(<span class="func">len</span>(s))  <span class="comment">// 3</span>
fmt.<span class="func">Println</span>(<span class="func">cap</span>(s))  <span class="comment">// 10</span>

<span class="comment">// Append grows the slice</span>
s = <span class="func">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)

<span class="comment">// Slicing creates a view (shares memory!)</span>
original := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}
slice := original[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">// [2 3 4]</span>
slice[<span class="number">0</span>] = <span class="number">999</span>
fmt.<span class="func">Println</span>(original)  <span class="comment">// [1 999 3 4 5] ‚Äî modified!</span></pre>
            </div>
            <div class="warning">
                <div class="warning-title">Gotcha</div>
                <p>Slicing creates a view, not a copy. Modifying the slice modifies the original!</p>
            </div>

            <h3>Common Slice Operations</h3>
            <div class="code-block">
                <div class="code-header">Slice operations</div>
                <pre><span class="comment">// Copy (to avoid shared memory)</span>
dst := <span class="keyword">make</span>([]<span class="type">int</span>, <span class="func">len</span>(src))
<span class="func">copy</span>(dst, src)

<span class="comment">// Delete element at index i</span>
s = <span class="func">append</span>(s[:<span class="number">i</span>], s[<span class="number">i</span>+<span class="number">1</span>:]...)

<span class="comment">// Insert at index i</span>
s = <span class="func">append</span>(s[:<span class="number">i</span>], <span class="func">append</span>([]<span class="type">int</span>{newItem}, s[<span class="number">i</span>:]...)...)

<span class="comment">// Filter (create new slice)</span>
<span class="keyword">var</span> filtered []<span class="type">int</span>
<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums {
    <span class="keyword">if</span> v > <span class="number">10</span> {
        filtered = <span class="func">append</span>(filtered, v)
    }
}

<span class="comment">// Reverse in place</span>
<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="func">len</span>(s)-<span class="number">1</span>; i < j; i, j = i+<span class="number">1</span>, j-<span class="number">1</span> {
    s[i], s[j] = s[j], s[i]
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Maps Deep Dive</h2>
            <div class="code-block">
                <div class="code-header">Map operations</div>
                <pre><span class="comment">// Create</span>
m := <span class="keyword">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)
m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>{<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>}

<span class="comment">// Check existence (IMPORTANT!)</span>
val, ok := m[<span class="string">"key"</span>]
<span class="keyword">if</span> !ok {
    <span class="comment">// key doesn't exist</span>
}

<span class="comment">// Delete</span>
<span class="func">delete</span>(m, <span class="string">"key"</span>)

<span class="comment">// Iterate (random order!)</span>
<span class="keyword">for</span> key, val := <span class="keyword">range</span> m {
    fmt.<span class="func">Println</span>(key, val)
}

<span class="comment">// Get keys</span>
keys := <span class="keyword">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="func">len</span>(m))
<span class="keyword">for</span> k := <span class="keyword">range</span> m {
    keys = <span class="func">append</span>(keys, k)
}</pre>
            </div>
            <div class="tip">
                <div class="tip-title">Map Iteration</div>
                <p>Map iteration order is random by design. If you need ordered keys, sort them separately.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Building a Set</h2>
            <p>Go doesn't have a built-in set. Use a map with empty struct values.</p>
            <div class="code-block">
                <div class="code-header">Set implementation</div>
                <pre><span class="comment">// Set using map[T]struct{}</span>
<span class="comment">// struct{} takes zero bytes!</span>

<span class="keyword">type</span> <span class="type">Set</span>[T comparable] <span class="keyword">map</span>[T]<span class="keyword">struct</span>{}

<span class="keyword">func</span> <span class="func">NewSet</span>[T comparable]() <span class="type">Set</span>[T] {
    <span class="keyword">return</span> <span class="keyword">make</span>(<span class="type">Set</span>[T])
}

<span class="keyword">func</span> (s <span class="type">Set</span>[T]) <span class="func">Add</span>(item T) {
    s[item] = <span class="keyword">struct</span>{}{}
}

<span class="keyword">func</span> (s <span class="type">Set</span>[T]) <span class="func">Contains</span>(item T) <span class="type">bool</span> {
    _, ok := s[item]
    <span class="keyword">return</span> ok
}

<span class="keyword">func</span> (s <span class="type">Set</span>[T]) <span class="func">Remove</span>(item T) {
    <span class="func">delete</span>(s, item)
}

<span class="comment">// Usage</span>
fruits := <span class="func">NewSet</span>[<span class="type">string</span>]()
fruits.<span class="func">Add</span>(<span class="string">"apple"</span>)
fruits.<span class="func">Add</span>(<span class="string">"banana"</span>)
fmt.<span class="func">Println</span>(fruits.<span class="func">Contains</span>(<span class="string">"apple"</span>))  <span class="comment">// true</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Building a Stack</h2>
            <div class="code-block">
                <div class="code-header">Generic stack</div>
                <pre><span class="keyword">type</span> <span class="type">Stack</span>[T <span class="type">any</span>] <span class="keyword">struct</span> {
    items []T
}

<span class="keyword">func</span> (s *<span class="type">Stack</span>[T]) <span class="func">Push</span>(item T) {
    s.items = <span class="func">append</span>(s.items, item)
}

<span class="keyword">func</span> (s *<span class="type">Stack</span>[T]) <span class="func">Pop</span>() (T, <span class="type">bool</span>) {
    <span class="keyword">if</span> <span class="func">len</span>(s.items) == <span class="number">0</span> {
        <span class="keyword">var</span> zero T
        <span class="keyword">return</span> zero, <span class="keyword">false</span>
    }
    item := s.items[<span class="func">len</span>(s.items)-<span class="number">1</span>]
    s.items = s.items[:<span class="func">len</span>(s.items)-<span class="number">1</span>]
    <span class="keyword">return</span> item, <span class="keyword">true</span>
}

<span class="keyword">func</span> (s *<span class="type">Stack</span>[T]) <span class="func">Peek</span>() (T, <span class="type">bool</span>) {
    <span class="keyword">if</span> <span class="func">len</span>(s.items) == <span class="number">0</span> {
        <span class="keyword">var</span> zero T
        <span class="keyword">return</span> zero, <span class="keyword">false</span>
    }
    <span class="keyword">return</span> s.items[<span class="func">len</span>(s.items)-<span class="number">1</span>], <span class="keyword">true</span>
}

<span class="keyword">func</span> (s *<span class="type">Stack</span>[T]) <span class="func">Len</span>() <span class="type">int</span> {
    <span class="keyword">return</span> <span class="func">len</span>(s.items)
}

<span class="comment">// Usage</span>
stack := &<span class="type">Stack</span>[<span class="type">int</span>]{}
stack.<span class="func">Push</span>(<span class="number">1</span>)
stack.<span class="func">Push</span>(<span class="number">2</span>)
val, _ := stack.<span class="func">Pop</span>()  <span class="comment">// 2</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Building a Queue</h2>
            <div class="code-block">
                <div class="code-header">Generic queue</div>
                <pre><span class="keyword">type</span> <span class="type">Queue</span>[T <span class="type">any</span>] <span class="keyword">struct</span> {
    items []T
}

<span class="keyword">func</span> (q *<span class="type">Queue</span>[T]) <span class="func">Enqueue</span>(item T) {
    q.items = <span class="func">append</span>(q.items, item)
}

<span class="keyword">func</span> (q *<span class="type">Queue</span>[T]) <span class="func">Dequeue</span>() (T, <span class="type">bool</span>) {
    <span class="keyword">if</span> <span class="func">len</span>(q.items) == <span class="number">0</span> {
        <span class="keyword">var</span> zero T
        <span class="keyword">return</span> zero, <span class="keyword">false</span>
    }
    item := q.items[<span class="number">0</span>]
    q.items = q.items[<span class="number">1</span>:]
    <span class="keyword">return</span> item, <span class="keyword">true</span>
}

<span class="keyword">func</span> (q *<span class="type">Queue</span>[T]) <span class="func">IsEmpty</span>() <span class="type">bool</span> {
    <span class="keyword">return</span> <span class="func">len</span>(q.items) == <span class="number">0</span>
}</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Generics Basics</h2>
            <p>Go 1.18+ introduced generics. Write once, use with any type.</p>
            <div class="code-block">
                <div class="code-header">Generic functions</div>
                <pre><span class="comment">// Generic function</span>
<span class="keyword">func</span> <span class="func">Min</span>[T constraints.Ordered](a, b T) T {
    <span class="keyword">if</span> a < b {
        <span class="keyword">return</span> a
    }
    <span class="keyword">return</span> b
}

<span class="comment">// Works with any ordered type</span>
<span class="func">Min</span>(<span class="number">3</span>, <span class="number">5</span>)          <span class="comment">// 3</span>
<span class="func">Min</span>(<span class="string">"a"</span>, <span class="string">"b"</span>)      <span class="comment">// "a"</span>
<span class="func">Min</span>(<span class="number">3.14</span>, <span class="number">2.71</span>)    <span class="comment">// 2.71</span>

<span class="comment">// Generic Map function</span>
<span class="keyword">func</span> <span class="func">Map</span>[T, U <span class="type">any</span>](items []T, f <span class="keyword">func</span>(T) U) []U {
    result := <span class="keyword">make</span>([]U, <span class="func">len</span>(items))
    <span class="keyword">for</span> i, item := <span class="keyword">range</span> items {
        result[i] = f(item)
    }
    <span class="keyword">return</span> result
}

<span class="comment">// Usage</span>
nums := []<span class="type">int</span>{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}
doubled := <span class="func">Map</span>(nums, <span class="keyword">func</span>(n <span class="type">int</span>) <span class="type">int</span> { <span class="keyword">return</span> n * <span class="number">2</span> })
<span class="comment">// [2, 4, 6]</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Exercises</h2>
            <p>Progress through each section in order, or jump to where you need practice.</p>

            <div style="background: var(--bg-card); border-radius: 8px; padding: 1rem 1.5rem; margin: 1rem 0 2rem 0;">
                <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text);">Jump to section:</div>
                <div style="display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; font-size: 0.9rem;">
                    <a href="#warmups" style="color: var(--green-bright);">üî• Warmups</a>
                    <a href="#challenges" style="color: var(--orange);">üí™ Challenges</a>
                </div>
            </div>

            <div style="display: flex; align-items: center; gap: 1rem; margin-top: 1.5rem;">
                <h3 id="warmups" style="color: var(--green-bright); margin: 0;">üî• Warmups</h3>
                <button id="shuffle-warmups-btn" onclick="shuffleWarmups()" style="background: var(--bg-card); border: 2px solid var(--green-bright); color: var(--green-bright); padding: 0.4rem 0.9rem; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-family: 'JetBrains Mono', monospace; transition: all 0.3s;">üé≤ Shuffle</button>
            </div>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice individual concepts you just learned.</p>

            <div id="warmups-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div>

            <h3 id="challenges" style="color: var(--orange); margin-top: 2rem;">üí™ Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 0.5rem;">Combine concepts and learn patterns. Each challenge has multiple variants at different difficulties.</p>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 1rem;">
                <button id="shuffle-challenges-btn" onclick="shuffleChallenges()" style="background: var(--bg-card); border: 1px solid var(--orange); color: var(--orange); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; transition: all 0.3s;">
                    üé≤ Shuffle Challenges
                </button>
            </div>

            <div id="challenges-container">
            <noscript><p class="js-required">JavaScript is required for the interactive exercises.</p></noscript>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 5 Summary</h2>
            <ul>
                <li><strong>Slices</strong> have length AND capacity</li>
                <li><strong>Slicing shares memory</strong> ‚Äî use copy() for independence</li>
                <li><strong>Maps iterate randomly</strong> ‚Äî sort keys if order matters</li>
                <li><strong>Set = map[T]struct{}</strong></li>
                <li><strong>Generics</strong> with [T any] or [T constraints.Ordered]</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="module4.html" class="nav-btn">‚Üê Module 4</a>
            <a href="module6.html" class="nav-btn primary">Module 6: CLI Foundations ‚Üí</a>
        </div>
    </div>
    <script src="module-loader.js"></script>
    <script src="course.js"></script>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
    <script src="srs.js"></script>
    <script src="progress.js"></script>
</body>
</html>

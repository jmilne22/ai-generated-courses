<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Pointers & Memory | Go From Python</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=20260125">
</head>
<body>
    <div class="container">
        <nav>
            <a href="module1.html">â† Module 1</a>
            <a href="module3.html">Module 3 â†’</a>
        </nav>

        <div class="module-header">
            <div class="module-tag">// MODULE 02</div>
            <h1>Pointers & Memory</h1>
            <p class="module-desc">Pointers demystified. They're not scary â€” they're just addresses. Let's make them click.</p>
        </div>

        <!-- Lesson 1: What's a Pointer -->
        <div class="lesson">
            <h2>What Even Is a Pointer?</h2>
            
            <p>In Python, you never think about this. In Go, you sometimes do. Here's the deal:</p>

            <p>A <strong>pointer</strong> is just a variable that holds a <strong>memory address</strong> instead of a direct value.</p>

            <div class="visual-box">
                <p style="color: var(--text-dim); margin-bottom: 1rem;">// Visual representation</p>
                <p>Regular variable:</p>
                <p style="color: var(--green-bright);">   x := 42</p>
                <p style="color: var(--text-dim);">   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
                <p style="color: var(--text-dim);">   â”‚   42    â”‚  â† x holds the value directly</p>
                <p style="color: var(--text-dim);">   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
                <br>
                <p>Pointer variable:</p>
                <p style="color: var(--green-bright);">   p := &x</p>
                <p style="color: var(--text-dim);">   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”</p>
                <p style="color: var(--text-dim);">   â”‚ 0xc0001 â”‚ â”€â”€â†’  â”‚   42    â”‚  â† p holds address, points to value</p>
                <p style="color: var(--text-dim);">   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
                <p style="color: var(--text-dim);">       p               x</p>
            </div>

            <h3>The Two Operators</h3>
            <div class="code-block">
                <div class="code-header go">Pointer operators</div>
                <pre>x := <span class="number">42</span>

<span class="comment">// & = "address of" â€” get the memory address</span>
p := &x        <span class="comment">// p is now a pointer to x</span>
fmt.<span class="func">Println</span>(p)  <span class="comment">// 0xc0000b4008 (some memory address)</span>

<span class="comment">// * = "dereference" â€” get the value at address</span>
fmt.<span class="func">Println</span>(*p) <span class="comment">// 42 (the actual value)</span>

<span class="comment">// Modify through pointer</span>
*p = <span class="number">100</span>
fmt.<span class="func">Println</span>(x)  <span class="comment">// 100 â€” x changed!</span></pre>
            </div>

            <div class="tip">
                <div class="tip-title">Memory Trick</div>
                <p><span class="inline-code">&</span> = "get <strong>A</strong>ddress" (& looks like 'A')<br>
                <span class="inline-code">*</span> = "get value" (go <strong>*</strong>through the pointer)</p>
            </div>
        </div>

        <!-- Lesson 2: Python Comparison -->
        <div class="lesson">
            <h2>How Python Handles This</h2>
            
            <p>Python has pointers too â€” you just can't see them. Everything in Python is a reference.</p>

            <div class="code-compare">
                <div class="code-block" style="margin: 0;">
                    <div class="code-header python">Python (hidden references)</div>
                    <pre><span class="comment"># Lists are mutable, passed by ref</span>
<span class="keyword">def</span> <span class="func">modify</span>(lst):
    lst.append(<span class="number">4</span>)

my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
modify(my_list)
<span class="func">print</span>(my_list)  <span class="comment"># [1, 2, 3, 4] changed!</span>

<span class="comment"># Ints are immutable</span>
<span class="keyword">def</span> <span class="func">modify_int</span>(x):
    x = <span class="number">100</span>

n = <span class="number">42</span>
modify_int(n)
<span class="func">print</span>(n)  <span class="comment"># 42 unchanged</span></pre>
                </div>
                <div class="code-block" style="margin: 0;">
                    <div class="code-header go">Go (explicit choice)</div>
                    <pre><span class="comment">// Slices work like Python lists</span>
<span class="keyword">func</span> <span class="func">modify</span>(s []<span class="type">int</span>) {
    s[<span class="number">0</span>] = <span class="number">999</span>  <span class="comment">// Modifies original</span>
}

<span class="comment">// Ints: pass by value (copy)</span>
<span class="keyword">func</span> <span class="func">modifyInt</span>(x <span class="type">int</span>) {
    x = <span class="number">100</span>  <span class="comment">// Only changes copy</span>
}

<span class="comment">// Ints: pass by pointer (reference)</span>
<span class="keyword">func</span> <span class="func">modifyIntPtr</span>(x *<span class="type">int</span>) {
    *x = <span class="number">100</span>  <span class="comment">// Changes original!</span>
}

n := <span class="number">42</span>
<span class="func">modifyIntPtr</span>(&n)  <span class="comment">// Pass address</span>
fmt.<span class="func">Println</span>(n)     <span class="comment">// 100</span></pre>
                </div>
            </div>

            <p><strong>The difference:</strong> Go makes you choose explicitly. Python hides the decision based on mutability.</p>
        </div>

        <!-- Lesson 3: When to Use Pointers -->
        <div class="lesson">
            <h2>When to Use Pointers</h2>
            
            <h3>Use Pointers When:</h3>
            <ol>
                <li><strong>You need to modify the original:</strong> Functions receive copies by default</li>
                <li><strong>The data is large:</strong> Copying big structs is slow; pass a pointer instead</li>
                <li><strong>You need to express "nothing":</strong> Pointers can be <span class="inline-code">nil</span></li>
                <li><strong>Consistency:</strong> If some methods need pointers, make all methods use pointers</li>
            </ol>

            <h3>Don't Use Pointers When:</h3>
            <ol>
                <li><strong>Data is small:</strong> <span class="inline-code">int</span>, <span class="inline-code">bool</span>, small structs â€” copying is fine</li>
                <li><strong>You want immutability:</strong> Pass by value guarantees the original won't change</li>
                <li><strong>Slices, maps, channels:</strong> Already reference types (sort of)</li>
            </ol>

            <div class="code-block">
                <div class="code-header go">Practical examples</div>
                <pre><span class="comment">// âŒ Unnecessary pointer â€” int is tiny</span>
<span class="keyword">func</span> <span class="func">double</span>(x *<span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> *x * <span class="number">2</span>
}

<span class="comment">// âœ“ Just take the value</span>
<span class="keyword">func</span> <span class="func">double</span>(x <span class="type">int</span>) <span class="type">int</span> {
    <span class="keyword">return</span> x * <span class="number">2</span>
}

<span class="comment">// âœ“ Pointer needed â€” modifying a struct</span>
<span class="keyword">func</span> (u *<span class="type">User</span>) <span class="func">UpdateEmail</span>(email <span class="type">string</span>) {
    u.Email = email
}

<span class="comment">// âœ“ Pointer useful â€” large struct</span>
<span class="keyword">type</span> <span class="type">BigData</span> <span class="keyword">struct</span> {
    Items [<span class="number">10000</span>]<span class="type">int</span>
}
<span class="keyword">func</span> <span class="func">process</span>(d *<span class="type">BigData</span>) { <span class="comment">/* ... */</span> }</pre>
            </div>
        </div>

        <!-- Lesson 4: nil Pointers -->
        <div class="lesson">
            <h2>nil: The Absence of a Value</h2>
            
            <p>A pointer that points to nothing is <span class="inline-code">nil</span>. It's Go's equivalent of Python's <span class="inline-code">None</span> for pointers.</p>

            <div class="code-block">
                <div class="code-header go">nil pointers</div>
                <pre><span class="keyword">var</span> p *<span class="type">int</span>           <span class="comment">// Declared but not initialized</span>
fmt.<span class="func">Println</span>(p)       <span class="comment">// &lt;nil&gt;</span>
fmt.<span class="func">Println</span>(p == <span class="keyword">nil</span>) <span class="comment">// true</span>

<span class="comment">// DANGER: Dereferencing nil crashes!</span>
<span class="comment">// fmt.Println(*p)  // panic: runtime error</span>

<span class="comment">// Always check for nil</span>
<span class="keyword">if</span> p != <span class="keyword">nil</span> {
    fmt.<span class="func">Println</span>(*p)
}</pre>
            </div>

            <h3>Using nil for "Optional" Values</h3>
            <div class="code-block">
                <div class="code-header go">nil as optional</div>
                <pre><span class="keyword">type</span> <span class="type">Config</span> <span class="keyword">struct</span> {
    Timeout *time.Duration  <span class="comment">// nil = use default</span>
    MaxSize *<span class="type">int</span>             <span class="comment">// nil = unlimited</span>
}

<span class="keyword">func</span> <span class="func">NewServer</span>(cfg <span class="type">Config</span>) *<span class="type">Server</span> {
    timeout := <span class="number">30</span> * time.Second  <span class="comment">// default</span>
    <span class="keyword">if</span> cfg.Timeout != <span class="keyword">nil</span> {
        timeout = *cfg.Timeout
    }
    <span class="comment">// ...</span>
}

<span class="comment">// Usage</span>
customTimeout := <span class="number">60</span> * time.Second
<span class="func">NewServer</span>(<span class="type">Config</span>{Timeout: &customTimeout})
<span class="func">NewServer</span>(<span class="type">Config</span>{})  <span class="comment">// Uses defaults</span></pre>
            </div>

            <div class="warning">
                <div class="warning-title">nil Panic</div>
                <p>Dereferencing a nil pointer causes a panic (crash). Always check <span class="inline-code">!= nil</span> before using <span class="inline-code">*p</span>.</p>
            </div>
        </div>

        <!-- Lesson 5: Pointer Receivers -->
        <div class="lesson">
            <h2>Pointer Receivers on Methods</h2>
            
            <p>This is where pointers matter most in day-to-day Go.</p>

            <div class="code-block">
                <div class="code-header go">Value vs Pointer receivers</div>
                <pre><span class="keyword">type</span> <span class="type">Counter</span> <span class="keyword">struct</span> {
    count <span class="type">int</span>
}

<span class="comment">// Value receiver: gets a COPY</span>
<span class="keyword">func</span> (c <span class="type">Counter</span>) <span class="func">IncrementBroken</span>() {
    c.count++  <span class="comment">// Increments the copy, not original!</span>
}

<span class="comment">// Pointer receiver: gets the original</span>
<span class="keyword">func</span> (c *<span class="type">Counter</span>) <span class="func">Increment</span>() {
    c.count++  <span class="comment">// Actually increments</span>
}

<span class="keyword">func</span> <span class="func">main</span>() {
    c := <span class="type">Counter</span>{}
    
    c.<span class="func">IncrementBroken</span>()
    fmt.<span class="func">Println</span>(c.count)  <span class="comment">// 0 â€” didn't work!</span>
    
    c.<span class="func">Increment</span>()
    fmt.<span class="func">Println</span>(c.count)  <span class="comment">// 1 â€” works!</span>
}</pre>
            </div>

            <h3>The Rule of Thumb</h3>
            <ul>
                <li>If <strong>any</strong> method needs a pointer receiver, make <strong>all</strong> methods use pointer receivers</li>
                <li>Pointer receivers for: mutation, large structs, consistency</li>
                <li>Value receivers for: small immutable types, when you want a copy</li>
            </ul>

            <div class="tip">
                <div class="tip-title">Go Does Some Magic</div>
                <p>You can call pointer methods on values and vice versa â€” Go automatically converts. But be consistent anyway.</p>
            </div>
        </div>

        <!-- Lesson 6: new() and make() -->
        <div class="lesson">
            <h2>Creating Pointers: new() and &</h2>
            
            <div class="code-block">
                <div class="code-header go">Different ways to create pointers</div>
                <pre><span class="comment">// Method 1: & operator (most common)</span>
x := <span class="number">42</span>
p := &x

<span class="comment">// Method 2: new() â€” allocates zeroed memory, returns pointer</span>
p := <span class="keyword">new</span>(<span class="type">int</span>)      <span class="comment">// *int pointing to 0</span>
*p = <span class="number">42</span>

<span class="comment">// Method 3: For structs, use & with literal</span>
user := &<span class="type">User</span>{Name: <span class="string">"Alice"</span>}  <span class="comment">// Returns *User</span>

<span class="comment">// Equivalent to:</span>
user := <span class="keyword">new</span>(<span class="type">User</span>)
user.Name = <span class="string">"Alice"</span></pre>
            </div>

            <h3>new() vs make()</h3>
            <div class="code-block">
                <div class="code-header go">new vs make</div>
                <pre><span class="comment">// new() â€” for any type, returns pointer to zero value</span>
p := <span class="keyword">new</span>(<span class="type">int</span>)        <span class="comment">// *int â†’ 0</span>
s := <span class="keyword">new</span>([]<span class="type">int</span>)      <span class="comment">// *[]int â†’ nil slice (not useful!)</span>

<span class="comment">// make() â€” ONLY for slices, maps, channels</span>
<span class="comment">// Returns initialized (not pointer!) value</span>
slice := <span class="keyword">make</span>([]<span class="type">int</span>, <span class="number">10</span>)        <span class="comment">// []int with len=10</span>
m := <span class="keyword">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)       <span class="comment">// Initialized map</span>
ch := <span class="keyword">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)         <span class="comment">// Buffered channel</span></pre>
            </div>

            <div class="tip">
                <div class="tip-title">Rule</div>
                <p><span class="inline-code">new()</span> = zero value + pointer. <span class="inline-code">make()</span> = initialized slice/map/channel (no pointer).</p>
            </div>
        </div>

        <!-- Lesson 7: Common Mistakes -->
        <div class="lesson">
            <h2>Common Pointer Mistakes</h2>
            
            <h3>Mistake 1: Returning Address of Local Variable... is Fine!</h3>
            <div class="code-block">
                <div class="code-header go">This is actually okay in Go</div>
                <pre><span class="keyword">func</span> <span class="func">newUser</span>() *<span class="type">User</span> {
    u := <span class="type">User</span>{Name: <span class="string">"Alice"</span|}
    <span class="keyword">return</span> &u  <span class="comment">// Fine! Go moves u to heap</span>
}
<span class="comment">// In C this would be a bug. Go's escape analysis handles it.</span></pre>
            </div>

            <h3>Mistake 2: Modifying Loop Variable</h3>
            <div class="code-block">
                <div class="code-header go">Loop variable trap</div>
                <pre>users := []<span class="type">User</span>{{Name: <span class="string">"A"</span>}, {Name: <span class="string">"B"</span>}, {Name: <span class="string">"C"</span>}}
<span class="keyword">var</span> ptrs []*<span class="type">User</span>

<span class="comment">// âŒ WRONG: All pointers point to same address!</span>
<span class="keyword">for</span> _, u := <span class="keyword">range</span> users {
    ptrs = <span class="func">append</span>(ptrs, &u)  <span class="comment">// &u is same address each iteration</span>
}
<span class="comment">// All ptrs[i] point to "C"!</span>

<span class="comment">// âœ“ CORRECT: Use index</span>
<span class="keyword">for</span> i := <span class="keyword">range</span> users {
    ptrs = <span class="func">append</span>(ptrs, &users[i])
}

<span class="comment">// âœ“ OR in Go 1.22+: loop var is new each iteration</span></pre>
            </div>

            <h3>Mistake 3: Forgetting nil Check</h3>
            <div class="code-block">
                <div class="code-header go">Nil checks</div>
                <pre><span class="keyword">func</span> <span class="func">process</span>(u *<span class="type">User</span>) {
    <span class="comment">// âŒ Crashes if u is nil</span>
    fmt.<span class="func">Println</span>(u.Name)
    
    <span class="comment">// âœ“ Check first</span>
    <span class="keyword">if</span> u == <span class="keyword">nil</span> {
        <span class="keyword">return</span>
    }
    fmt.<span class="func">Println</span>(u.Name)
}</pre>
            </div>
        </div>

        <!-- Summary -->
        <div class="lesson">
            <h2>Exercises</h2>
            
            <h3 style="color: var(--green-bright); margin-top: 1.5rem;">ğŸ”¥ Warmups</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Practice pointer basics before combining concepts.</p>
            
            <div class="exercise">
                <h4>Warmup 1: Get an Address</h4>
                <p>Create an integer variable, get its address using <code>&</code>, and print both the value and the address.</p>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>x := 42
ptr := &x
fmt.Println("Value:", x)
fmt.Println("Address:", ptr)</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 2: Modify Through Pointer</h4>
                <p>Create a variable, get a pointer to it, then change the value using <code>*ptr = newValue</code>. Print before and after.</p>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>x := 10
fmt.Println("Before:", x)
ptr := &x
*ptr = 50
fmt.Println("After:", x)  // 50</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 3: Function with Pointer Parameter</h4>
                <p>Write <code>func double(n *int)</code> that doubles the value at the pointer.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Dereference the pointer to get and set the value: <code>*n = *n * 2</code>
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func double(n *int) {
    *n = *n * 2
}

// Test:
x := 5
double(&x)
fmt.Println(x)  // 10</pre>
                    </div>
                </details>
            </div>

            <div class="exercise">
                <h4>Warmup 4: Check for nil</h4>
                <p>Write a function <code>func printValue(p *int)</code> that prints the value if p is not nil, or prints "pointer is nil" if it is.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Check <code>if p != nil</code> before dereferencing.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func printValue(p *int) {
    if p != nil {
        fmt.Println("Value:", *p)
    } else {
        fmt.Println("pointer is nil")
    }
}</pre>
                    </div>
                </details>
            </div>

            <h3 style="color: var(--orange); margin-top: 2rem;">ğŸ’ª Challenges</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Combine pointer concepts with structs and methods.</p>
            
            <div class="exercise">
                <h4>Challenge 1: Swap</h4>
                <p>Write a function <code>func swap(a, b *int)</code> that swaps two integers using pointers.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Dereference both pointers, swap the values. Use parallel assignment: <code>*a, *b = *b, *a</code>
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func swap(a, b *int) {
    *a, *b = *b, *a
}

// Usage:
x, y := 10, 20
swap(&x, &y)
fmt.Println(x, y) // 20 10</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>x, y := 5, 10
swap(&x, &y)
// x = 10, y = 5</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 2: Counter Struct</h4>
                <p>Create a <code>Counter</code> struct with an <code>int</code> value. Add methods <code>Increment()</code>, <code>Decrement()</code>, and <code>Value() int</code>.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        <code>Increment</code> and <code>Decrement</code> need pointer receivers to modify the struct. <code>Value</code> can use value receiver.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>type Counter struct {
    value int
}

func (c *Counter) Increment() {
    c.value++
}

func (c *Counter) Decrement() {
    c.value--
}

func (c *Counter) Value() int {
    return c.value
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>c := Counter{}
c.Increment()
c.Increment()
c.Decrement()
fmt.Println(c.Value()) // 1</pre>
                </div>
            </div>

            <div class="exercise">
                <h4>Challenge 3: Safe Dereference</h4>
                <p>Write <code>func safeDeref(p *string) string</code> that returns the string value if p is not nil, or <code>"&lt;nil&gt;"</code> if it is.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Check <code>p == nil</code> before dereferencing. Return the fallback string if nil.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>func safeDeref(p *string) string {
    if p == nil {
        return "<nil>"
    }
    return *p
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>s := "hello"
fmt.Println(safeDeref(&s))  // "hello"
fmt.Println(safeDeref(nil)) // "<nil>"</pre>
                </div>
            </div>

            <h3 style="color: var(--purple); margin-top: 2rem;">ğŸš€ Advanced (Optional)</h3>
            <p style="color: var(--text-dim); font-size: 0.9rem; margin-bottom: 1rem;">Data structures using pointers. Only attempt after completing warmups and challenges.</p>

            <div class="exercise">
                <h4>Advanced: Linked List Node</h4>
                <p>Define a <code>Node</code> struct with <code>Value int</code> and <code>Next *Node</code>. Write functions to build a list from a slice and traverse it.</p>
                
                <details>
                    <summary>ğŸ’¡ Hint</summary>
                    <div class="hint-content">
                        Build in reverse: start from the last element, create node, link to previous. Traverse with <code>for node != nil</code>.
                    </div>
                </details>
                
                <details>
                    <summary>âœ… Solution</summary>
                    <div class="hint-content">
<pre>type Node struct {
    Value int
    Next  *Node
}

func buildList(values []int) *Node {
    var head *Node
    for i := len(values) - 1; i >= 0; i-- {
        head = &Node{Value: values[i], Next: head}
    }
    return head
}

func traverse(head *Node) {
    for node := head; node != nil; node = node.Next {
        fmt.Println(node.Value)
    }
}</pre>
                    </div>
                </details>
                
                <div class="expected">
                    <div class="expected-title">Expected Output</div>
                    <pre>list := buildList([]int{1, 2, 3})
traverse(list)
// 1
// 2
// 3</pre>
                </div>
            </div>
            
            <div class="tip">
                <div class="tip-title">Practice Strategy</div>
                <p>Do warmups first to get comfortable with pointer syntax. Then tackle challenges that combine pointers with other concepts. Save the advanced exercise for when you're confident with the basics!</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Module 2 Summary</h2>
            <ul>
                <li><strong>&</strong> gets the address, <strong>*</strong> dereferences (gets value)</li>
                <li><strong>Use pointers</strong> to modify originals or avoid copying large data</li>
                <li><strong>nil</strong> = pointer to nothing â€” always check before dereferencing</li>
                <li><strong>Pointer receivers</strong> let methods modify structs</li>
                <li><strong>new()</strong> = zero value pointer, <strong>make()</strong> = initialized slice/map/channel</li>
                <li><strong>Go handles memory</strong> â€” you don't free things manually</li>
            </ul>

            <div class="tip">
                <div class="tip-title">The Mantra</div>
                <p>When in doubt, start without pointers. Add them when you need mutation or have large data.</p>
            </div>
        </div>

        <div class="nav-buttons">
            <a href="module1.html" class="nav-btn">â† Module 1</a>
            <a href="module3.html" class="nav-btn primary">Module 3: Structs â†’</a>
        </div>
    </div>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 13: Project Structure | Go From Python</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="gamification.css">
</head>
<body>
    <div class="container">
        <nav><a href="module12.html">← Module 12</a><a href="module14.html">Module 14 →</a></nav>
        <div class="module-tag">// MODULE 13</div>
        <h1>Project Structure</h1>
        <p class="module-desc">How Go projects grow from one file to many. Packages, visibility, and organization.</p>

        <div class="lesson">
            <h2>Same Package, Multiple Files</h2>
            <p>This is the first thing that confuses people from Python. In Go, all files in the same directory with the same <span class="inline-code">package</span> declaration are ONE unit. They share everything automatically.</p>
            
            <div class="code-block">
                <div class="code-header file">main.go</div>
                <pre><span class="keyword">package</span> main

<span class="keyword">func</span> <span class="func">main</span>() {
    cfg := <span class="func">LoadConfig</span>()  <span class="comment">// Defined in config.go</span>
    <span class="func">Process</span>(cfg)         <span class="comment">// Defined in process.go</span>
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header file">config.go</div>
                <pre><span class="keyword">package</span> main

<span class="keyword">type</span> <span class="type">Config</span> <span class="keyword">struct</span> {
    Name <span class="type">string</span>
}

<span class="keyword">func</span> <span class="func">LoadConfig</span>() *<span class="type">Config</span> {
    <span class="keyword">return</span> &<span class="type">Config</span>{Name: <span class="string">"test"</span>}
}</pre>
            </div>
            <div class="code-block">
                <div class="code-header file">process.go</div>
                <pre><span class="keyword">package</span> main

<span class="keyword">func</span> <span class="func">Process</span>(cfg *<span class="type">Config</span>) {  <span class="comment">// Can use Config from config.go</span>
    fmt.<span class="func">Println</span>(cfg.Name)
}</pre>
            </div>
            
            <p>No imports between them. They just... work together. The compiler sees them as one blob.</p>
            
            <div class="code-block">
                <div class="code-header terminal">Running it</div>
                <pre><span class="comment"># Compiles ALL .go files in current directory</span>
$ go run .

<span class="comment"># Or explicitly</span>
$ go run main.go config.go process.go</pre>
            </div>
        </div>

        <div class="lesson">
            <h2>When to Split Files</h2>
            <p>There's no hard rule, but here's what works:</p>
            <ul>
                <li><strong>By type</strong> — one file per major struct/type and its methods</li>
                <li><strong>By responsibility</strong> — config stuff in config.go, HTTP stuff in http.go</li>
                <li><strong>When it gets long</strong> — if you're scrolling forever, split it</li>
            </ul>
            <p>Don't over-split. A 200-line file is fine. Ten 20-line files is annoying.</p>
        </div>

        <div class="lesson">
            <h2>Packages = Directories</h2>
            <p>When your project gets bigger, you'll want separate packages. Each directory is a package.</p>
            
            <div class="code-block">
                <div class="code-header">Directory structure</div>
                <pre>myproject/
├── go.mod              <span class="comment"># module github.com/you/myproject</span>
├── main.go             <span class="comment"># package main</span>
└── stuff/
    └── stuff.go        <span class="comment"># package stuff</span></pre>
            </div>
            
            <div class="code-block">
                <div class="code-header file">stuff/stuff.go</div>
                <pre><span class="keyword">package</span> stuff

<span class="keyword">func</span> <span class="func">DoThing</span>() <span class="type">string</span> {
    <span class="keyword">return</span> <span class="string">"did the thing"</span>
}</pre>
            </div>
            
            <div class="code-block">
                <div class="code-header file">main.go</div>
                <pre><span class="keyword">package</span> main

<span class="keyword">import</span> <span class="string">"github.com/you/myproject/stuff"</span>

<span class="keyword">func</span> <span class="func">main</span>() {
    result := stuff.<span class="func">DoThing</span>()
    fmt.<span class="func">Println</span>(result)
}</pre>
            </div>
            
            <div class="warning">
                <div class="warning-title">Import Path</div>
                <p>The import path is your module name (from go.mod) + the directory path. Not the file path. Not the package name. The directory.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Uppercase = Exported (Public)</h2>
            <p>This is Go's visibility system. Dead simple once you get it.</p>
            
            <div class="code-block">
                <div class="code-header">Visibility rules</div>
                <pre><span class="keyword">package</span> stuff

<span class="comment">// Exported — visible outside this package</span>
<span class="keyword">func</span> <span class="func">PublicFunc</span>() {}      <span class="comment">// ✓ Uppercase first letter</span>
<span class="keyword">type</span> <span class="type">PublicType</span> <span class="keyword">struct</span>{} <span class="comment">// ✓</span>
<span class="keyword">var</span> PublicVar = <span class="number">42</span>       <span class="comment">// ✓</span>

<span class="comment">// Unexported — only visible inside this package</span>
<span class="keyword">func</span> <span class="func">privateFunc</span>() {}     <span class="comment">// ✗ Lowercase first letter</span>
<span class="keyword">type</span> <span class="type">privateType</span> <span class="keyword">struct</span>{} <span class="comment">// ✗</span>
<span class="keyword">var</span> privateVar = <span class="number">42</span>      <span class="comment">// ✗</span></pre>
            </div>
            
            <p>From another package, you can only access the uppercase stuff:</p>
            
            <div class="code-block">
                <div class="code-header file">main.go</div>
                <pre><span class="keyword">import</span> <span class="string">"github.com/you/myproject/stuff"</span>

stuff.<span class="func">PublicFunc</span>()   <span class="comment">// ✓ Works</span>
stuff.<span class="func">privateFunc</span>()  <span class="comment">// ✗ Compile error</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>The internal/ Directory</h2>
            <p>Go has one magic directory name: <span class="inline-code">internal/</span></p>
            <p>Code inside <span class="inline-code">internal/</span> can only be imported by code in the parent directory tree. The compiler enforces this.</p>
            
            <div class="code-block">
                <div class="code-header">internal/ example</div>
                <pre>myproject/
├── go.mod
├── main.go                 <span class="comment"># Can import internal/secret</span>
├── cmd/
│   └── tool/
│       └── main.go         <span class="comment"># Can import internal/secret</span>
└── internal/
    └── secret/
        └── secret.go       <span class="comment"># package secret</span></pre>
            </div>
            
            <p>If someone else imports your module, they <strong>cannot</strong> import anything from your internal/ directory. Compiler stops them.</p>
            
            <div class="tip">
                <div class="tip-title">When to use internal/</div>
                <p>Put implementation details you don't want to be part of your public API. You can refactor internal code freely without breaking anyone.</p>
            </div>
        </div>

        <div class="lesson">
            <h2>Common Project Layouts</h2>
            
            <h3>Small CLI tool</h3>
            <div class="code-block">
                <div class="code-header">Simple layout</div>
                <pre>mytool/
├── go.mod
├── main.go         <span class="comment"># Everything in one package</span>
├── config.go
└── commands.go</pre>
            </div>
            
            <h3>Medium project</h3>
            <div class="code-block">
                <div class="code-header">With packages</div>
                <pre>mytool/
├── go.mod
├── main.go
├── cmd/            <span class="comment"># CLI command definitions</span>
│   ├── root.go
│   └── serve.go
└── internal/       <span class="comment"># Private implementation</span>
    ├── config/
    └── server/</pre>
            </div>
            
            <h3>Library + CLI</h3>
            <div class="code-block">
                <div class="code-header">Dual-purpose</div>
                <pre>mylib/
├── go.mod
├── mylib.go        <span class="comment"># Public library API (package mylib)</span>
├── cmd/
│   └── mylib/
│       └── main.go <span class="comment"># CLI that uses the library</span>
└── internal/       <span class="comment"># Shared private code</span></pre>
            </div>
        </div>

        <div class="lesson">
            <h2>Circular Import = Compile Error</h2>
            <p>Go doesn't allow circular imports. If package A imports B, B cannot import A.</p>
            
            <div class="code-block">
                <div class="code-header">This won't compile</div>
                <pre><span class="comment">// a/a.go</span>
<span class="keyword">package</span> a
<span class="keyword">import</span> <span class="string">"myproject/b"</span>  <span class="comment">// A imports B</span>

<span class="comment">// b/b.go</span>
<span class="keyword">package</span> b
<span class="keyword">import</span> <span class="string">"myproject/a"</span>  <span class="comment">// B imports A — ERROR!</span></pre>
            </div>
            
            <p><strong>Solutions:</strong></p>
            <ul>
                <li>Merge the packages if they're that intertwined</li>
                <li>Extract shared types into a third package both can import</li>
                <li>Use interfaces to break the dependency</li>
            </ul>
        </div>

        <div class="lesson">
            <h2>Module 13 Summary</h2>
            <ul>
                <li><strong>Same package, multiple files</strong> — share everything, no imports needed</li>
                <li><strong>Package = directory</strong> — import path is module + directory</li>
                <li><strong>Uppercase = exported</strong> — visible outside package</li>
                <li><strong>internal/</strong> — compiler-enforced private packages</li>
                <li><strong>No circular imports</strong> — design around it</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="module12.html" class="nav-btn">← Module 12</a>
            <a href="module14.html" class="nav-btn primary">Module 14: System Interaction →</a>
        </div>
    </div>
    <script src="theme.js"></script>
    <script src="sidebar.js"></script>
    <script src="gamification.js"></script>
</body>
</html>

{
  "conceptLinks": {
    "For Loops": "#lesson-loops",
    "If/Else": "#lesson-if",
    "Slices & Range": "#lesson-slices",
    "Maps": "#lesson-maps",
    "make() Function": "#lesson-slices",
    "Comma-Ok Pattern": "#lesson-comma-ok",
    "Range with Index": "#lesson-loops",
    "Building Slices": "#lesson-slices",
    "Recursion": "#lesson-loops",
    "Strings": "#lesson-slices",
    "Switch": "#lesson-if",
    "Binary Search": "#lesson-slices",
    "Stack Pattern": "#lesson-slices",
    "String Building": "#lesson-slices"
  },
  "sharedContent": {
    "advanced_1": {
      "preReading": {
        "title": "üìñ Pre-reading: The \"Have I Seen This?\" Pattern",
        "content": "<strong>The Problem:</strong> How do you know if you've seen something before?<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                For each element, check every other element to see if it matches ‚Üí O(n¬≤)<br>\n                For 1000 elements, that's 1,000,000 comparisons! üêå<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Use a map to remember what you've seen ‚Üí O(n)<br>\n                For 1000 elements, that's just 1000 operations! üöÄ<br><br>\n                <strong>The Pattern:</strong><br>\n                1. Create an empty map to track what you've seen<br>\n                2. For each element, check: \"Have I seen this before?\"<br>\n                3. If yes ‚Üí found a duplicate!<br>\n                4. If no ‚Üí remember it and continue"
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "As you go through the elements, how would you remember which ones you've already seen? What data structure gives you fast lookup to check \"have I seen this before?\""
        },
        {
          "title": "üí° Hint",
          "content": "Use a map as your \"memory\" - the key is the element, and you just need to know it exists (what simple type represents yes/no?). For each element: first check if it's in your memory, then add it if not. If you make it through all elements without finding a duplicate, they must all be unique."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already in tracker? ‚Üí found duplicate!\n   - Not seen? ‚Üí add to tracker\n3. Finished loop? ‚Üí all unique</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "comprehensive guide to maps"
        },
        {
          "url": "https://go.dev/ref/spec#Map_types",
          "title": "Go Spec: Map types",
          "note": "official language specification"
        },
        {
          "url": "https://go.dev/ref/spec#Making_slices_maps_and_channels",
          "title": "Go Spec: make()",
          "note": "how make() initializes maps"
        }
      ]
    },
    "advanced_2": {
      "preReading": {
        "title": "üìñ Pre-reading: The Slow/Fast Pointer Pattern",
        "content": "<strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>\n                <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>\n                <strong>The Slow/Fast Pattern:</strong><br>\n                ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>\n                ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>\n                ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>\n                <strong>Code structure pattern:</strong><br>\n<pre>slow := 0  // Initialize OUTSIDE loop (write position)\n\nfor fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)\n    // Compare items[fast] with items[slow]\n    // If different: move slow, write value\n    // If same: do nothing\n    // fast moves automatically every iteration\n}</pre>"
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "If the array is already sorted, where will duplicates be? If you're keeping track of the 'last unique' position, what do you do when you find a new unique value?"
        },
        {
          "title": "üí° Hint",
          "content": "Use two pointers: 'slow' marks where to write the next unique value, 'fast' scans ahead. When fast finds something different from what slow points to, you've found a new unique value - increment slow and copy it there."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. slow = first position (write pointer)\n2. fast scans from second position (read pointer)\n3. For each fast position:\n   - Different from slow? ‚Üí advance slow, copy value\n   - Same? ‚Üí skip (fast moves on)\n4. Return slow + 1 (new length)</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#For_statements",
          "title": "Go Spec: For statements",
          "note": "loop syntax and semantics"
        },
        {
          "url": "https://go.dev/ref/spec#Slice_types",
          "title": "Go Spec: Slice types",
          "note": "understanding slices"
        },
        {
          "url": "https://go.dev/blog/slices-intro",
          "title": "Go Blog: Arrays, slices, and strings",
          "note": "in-depth slice mechanics"
        }
      ]
    },
    "advanced_3": {
      "preReading": {
        "title": "üìñ Pre-reading: Strings vs Runes in Go",
        "content": "<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence of <strong>bytes</strong>, not characters!<br><br>\n                For ASCII (a-z, 0-9), one character = one byte. Easy!<br>\n                But for Unicode (emoji üéâ, Chinese ‰∏ñÁïå, etc.), one character can be 2-4 bytes.<br><br>\n                <strong>Example:</strong><br>\n                <code>\"Hello\"</code> = 5 bytes = 5 characters √¢¬ú¬Ö<br>\n                <code>\"‰∏ñÁïå\"</code> = 6 bytes but only 2 characters! √¢¬ö¬†√Ø¬∏¬è<br>\n                <code>\"üéâ\"</code> = 4 bytes but only 1 character! √¢¬ö¬†√Ø¬∏¬è<br><br>\n                <strong>The Solution: Runes</strong><br>\n                A <code>rune</code> is Go's type for a Unicode character (actually an <code>int32</code>).<br>\n                Converting to <code>[]rune</code> splits the string into actual characters, not bytes."
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "Why can't you just index a string directly with [i]? What's special about strings in Go when dealing with non-ASCII characters?"
        },
        {
          "title": "üí° Hint",
          "content": "Convert to []rune to handle Unicode properly. Then use the two-pointer swap pattern you learned - swap from both ends working inward."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Convert string to character array (runes)\n2. Two pointers: left at start, right at end\n3. While left < right:\n   - Swap characters at left and right\n   - Move pointers inward\n4. Convert back to string</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/strings",
          "title": "Go Blog: Strings, bytes, runes and characters",
          "note": "essential reading for Go strings"
        },
        {
          "url": "https://go.dev/ref/spec#Rune_literals",
          "title": "Go Spec: Rune literals",
          "note": "what runes are"
        },
        {
          "url": "https://pkg.go.dev/unicode",
          "title": "Package unicode",
          "note": "unicode classification functions"
        }
      ]
    },
    "advanced_4": {
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "What's the pattern for counting things? What data structure lets you track 'how many of each thing' efficiently?"
        },
        {
          "title": "üí° Hint",
          "content": "First split the string into words (check the strings package for a function that splits on whitespace). Then use a map where keys are words and values are counts - what operation increases a map value?"
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Split string into words\n2. Create empty count tracker (map)\n3. For each word:\n   - Increment its count\n4. Return the counts</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://pkg.go.dev/strings",
          "title": "Package strings",
          "note": "Fields, Split, Join and more"
        },
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "map operations including increment"
        },
        {
          "url": "https://pkg.go.dev/fmt",
          "title": "Package fmt",
          "note": "printing maps and formatted output"
        }
      ]
    },
    "advanced_5": {
      "preReading": {
        "title": "üìñ Pre-reading: The Hash Map Complement Pattern",
        "content": "<strong>The Naive Approach (slow):</strong><br>\n                Check every pair of numbers - requires nested loops O(n¬≤)<br><br>\n                <strong>The Smart Approach (fast):</strong><br>\n                Use a map to remember what you've seen - only one loop O(n)<br><br>\n                <strong>The Key Insight:</strong><br>\n                If target = 9 and current number = 2, we need to find 7.<br>\n                Instead of searching the whole array for 7, just check: \"Have I seen 7 before?\"<br>\n                Maps make this lookup instant!"
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "For each number, what other number would you need to find to reach the target? Instead of searching the whole array for it, how could you instantly check if you've seen it?"
        },
        {
          "title": "üí° Hint",
          "content": "The complement is <code>target - current</code>. Use a map to remember numbers you've seen AND their indices (since you need to return indices). Check for the complement before adding the current number to your map."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Create tracker: number ‚Üí its index\n2. For each number at position i:\n   - Calculate: complement = target - number\n   - Complement in tracker? ‚Üí return [tracker[complement], i]\n   - Not found? ‚Üí add number:i to tracker</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/blog/maps",
          "title": "Go Blog: Go maps in action",
          "note": "storing values (indices) in maps"
        },
        {
          "url": "https://go.dev/ref/spec#Index_expressions",
          "title": "Go Spec: Index expressions",
          "note": "the comma-ok idiom for map access"
        },
        {
          "url": "https://pkg.go.dev/sort",
          "title": "Package sort",
          "note": "for sorted-input variants"
        }
      ]
    },
    "advanced_6": {
      "preReading": {
        "title": "üìñ Pre-reading: The Sliding Window Pattern",
        "content": "<strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                Check every possible subarray - O(n¬≤) or worse üêå<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Use a \"window\" that slides through the array - O(n) üöÄ<br><br>\n                <strong>Two Types of Sliding Windows:</strong><br>\n                <strong>1. Fixed-size window:</strong> Window size k stays constant<br>\n                ‚Ä¢ Add the new element entering on the right<br>\n                ‚Ä¢ Subtract the element leaving on the left<br><br>\n                <strong>2. Variable-size window:</strong> Window grows and shrinks<br>\n                ‚Ä¢ Expand (move right pointer) to include more elements<br>\n                ‚Ä¢ Shrink (move left pointer) when condition is violated or met"
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "If you've already calculated the sum for elements 0-3, do you really need to recalculate everything for elements 1-4? What operation can give you the new sum efficiently?"
        },
        {
          "title": "üí° Hint",
          "content": "For fixed windows: add the new element entering, subtract the element leaving. Think of it as the window 'sliding' right - one element comes in, one goes out. Track your max/min as you slide."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Calculate sum of first k elements\n2. Track this as current max\n3. Slide window: for each new position:\n   - Add new element (entering window)\n   - Subtract old element (leaving window)\n   - Update max if current sum is larger</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#For_statements",
          "title": "Go Spec: For statements",
          "note": "loop constructs"
        },
        {
          "url": "https://go.dev/blog/slices-intro",
          "title": "Go Blog: Slices introduction",
          "note": "slice indexing and sub-slicing"
        },
        {
          "url": "https://pkg.go.dev/builtin#len",
          "title": "Builtin len()",
          "note": "getting slice length"
        }
      ]
    },
    "advanced_7": {
      "preReading": {
        "title": "üìñ Pre-reading: The \"Best So Far\" Pattern",
        "content": "<strong>The Problem:</strong> Find the optimal result that depends on pairs of elements where order matters<br><br>\n                <strong>Example:</strong> Best Time to Buy/Sell Stock - you must buy BEFORE you sell<br><br>\n                <strong>Naive approach (slow):</strong><br>\n                Check every pair (i, j) where i < j - O(n¬≤) üêå<br><br>\n                <strong>Smart approach (fast):</strong><br>\n                Track the \"best so far\" as you scan - O(n) üöÄ<br><br>\n                <strong>The Pattern:</strong><br>\n                ‚Ä¢ Track the minimum (or maximum) seen so far<br>\n                ‚Ä¢ At each position, calculate the best result using that tracked value<br>\n                ‚Ä¢ Update your overall best if this result is better<br><br>\n                <strong>Key insight:</strong> You don't need to remember ALL previous values - just the one that matters (min or max)!"
      },
      "hints": [
        {
          "title": "ü§î Think about it",
          "content": "To maximize profit, you want to buy low and sell high. As you scan through prices, what single value from the past do you need to remember to calculate the best possible profit at each day?"
        },
        {
          "title": "üí° Hint",
          "content": "Track the minimum price seen so far. At each day, the best profit you could make is: today's price - minimum so far. Keep track of the maximum profit across all days."
        },
        {
          "title": "üîß Pattern",
          "content": "<pre>1. Initialize: minSoFar = first element, bestResult = 0\n2. For each element:\n   - Calculate result using minSoFar\n   - Update bestResult if this is better\n   - Update minSoFar if current element is smaller\n3. Return bestResult</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#Comparison_operators",
          "title": "Go Spec: Comparison operators",
          "note": "< > comparisons"
        },
        {
          "url": "https://go.dev/ref/spec#Arithmetic_operators",
          "title": "Go Spec: Arithmetic operators",
          "note": "subtraction for differences"
        },
        {
          "url": "https://go.dev/ref/spec#If_statements",
          "title": "Go Spec: If statements",
          "note": "conditional updates"
        }
      ]
    },
    "advanced_recursion": {
      "preReading": {
        "title": "√≠¬†¬Ω√≠¬≥¬ñ Pre-reading: The Recursion Pattern",
        "content": "<strong>The Core Idea:</strong> A function that calls itself to solve smaller sub-problems.<br><br>Think of recursion like infiltrating a Palace in the Metaverse ‚Äî you go deeper level by level, and you <strong>always need an escape route (base case)</strong> to get back out.<br><br><strong>Every recursive function needs two things:</strong><br>‚Ä¢ <strong>Base case:</strong> The simplest version of the problem (stop recursing!)<br>‚Ä¢ <strong>Recursive case:</strong> Break the problem down and call yourself with a smaller input<br><br><strong>Example pattern:</strong><br><pre>func solve(n int) int {\n    if n == 0 {          // base case - escape route!\n        return 0\n    }\n    return n + solve(n-1) // recursive case - go deeper\n}</pre><br><strong>Key insight:</strong> Trust that the recursive call works correctly for the smaller problem. Like trusting your Phantom Thief teammates ‚Äî focus on your part, trust the rest will handle theirs."
      },
      "hints": [
        {
          "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
          "content": "What is the simplest possible input where you already know the answer? That's your base case. For everything else, can you express the answer in terms of a slightly smaller version of the same problem?"
        },
        {
          "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
          "content": "Write the base case first (the 'escape route'). Then write the recursive case: call the same function with a smaller input and combine the result. Make sure every recursive call moves toward the base case!"
        },
        {
          "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
          "content": "<pre>1. Base case: simplest input ‚Üí return known answer\n2. Recursive case:\n   - Do one small piece of work\n   - Call yourself with smaller input\n   - Combine and return</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#Function_declarations",
          "title": "Go Spec: Function declarations",
          "note": "defining functions"
        },
        {
          "url": "https://go.dev/ref/spec#Calls",
          "title": "Go Spec: Calls",
          "note": "function call syntax"
        },
        {
          "url": "https://go.dev/ref/spec#If_statements",
          "title": "Go Spec: If statements",
          "note": "base case conditions"
        }
      ]
    },
    "advanced_binary_search": {
      "preReading": {
        "title": "√≠¬†¬Ω√≠¬≥¬ñ Pre-reading: Binary Search ‚Äî Halving the Search Space",
        "content": "<strong>The Problem:</strong> Find a target in a sorted collection<br><br>Imagine searching for a Shadow in Mementos. You could check every floor one by one (linear search, O(n)), or you could be smart: check the middle floor. Is the Shadow above or below? Now you've eliminated <strong>half</strong> the floors in one move!<br><br><strong>Linear search:</strong> Check every element ‚Üí O(n)<br><strong>Binary search:</strong> Halve the space each step ‚Üí O(log n)<br><br>For 1,000,000 elements: linear = 1,000,000 checks, binary = ~20 checks!<br><br><strong>The Pattern:</strong><br><pre>low, high := 0, len(items)-1\nfor low <= high {\n    mid := (low + high) / 2\n    if items[mid] == target {\n        return mid       // Found it!\n    } else if items[mid] < target {\n        low = mid + 1    // Search right half\n    } else {\n        high = mid - 1   // Search left half\n    }\n}\nreturn -1 // Not found</pre><br><strong>Requirement:</strong> The data MUST be sorted! Like a well-organized Phantom Thief filing system."
      },
      "hints": [
        {
          "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
          "content": "If the array is sorted and you check the middle element, what does comparing it to your target tell you about which half to search next?"
        },
        {
          "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
          "content": "Maintain two pointers: low and high. Calculate mid = (low + high) / 2. Compare the middle element to target: equal means found, less means search right half (low = mid+1), greater means search left half (high = mid-1)."
        },
        {
          "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
          "content": "<pre>1. Set low = 0, high = len-1\n2. While low <= high:\n   - mid = (low + high) / 2\n   - Found target? ‚Üí return mid\n   - Target larger? ‚Üí low = mid + 1\n   - Target smaller? ‚Üí high = mid - 1\n3. Return -1 (not found)</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#For_statements",
          "title": "Go Spec: For statements",
          "note": "while-style loops"
        },
        {
          "url": "https://go.dev/ref/spec#Comparison_operators",
          "title": "Go Spec: Comparison operators",
          "note": "comparing elements"
        },
        {
          "url": "https://pkg.go.dev/sort#SearchInts",
          "title": "Package sort: SearchInts",
          "note": "Go's built-in binary search"
        }
      ]
    },
    "advanced_stack": {
      "preReading": {
        "title": "√≠¬†¬Ω√≠¬≥¬ñ Pre-reading: The Stack Pattern (LIFO)",
        "content": "<strong>The Core Idea:</strong> Last In, First Out ‚Äî like a stack of calling cards<br><br>Picture the Phantom Thieves' calling cards stacked on a desk. The last card placed on top is the first one you pick up. That's a stack!<br><br><strong>In Go, use a slice as a stack:</strong><br>‚Ä¢ <strong>Push:</strong> <code>stack = append(stack, item)</code><br>‚Ä¢ <strong>Pop:</strong> <code>top = stack[len(stack)-1]; stack = stack[:len(stack)-1]</code><br>‚Ä¢ <strong>Peek:</strong> <code>stack[len(stack)-1]</code> (look without removing)<br>‚Ä¢ <strong>Empty?:</strong> <code>len(stack) == 0</code><br><br><strong>Common uses:</strong><br>‚Ä¢ Matching brackets/parentheses<br>‚Ä¢ Reversing things<br>‚Ä¢ Tracking nested structures<br>‚Ä¢ Undo operations<br><br><strong>Key insight:</strong> When you need to match things that nest (like parentheses), push opening symbols and pop when you find closing ones. If they match, you're golden!"
      },
      "hints": [
        {
          "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
          "content": "When you encounter an opening bracket, you need to remember it for later. When you encounter a closing bracket, you need to check the most recent opening bracket. What data structure handles 'most recent first'?"
        },
        {
          "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
          "content": "Use a slice as a stack: append to push, slice off the end to pop. For matching problems: push openers, pop and compare when you see closers. At the end, the stack should be empty if everything matched."
        },
        {
          "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
          "content": "<pre>1. Create empty stack (slice)\n2. For each element:\n   - Is it an 'opener'? ‚Üí push onto stack\n   - Is it a 'closer'? ‚Üí pop from stack, check match\n3. Stack empty at end? ‚Üí all matched!</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://go.dev/ref/spec#Appending_and_copying_slices",
          "title": "Go Spec: Appending slices",
          "note": "push with append"
        },
        {
          "url": "https://go.dev/ref/spec#Slice_expressions",
          "title": "Go Spec: Slice expressions",
          "note": "pop with re-slicing"
        },
        {
          "url": "https://go.dev/blog/slices-intro",
          "title": "Go Blog: Slices introduction",
          "note": "slice mechanics"
        }
      ]
    },
    "advanced_string_manipulation": {
      "preReading": {
        "title": "√≠¬†¬Ω√≠¬≥¬ñ Pre-reading: String Building Patterns in Go",
        "content": "<strong>Strings in Go are immutable</strong> ‚Äî every concatenation creates a new string!<br><br>Think of it like writing a calling card message. You can't erase and rewrite ‚Äî you have to write a whole new card each time you change something.<br><br><strong>Common patterns:</strong><br>‚Ä¢ <strong>Byte-by-byte building:</strong> Loop through characters, build result<br>‚Ä¢ <strong>strings.Builder:</strong> Efficient way to build strings piece by piece<br>‚Ä¢ <strong>[]byte conversion:</strong> Convert to mutable byte slice, modify, convert back<br><br><strong>Useful packages:</strong><br>‚Ä¢ <code>strings</code> ‚Äî Contains, Replace, Split, Join, ToUpper, ToLower, etc.<br>‚Ä¢ <code>unicode</code> ‚Äî IsLetter, IsDigit, IsUpper, IsLower, etc.<br>‚Ä¢ <code>strconv</code> ‚Äî Itoa (int to string), Atoi (string to int)<br><br><strong>Key insight:</strong> For simple cases, <code>result += char</code> is fine. For building long strings in loops, use <code>strings.Builder</code> for performance."
      },
      "hints": [
        {
          "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
          "content": "Do you need to examine each character individually? Consider whether you can use a function from the strings package, or if you need to iterate character by character."
        },
        {
          "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
          "content": "For character-level work: range over the string to get runes. Build results with string concatenation or strings.Builder. Check the strings and unicode packages for helper functions before writing everything from scratch."
        },
        {
          "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
          "content": "<pre>1. Choose approach:\n   - strings package function? (simplest)\n   - Loop through characters? (flexible)\n   - Convert to []byte/[]rune? (mutable)\n2. Process each character/word\n3. Build and return result</pre>"
        }
      ],
      "docLinks": [
        {
          "url": "https://pkg.go.dev/strings",
          "title": "Package strings",
          "note": "string manipulation functions"
        },
        {
          "url": "https://pkg.go.dev/unicode",
          "title": "Package unicode",
          "note": "character classification"
        },
        {
          "url": "https://go.dev/blog/strings",
          "title": "Go Blog: Strings, bytes, runes",
          "note": "essential reading"
        }
      ]
    }
  },
  "variants": {
    "warmups": [
      {
        "id": "warmup_1",
        "concept": "For Loops",
        "variants": [
          {
            "id": "v1",
            "title": "Print 1 to 10",
            "description": "Write a program that prints the numbers 1 to 10, one per line.",
            "hints": [
              "Use <code>for i := 1; i <= 10; i++</code>"
            ],
            "solution": "for i := 1; i <= 10; i++ {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v2",
            "title": "Countdown from 5",
            "description": "Write a program that counts down from 5 to 1, then prints \"Go!\"",
            "hints": [
              "Use <code>for i := 5; i >= 1; i--</code>",
              "Print \"Go!\" after the loop"
            ],
            "solution": "for i := 5; i >= 1; i-- {\n    fmt.Println(i)\n}\nfmt.Println(\"Go!\")"
          },
          {
            "id": "v3",
            "title": "Print Even Numbers",
            "description": "Write a program that prints even numbers from 2 to 10.",
            "hints": [
              "Use <code>for i := 2; i <= 10; i += 2</code>"
            ],
            "solution": "for i := 2; i <= 10; i += 2 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v4",
            "title": "Count by Twos",
            "description": "Write a program that prints odd numbers from 1 to 9.",
            "hints": [
              "Use <code>for i := 1; i <= 9; i += 2</code>"
            ],
            "solution": "for i := 1; i <= 9; i += 2 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v5",
            "title": "Sum First N Numbers",
            "description": "Write a program that calculates and prints the sum of numbers from 1 to 5.",
            "hints": [
              "Create a <code>sum</code> variable",
              "Add each number: <code>sum += i</code>"
            ],
            "solution": "sum := 0\nfor i := 1; i <= 5; i++ {\n    sum += i\n}\nfmt.Println(sum)  // 15"
          },
          {
            "id": "v6",
            "title": "Multiplication Table Row",
            "description": "Write a program that prints the 3 times table from 3x1 to 3x5.",
            "hints": [
              "Loop from 1 to 5",
              "Print <code>3 * i</code> each time"
            ],
            "solution": "for i := 1; i <= 5; i++ {\n    fmt.Printf(\"3 x %d = %d\\n\", i, 3*i)\n}"
          },
          {
            "id": "v7",
            "title": "Print Squares",
            "description": "Write a program that prints the square of numbers from 1 to 4.",
            "hints": [
              "Square is <code>i * i</code>"
            ],
            "solution": "for i := 1; i <= 4; i++ {\n    fmt.Println(i * i)\n}"
          },
          {
            "id": "v8",
            "title": "Count Down by Threes",
            "description": "Write a program that counts down from 15 to 0 by threes (15, 12, 9, 6, 3, 0).",
            "hints": [
              "Start at 15, use <code>i -= 3</code>"
            ],
            "solution": "for i := 15; i >= 0; i -= 3 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v9",
            "title": "Fibonacci First N",
            "description": "Write a program that prints the first 7 Fibonacci numbers (1, 1, 2, 3, 5, 8, 13).",
            "hints": [
              "Start with <code>a, b := 1, 1</code>",
              "Each new number is the sum of the previous two"
            ],
            "solution": "a, b := 1, 1\nfor i := 0; i < 7; i++ {\n    fmt.Println(a)\n    a, b = b, a+b\n}"
          },
          {
            "id": "v10",
            "title": "Factorial",
            "description": "Write a program that calculates and prints 5! (5 factorial = 5 √É¬ó 4 √É¬ó 3 √É¬ó 2 √É¬ó 1 = 120).",
            "hints": [
              "Start with <code>result := 1</code>",
              "Multiply by each number: <code>result *= i</code>"
            ],
            "solution": "result := 1\nfor i := 1; i <= 5; i++ {\n    result *= i\n}\nfmt.Println(result)  // 120"
          },
          {
            "id": "v11",
            "title": "Skip Count by Fives",
            "description": "Write a program that counts from 0 to 25 by fives (0, 5, 10, 15, 20, 25).",
            "hints": [
              "Use <code>for i := 0; i <= 25; i += 5</code>"
            ],
            "solution": "for i := 0; i <= 25; i += 5 {\n    fmt.Println(i)\n}"
          },
          {
            "id": "v12",
            "title": "Print Star Pattern",
            "description": "Write a program that prints a triangle pattern of stars (1 star, then 2 stars, then 3 stars).",
            "hints": [
              "Outer loop controls rows",
              "Inner loop prints stars: <code>for j := 0; j < i; j++</code>"
            ],
            "solution": "for i := 1; i <= 3; i++ {\n    for j := 0; j < i; j++ {\n        fmt.Print(\"*\")\n    }\n    fmt.Println()\n}"
          },
          {
            "id": "v13",
            "title": "Power of Two",
            "description": "Write a program that prints powers of 2 from 2^0 to 2^5 (1, 2, 4, 8, 16, 32).",
            "hints": [
              "Start with <code>power := 1</code>",
              "Double each time: <code>power *= 2</code>"
            ],
            "solution": "power := 1\nfor i := 0; i <= 5; i++ {\n    fmt.Println(power)\n    power *= 2\n}"
          }
        ]
      },
      {
        "id": "warmup_2",
        "concept": "If/Else",
        "variants": [
          {
            "id": "v1",
            "title": "Odd or Even",
            "description": "Write <code>func oddOrEven(n int) string</code> that returns \"even\" if n is divisible by 2, else \"odd\".",
            "hints": [
              "Use modulo: <code>if n % 2 == 0</code> means even"
            ],
            "solution": "func oddOrEven(n int) string {\n    if n % 2 == 0 {\n        return \"even\"\n    }\n    return \"odd\"\n}"
          },
          {
            "id": "v2",
            "title": "Pass or Fail",
            "description": "Write <code>func passOrFail(score int) string</code> that returns \"pass\" if score >= 60, else \"fail\".",
            "hints": [
              "Simple if/else: <code>if score >= 60 { return \"pass\" }</code>"
            ],
            "solution": "func passOrFail(score int) string {\n    if score >= 60 {\n        return \"pass\"\n    }\n    return \"fail\"\n}"
          },
          {
            "id": "v3",
            "title": "Temperature Feel",
            "description": "Write <code>func tempFeel(celsius int) string</code> that returns \"freezing\" (< 0), \"cold\" (0-15), \"warm\" (16-25), or \"hot\" (> 25).",
            "hints": [
              "Chain if/else if based on temperature thresholds"
            ],
            "solution": "func tempFeel(celsius int) string {\n    if celsius < 0 {\n        return \"freezing\"\n    } else if celsius <= 15 {\n        return \"cold\"\n    } else if celsius <= 25 {\n        return \"warm\"\n    }\n    return \"hot\"\n}"
          },
          {
            "id": "v4",
            "title": "Grade Letter",
            "description": "Write <code>func gradeLetter(score int) string</code> that returns \"A\" (>=90), \"B\" (>=80), \"C\" (>=70), \"D\" (>=60), or \"F\" (<60).",
            "hints": [
              "Use chained if/else if statements",
              "Check highest grade first"
            ],
            "solution": "func gradeLetter(score int) string {\n    if score >= 90 {\n        return \"A\"\n    } else if score >= 80 {\n        return \"B\"\n    } else if score >= 70 {\n        return \"C\"\n    } else if score >= 60 {\n        return \"D\"\n    }\n    return \"F\"\n}"
          },
          {
            "id": "v5",
            "title": "Voting Eligibility",
            "description": "Write <code>func canVote(age int) string</code> that returns \"can vote\" if age >= 18, else \"too young\".",
            "hints": [
              "Simple comparison with 18"
            ],
            "solution": "func canVote(age int) string {\n    if age >= 18 {\n        return \"can vote\"\n    }\n    return \"too young\"\n}"
          },
          {
            "id": "v6",
            "title": "Discount Eligibility",
            "description": "Write <code>func getDiscount(age int) string</code> that returns \"senior discount\" (>=65), \"student discount\" (<=25), or \"no discount\".",
            "hints": [
              "Check senior first, then student, then default"
            ],
            "solution": "func getDiscount(age int) string {\n    if age >= 65 {\n        return \"senior discount\"\n    } else if age <= 25 {\n        return \"student discount\"\n    }\n    return \"no discount\"\n}"
          },
          {
            "id": "v7",
            "title": "Positive or Negative",
            "description": "Write <code>func posNegZero(n int) string</code> that returns \"positive\", \"negative\", or \"zero\".",
            "hints": [
              "Check if n > 0, n < 0, or else it's zero"
            ],
            "solution": "func posNegZero(n int) string {\n    if n > 0 {\n        return \"positive\"\n    } else if n < 0 {\n        return \"negative\"\n    }\n    return \"zero\"\n}"
          },
          {
            "id": "v8",
            "title": "Speed Limit",
            "description": "Write <code>func speedCheck(speed int) string</code> that returns \"safe\" (<=60), \"warning\" (61-80), or \"ticket\" (>80).",
            "hints": [
              "Use ranges for different categories"
            ],
            "solution": "func speedCheck(speed int) string {\n    if speed <= 60 {\n        return \"safe\"\n    } else if speed <= 80 {\n        return \"warning\"\n    }\n    return \"ticket\"\n}"
          },
          {
            "id": "v9",
            "title": "Age Category",
            "description": "Write <code>func ageCategory(age int) string</code> that returns \"child\" if age < 13, \"teen\" if age < 20, else \"adult\".",
            "hints": [
              "Use multiple if/else if statements",
              "Check conditions from smallest to largest"
            ],
            "solution": "func ageCategory(age int) string {\n    if age < 13 {\n        return \"child\"\n    } else if age < 20 {\n        return \"teen\"\n    }\n    return \"adult\"\n}"
          },
          {
            "id": "v10",
            "title": "BMI Category",
            "description": "Write <code>func bmiCategory(bmi float64) string</code> that returns \"underweight\" if bmi < 18.5, \"normal\" if bmi < 25, else \"overweight\".",
            "hints": [
              "Use <code>else if</code> for the middle condition"
            ],
            "solution": "func bmiCategory(bmi float64) string {\n    if bmi < 18.5 {\n        return \"underweight\"\n    } else if bmi < 25 {\n        return \"normal\"\n    }\n    return \"overweight\"\n}"
          },
          {
            "id": "v11",
            "title": "Season from Month",
            "description": "Write <code>func season(month int) string</code> that returns \"winter\" for 12-2, \"spring\" for 3-5, \"summer\" for 6-8, \"fall\" for 9-11.",
            "hints": [
              "Use multiple if/else if conditions",
              "Check ranges like <code>month >= 3 && month <= 5</code>"
            ],
            "solution": "func season(month int) string {\n    if month == 12 || month <= 2 {\n        return \"winter\"\n    } else if month <= 5 {\n        return \"spring\"\n    } else if month <= 8 {\n        return \"summer\"\n    }\n    return \"fall\"\n}"
          },
          {
            "id": "v12",
            "title": "Weekend or Weekday",
            "description": "Write <code>func dayType(day string) string</code> that returns \"weekend\" if day is \"Saturday\" or \"Sunday\", else \"weekday\".",
            "hints": [
              "Use <code>||</code> (OR) operator",
              "Check: <code>if day == \"Saturday\" || day == \"Sunday\"</code>"
            ],
            "solution": "func dayType(day string) string {\n    if day == \"Saturday\" || day == \"Sunday\" {\n        return \"weekend\"\n    }\n    return \"weekday\"\n}"
          },
          {
            "id": "v13",
            "title": "Password Strength",
            "description": "Write <code>func passwordStrength(length int) string</code> that returns \"weak\" if length < 8, \"medium\" if length < 12, else \"strong\".",
            "hints": [
              "Simple if/else if chain based on length thresholds"
            ],
            "solution": "func passwordStrength(length int) string {\n    if length < 8 {\n        return \"weak\"\n    } else if length < 12 {\n        return \"medium\"\n    }\n    return \"strong\"\n}"
          }
        ]
      },
      {
        "id": "warmup_3",
        "concept": "Slices & Range",
        "variants": [
          {
            "id": "v1",
            "title": "Iterate Numbers",
            "description": "Create a slice with three numbers, then print each using <code>for range</code>.",
            "hints": [
              "Create: <code>nums := []int{7, 42, 99}</code>",
              "Loop: <code>for _, num := range nums</code>"
            ],
            "solution": "nums := []int{7, 42, 99}\nfor _, num := range nums {\n    fmt.Println(num)\n}"
          },
          {
            "id": "v2",
            "title": "Iterate with Index",
            "description": "Create a slice of colors, then print each with its index: \"0: red\", \"1: blue\", etc.",
            "hints": [
              "Loop with index: <code>for i, color := range colors</code>",
              "Use <code>fmt.Printf(\"%d: %s\\n\", i, color)</code>"
            ],
            "solution": "colors := []string{\"red\", \"blue\", \"green\"}\nfor i, color := range colors {\n    fmt.Printf(\"%d: %s\\n\", i, color)\n}"
          },
          {
            "id": "v3",
            "title": "Iterate Strings",
            "description": "Create a slice of your favorite foods, print each on its own line.",
            "hints": [
              "Create: <code>foods := []string{\"pizza\", \"sushi\", \"tacos\"}</code>"
            ],
            "solution": "foods := []string{\"pizza\", \"sushi\", \"tacos\"}\nfor _, food := range foods {\n    fmt.Println(food)\n}"
          },
          {
            "id": "v4",
            "title": "Sum Slice",
            "description": "Create a slice of numbers, then calculate and print their sum.",
            "hints": [
              "Create a sum variable before the loop",
              "Add each number: <code>sum += num</code>"
            ],
            "solution": "nums := []int{10, 20, 30}\nsum := 0\nfor _, num := range nums {\n    sum += num\n}\nfmt.Println(sum)  // 60"
          },
          {
            "id": "v5",
            "title": "Count Items",
            "description": "Create a slice of fruits and print how many items are in it.",
            "hints": [
              "Use <code>len(fruits)</code> to get the count"
            ],
            "solution": "fruits := []string{\"apple\", \"banana\", \"orange\", \"grape\"}\nfmt.Println(len(fruits))  // 4"
          },
          {
            "id": "v6",
            "title": "Names List",
            "description": "Create a slice of names and print each with a greeting: \"Hello, Alice!\"",
            "hints": [
              "Use <code>fmt.Printf(\"Hello, %s!\\n\", name)</code>"
            ],
            "solution": "names := []string{\"Alice\", \"Bob\", \"Charlie\"}\nfor _, name := range names {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}"
          },
          {
            "id": "v7",
            "title": "Test Scores",
            "description": "Create a slice of test scores and print each one with its position: \"Test 1: 85\"",
            "hints": [
              "Use the index in the range loop",
              "Add 1 to the index for human-readable numbering"
            ],
            "solution": "scores := []int{85, 92, 78, 95}\nfor i, score := range scores {\n    fmt.Printf(\"Test %d: %d\\n\", i+1, score)\n}"
          },
          {
            "id": "v8",
            "title": "Reverse Print",
            "description": "Create a slice of 3 animals and print them in reverse order using a regular for loop.",
            "hints": [
              "Start from <code>len(animals)-1</code>",
              "Count down: <code>i--</code>"
            ],
            "solution": "animals := []string{\"cat\", \"dog\", \"bird\"}\nfor i := len(animals) - 1; i >= 0; i-- {\n    fmt.Println(animals[i])\n}"
          },
          {
            "id": "v9",
            "title": "Find Maximum",
            "description": "Write <code>func findMax(nums []int) int</code> that returns the largest number in the slice.",
            "hints": [
              "Start with <code>max := nums[0]</code>",
              "Use range to compare each number"
            ],
            "solution": "func findMax(nums []int) int {\n    max := nums[0]\n    for _, n := range nums {\n        if n > max {\n            max = n\n        }\n    }\n    return max\n}"
          },
          {
            "id": "v10",
            "title": "Find Minimum",
            "description": "Write <code>func findMin(nums []int) int</code> that returns the smallest number in the slice.",
            "hints": [
              "Start with <code>min := nums[0]</code>",
              "Compare each number: <code>if n < min</code>"
            ],
            "solution": "func findMin(nums []int) int {\n    min := nums[0]\n    for _, n := range nums {\n        if n < min {\n            min = n\n        }\n    }\n    return min\n}"
          },
          {
            "id": "v11",
            "title": "Calculate Average",
            "description": "Write <code>func average(nums []float64) float64</code> that returns the average of all numbers.",
            "hints": [
              "Sum all numbers first",
              "Divide by length: <code>sum / float64(len(nums))</code>"
            ],
            "solution": "func average(nums []float64) float64 {\n    sum := 0.0\n    for _, n := range nums {\n        sum += n\n    }\n    return sum / float64(len(nums))\n}"
          },
          {
            "id": "v12",
            "title": "Contains Check",
            "description": "Write <code>func contains(items []string, target string) bool</code> that returns true if target is in items.",
            "hints": [
              "Use range to check each item",
              "Return true immediately when found"
            ],
            "solution": "func contains(items []string, target string) bool {\n    for _, item := range items {\n        if item == target {\n            return true\n        }\n    }\n    return false\n}"
          },
          {
            "id": "v13",
            "title": "First N Elements",
            "description": "Write <code>func firstN(items []string, n int) []string</code> that returns the first n elements of the slice.",
            "hints": [
              "Use slice syntax: <code>items[:n]</code>"
            ],
            "solution": "func firstN(items []string, n int) []string {\n    return items[:n]\n}"
          }
        ]
      },
      {
        "id": "warmup_4",
        "concept": "Maps",
        "variants": [
          {
            "id": "v1",
            "title": "Ages Map",
            "description": "Create a map of names to ages, then print each person's name and age.",
            "hints": [
              "Map syntax: <code>map[string]int{\"alice\": 30}</code>",
              "Loop: <code>for name, age := range ages</code>"
            ],
            "solution": "ages := map[string]int{\n    \"alice\": 30,\n    \"bob\":   25,\n}\nfor name, age := range ages {\n    fmt.Printf(\"%s is %d\\n\", name, age)\n}"
          },
          {
            "id": "v2",
            "title": "Prices Map",
            "description": "Create a map of items to prices (float64), then print each item and price.",
            "hints": [
              "Map syntax: <code>map[string]float64{\"apple\": 1.50}</code>"
            ],
            "solution": "prices := map[string]float64{\n    \"apple\":  1.50,\n    \"banana\": 0.75,\n}\nfor item, price := range prices {\n    fmt.Printf(\"%s: $%.2f\\n\", item, price)\n}"
          },
          {
            "id": "v3",
            "title": "Capitals Map",
            "description": "Create a map of countries to their capitals, then print each pair.",
            "hints": [
              "Map syntax: <code>map[string]string{\"France\": \"Paris\"}</code>"
            ],
            "solution": "capitals := map[string]string{\n    \"France\": \"Paris\",\n    \"Japan\":  \"Tokyo\",\n}\nfor country, capital := range capitals {\n    fmt.Printf(\"%s: %s\\n\", country, capital)\n}"
          },
          {
            "id": "v4",
            "title": "Inventory Count",
            "description": "Create a map of product names to quantities in stock, then print each item and count.",
            "hints": [
              "Map syntax: <code>map[string]int{\"shirt\": 15}</code>"
            ],
            "solution": "inventory := map[string]int{\n    \"shirt\": 15,\n    \"pants\": 8,\n    \"hat\":   20,\n}\nfor item, count := range inventory {\n    fmt.Printf(\"%s: %d in stock\\n\", item, count)\n}"
          },
          {
            "id": "v5",
            "title": "Student Grades",
            "description": "Create a map of student names to their letter grades, then print each student and grade.",
            "hints": [
              "Map syntax: <code>map[string]string{\"Alice\": \"A\"}</code>"
            ],
            "solution": "grades := map[string]string{\n    \"Alice\": \"A\",\n    \"Bob\":   \"B\",\n    \"Carol\": \"A\",\n}\nfor student, grade := range grades {\n    fmt.Printf(\"%s: %s\\n\", student, grade)\n}"
          },
          {
            "id": "v6",
            "title": "Phone Book",
            "description": "Create a map of names to phone numbers, then print each entry.",
            "hints": [
              "Phone numbers can be strings: <code>\"555-1234\"</code>"
            ],
            "solution": "phonebook := map[string]string{\n    \"Alice\": \"555-1234\",\n    \"Bob\":   \"555-5678\",\n}\nfor name, phone := range phonebook {\n    fmt.Printf(\"%s: %s\\n\", name, phone)\n}"
          },
          {
            "id": "v7",
            "title": "Menu Prices",
            "description": "Create a map of menu items to their prices (use integers for cents), then print the menu.",
            "hints": [
              "Store cents as int: 250 for $2.50",
              "Divide by 100.0 when printing"
            ],
            "solution": "menu := map[string]int{\n    \"burger\": 850,\n    \"fries\":  350,\n    \"soda\":   200,\n}\nfor item, cents := range menu {\n    fmt.Printf(\"%s: $%.2f\\n\", item, float64(cents)/100.0)\n}"
          },
          {
            "id": "v8",
            "title": "Room Numbers",
            "description": "Create a map of employee names to their office room numbers, then print the directory.",
            "hints": [
              "Map syntax: <code>map[string]int{\"Alice\": 101}</code>"
            ],
            "solution": "offices := map[string]int{\n    \"Alice\": 101,\n    \"Bob\":   102,\n    \"Carol\": 105,\n}\nfor name, room := range offices {\n    fmt.Printf(\"%s - Room %d\\n\", name, room)\n}"
          },
          {
            "id": "v9",
            "title": "Most Common Value",
            "description": "Write <code>func mostCommon(counts map[string]int) string</code> that returns the key with the highest value.",
            "hints": [
              "Track max value and corresponding key",
              "Loop through map with range"
            ],
            "solution": "func mostCommon(counts map[string]int) string {\n    maxKey := \"\"\n    maxVal := 0\n    for k, v := range counts {\n        if v > maxVal {\n            maxVal = v\n            maxKey = k\n        }\n    }\n    return maxKey\n}"
          },
          {
            "id": "v10",
            "title": "Merge Maps",
            "description": "Write <code>func mergeMaps(m1, m2 map[string]int) map[string]int</code> that combines both maps (m2 overwrites m1 on conflicts).",
            "hints": [
              "Create new result map",
              "Copy all from m1, then all from m2"
            ],
            "solution": "func mergeMaps(m1, m2 map[string]int) map[string]int {\n    result := make(map[string]int)\n    for k, v := range m1 {\n        result[k] = v\n    }\n    for k, v := range m2 {\n        result[k] = v\n    }\n    return result\n}"
          },
          {
            "id": "v11",
            "title": "Filter by Value",
            "description": "Write <code>func filterByValue(m map[string]int, threshold int) map[string]int</code> that returns only entries where value >= threshold.",
            "hints": [
              "Create new map for results",
              "Only add entries that meet the condition"
            ],
            "solution": "func filterByValue(m map[string]int, threshold int) map[string]int {\n    result := make(map[string]int)\n    for k, v := range m {\n        if v >= threshold {\n            result[k] = v\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v12",
            "title": "Key Exists Multiple",
            "description": "Write <code>func hasAllKeys(m map[string]int, keys []string) bool</code> that returns true if all keys exist in the map.",
            "hints": [
              "Loop through keys slice",
              "Use comma-ok idiom: <code>_, ok := m[key]</code>"
            ],
            "solution": "func hasAllKeys(m map[string]int, keys []string) bool {\n    for _, key := range keys {\n        if _, ok := m[key]; !ok {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v13",
            "title": "Invert Map",
            "description": "Write <code>func invertMap(m map[string]string) map[string]string</code> that swaps keys and values.",
            "hints": [
              "Create new map where values become keys",
              "Loop: <code>result[v] = k</code>"
            ],
            "solution": "func invertMap(m map[string]string) map[string]string {\n    result := make(map[string]string)\n    for k, v := range m {\n        result[v] = k\n    }\n    return result\n}"
          }
        ]
      },
      {
        "id": "warmup_5",
        "concept": "Variables & Assignment",
        "variants": [
          {
            "id": "v1",
            "title": "Declare and Print",
            "description": "Declare a variable <code>name</code> with value \"Go\", and an integer <code>year</code> with value 2009. Print both.",
            "hints": [
              "Use short declaration: <code>name := \"Go\"</code>",
              "Use <code>fmt.Println(name, year)</code>"
            ],
            "solution": "name := \"Go\"\nyear := 2009\nfmt.Println(name, year)"
          },
          {
            "id": "v2",
            "title": "Swap Two Variables",
            "description": "Create two variables <code>a := 10</code> and <code>b := 20</code>. Swap their values, then print them.",
            "hints": [
              "Go allows simultaneous assignment: <code>a, b = b, a</code>"
            ],
            "solution": "a := 10\nb := 20\na, b = b, a\nfmt.Println(a, b)  // 20 10"
          },
          {
            "id": "v3",
            "title": "Type Inference",
            "description": "Create variables for your age (int), height (float64), and name (string) using short declaration. Print their values and types.",
            "hints": [
              "Go infers types: <code>age := 25</code> is int",
              "Use <code>fmt.Printf(\"%T\", age)</code> to print type"
            ],
            "solution": "age := 25\nheight := 5.9\nname := \"Alice\"\nfmt.Printf(\"age: %d (%T)\\n\", age, age)\nfmt.Printf(\"height: %.1f (%T)\\n\", height, height)\nfmt.Printf(\"name: %s (%T)\\n\", name, name)"
          },
          {
            "id": "v4",
            "title": "Calculate Area",
            "description": "Create variables for width (5.0) and height (3.0), calculate the area, and print it.",
            "hints": [
              "Area is width * height",
              "Use <code>:=</code> for short declaration"
            ],
            "solution": "width := 5.0\nheight := 3.0\narea := width * height\nfmt.Println(area)  // 15"
          },
          {
            "id": "v5",
            "title": "String Concatenation",
            "description": "Create variables for first name and last name, then create and print a full name.",
            "hints": [
              "Concatenate with <code>+</code>",
              "Don't forget the space between names"
            ],
            "solution": "firstName := \"John\"\nlastName := \"Doe\"\nfullName := firstName + \" \" + lastName\nfmt.Println(fullName)  // John Doe"
          },
          {
            "id": "v6",
            "title": "Boolean Logic",
            "description": "Create two boolean variables, then print their AND and OR results.",
            "hints": [
              "AND: <code>a && b</code>",
              "OR: <code>a || b</code>"
            ],
            "solution": "a := true\nb := false\nfmt.Println(a && b)  // false\nfmt.Println(a || b)  // true"
          },
          {
            "id": "v7",
            "title": "Temperature Conversion",
            "description": "Create a celsius variable (25), convert it to Fahrenheit (F = C * 9/5 + 32), and print both.",
            "hints": [
              "Formula: <code>fahrenheit := celsius * 9 / 5 + 32</code>",
              "Use float64 for decimal precision"
            ],
            "solution": "celsius := 25.0\nfahrenheit := celsius * 9 / 5 + 32\nfmt.Printf(\"%.1fC = %.1fF\\n\", celsius, fahrenheit)  // 25.0C = 77.0F"
          },
          {
            "id": "v8",
            "title": "Shopping Total",
            "description": "Create variables for three item prices, calculate the total, then apply a 10% discount and print the final price.",
            "hints": [
              "Total: <code>price1 + price2 + price3</code>",
              "Discount: <code>total * 0.9</code>"
            ],
            "solution": "item1 := 10.0\nitem2 := 25.5\nitem3 := 8.75\ntotal := item1 + item2 + item3\nfinal := total * 0.9\nfmt.Printf(\"Total: $%.2f, After discount: $%.2f\\n\", total, final)"
          },
          {
            "id": "v9",
            "title": "Pythagorean Theorem",
            "description": "Write a program that calculates the hypotenuse c given sides a=3 and b=4 using c = sqrt(a¬≤ + b¬≤). Print the result.",
            "hints": [
              "Use <code>math.Sqrt()</code> function",
              "Formula: <code>c := math.Sqrt(a*a + b*b)</code>"
            ],
            "solution": "import \"math\"\n\na := 3.0\nb := 4.0\nc := math.Sqrt(a*a + b*b)\nfmt.Println(c)  // 5"
          },
          {
            "id": "v10",
            "title": "Compound Interest",
            "description": "Write a program that calculates compound interest. Given principal=1000, rate=0.05, time=2, calculate amount = principal * (1 + rate)^time. Print result.",
            "hints": [
              "Use <code>math.Pow()</code> for exponentiation",
              "Formula: <code>amount := principal * math.Pow(1+rate, time)</code>"
            ],
            "solution": "import \"math\"\n\nprincipal := 1000.0\nrate := 0.05\ntime := 2.0\namount := principal * math.Pow(1+rate, time)\nfmt.Println(amount)  // 1102.5"
          },
          {
            "id": "v11",
            "title": "Temperature Conversion",
            "description": "Write a program that converts 100√Ç¬∞F to Celsius using the formula C = (F - 32) * 5/9. Print the result.",
            "hints": [
              "Use parentheses for correct order of operations",
              "Formula: <code>celsius := (fahrenheit - 32) * 5 / 9</code>"
            ],
            "solution": "fahrenheit := 100.0\ncelsius := (fahrenheit - 32) * 5 / 9\nfmt.Println(celsius)  // 37.777..."
          },
          {
            "id": "v12",
            "title": "Circle Circumference",
            "description": "Write a program that calculates the circumference of a circle with radius 7 using C = 2√è¬Är. Print the result.",
            "hints": [
              "Use <code>math.Pi</code> constant",
              "Formula: <code>circumference := 2 * math.Pi * radius</code>"
            ],
            "solution": "import \"math\"\n\nradius := 7.0\ncircumference := 2 * math.Pi * radius\nfmt.Println(circumference)  // 43.98..."
          },
          {
            "id": "v13",
            "title": "Distance Formula",
            "description": "Write a program that calculates distance between points (1,2) and (4,6) using d = sqrt((x2-x1)¬≤ + (y2-y1)¬≤). Print result.",
            "hints": [
              "Calculate differences first: <code>dx := x2 - x1</code>",
              "Use <code>math.Sqrt(dx*dx + dy*dy)</code>"
            ],
            "solution": "import \"math\"\n\nx1, y1 := 1.0, 2.0\nx2, y2 := 4.0, 6.0\ndx := x2 - x1\ndy := y2 - y1\ndist := math.Sqrt(dx*dx + dy*dy)\nfmt.Println(dist)  // 5"
          }
        ]
      },
      {
        "id": "warmup_6",
        "concept": "Multiple Returns",
        "variants": [
          {
            "id": "v1",
            "title": "Divide with Remainder",
            "description": "Write <code>func divMod(a, b int) (int, int)</code> that returns both quotient and remainder.",
            "hints": [
              "Return two values: <code>return a / b, a % b</code>",
              "Call with: <code>q, r := divMod(10, 3)</code>"
            ],
            "solution": "func divMod(a, b int) (int, int) {\n    return a / b, a % b\n}\n\n// Usage:\nq, r := divMod(10, 3)\nfmt.Println(q, r)  // 3 1"
          },
          {
            "id": "v2",
            "title": "Min and Max",
            "description": "Write <code>func minMax(a, b int) (int, int)</code> that returns the smaller value first, then the larger.",
            "hints": [
              "Use if to compare, then return in order"
            ],
            "solution": "func minMax(a, b int) (int, int) {\n    if a < b {\n        return a, b\n    }\n    return b, a\n}\n\n// Usage:\nsmall, big := minMax(5, 3)\nfmt.Println(small, big)  // 3 5"
          },
          {
            "id": "v3",
            "title": "First and Last",
            "description": "Write <code>func firstLast(s string) (string, string)</code> that returns the first and last character of a string.",
            "hints": [
              "First char: <code>string(s[0])</code>",
              "Last char: <code>string(s[len(s)-1])</code>"
            ],
            "solution": "func firstLast(s string) (string, string) {\n    return string(s[0]), string(s[len(s)-1])\n}\n\n// Usage:\nf, l := firstLast(\"hello\")\nfmt.Println(f, l)  // h o"
          },
          {
            "id": "v4",
            "title": "Split Name",
            "description": "Write <code>func splitName(fullName string) (string, string)</code> that splits \"John Doe\" into first and last name (assume one space).",
            "hints": [
              "Find the space with a simple loop or assume fixed position",
              "For warmup, you can hardcode the split at index 4 for \"John Doe\""
            ],
            "solution": "func splitName(fullName string) (string, string) {\n    // Simple version: find space\n    for i, ch := range fullName {\n        if ch == ' ' {\n            return fullName[:i], fullName[i+1:]\n        }\n    }\n    return fullName, \"\"\n}\n\n// Usage:\nfirst, last := splitName(\"John Doe\")\nfmt.Println(first, last)  // John Doe"
          },
          {
            "id": "v5",
            "title": "Circle Properties",
            "description": "Write <code>func circleProps(radius float64) (float64, float64)</code> that returns circumference and area (use 3.14 for pi).",
            "hints": [
              "Circumference: <code>2 * pi * radius</code>",
              "Area: <code>pi * radius * radius</code>"
            ],
            "solution": "func circleProps(radius float64) (float64, float64) {\n    pi := 3.14\n    circumference := 2 * pi * radius\n    area := pi * radius * radius\n    return circumference, area\n}\n\n// Usage:\nc, a := circleProps(5.0)\nfmt.Printf(\"Circumference: %.2f, Area: %.2f\\n\", c, a)"
          },
          {
            "id": "v6",
            "title": "Bounds Check",
            "description": "Write <code>func inRange(n, min, max int) (bool, string)</code> that returns true/\"in range\" if n is between min and max, else false/\"out of range\".",
            "hints": [
              "Check if <code>n >= min && n <= max</code>",
              "Return both the boolean and a message"
            ],
            "solution": "func inRange(n, min, max int) (bool, string) {\n    if n >= min && n <= max {\n        return true, \"in range\"\n    }\n    return false, \"out of range\"\n}\n\n// Usage:\nok, msg := inRange(15, 10, 20)\nfmt.Println(ok, msg)  // true in range"
          },
          {
            "id": "v7",
            "title": "Quotient and Remainder",
            "description": "Write <code>func divide(dividend, divisor int) (int, int)</code> that returns quotient and remainder.",
            "hints": [
              "Quotient: <code>dividend / divisor</code>",
              "Remainder: <code>dividend % divisor</code>"
            ],
            "solution": "func divide(dividend, divisor int) (int, int) {\n    quotient := dividend / divisor\n    remainder := dividend % divisor\n    return quotient, remainder\n}\n\n// Usage:\nq, r := divide(17, 5)\nfmt.Println(q, r)  // 3 2"
          },
          {
            "id": "v8",
            "title": "String Info",
            "description": "Write <code>func stringInfo(s string) (int, string)</code> that returns the length and the first character as a string.",
            "hints": [
              "Length: <code>len(s)</code>",
              "First char: <code>string(s[0])</code>"
            ],
            "solution": "func stringInfo(s string) (int, string) {\n    length := len(s)\n    firstChar := string(s[0])\n    return length, firstChar\n}\n\n// Usage:\nlen, first := stringInfo(\"hello\")\nfmt.Println(len, first)  // 5 h"
          },
          {
            "id": "v9",
            "title": "Parse Int with Error",
            "description": "Write <code>func parsePositive(s string) (int, error)</code> that converts string to int. Return error if conversion fails or number is negative.",
            "hints": [
              "Use <code>strconv.Atoi(s)</code> to convert",
              "Check if result < 0 and return custom error"
            ],
            "solution": "import (\n    \"errors\"\n    \"strconv\"\n)\n\nfunc parsePositive(s string) (int, error) {\n    n, err := strconv.Atoi(s)\n    if err != nil {\n        return 0, err\n    }\n    if n < 0 {\n        return 0, errors.New(\"negative number\")\n    }\n    return n, nil\n}"
          },
          {
            "id": "v10",
            "title": "Validate Range",
            "description": "Write <code>func validateRange(n, min, max int) (int, bool)</code> that returns (n, true) if n is in [min,max], else (0, false).",
            "hints": [
              "Check condition: <code>n >= min && n <= max</code>",
              "Return the value with a boolean flag"
            ],
            "solution": "func validateRange(n, min, max int) (int, bool) {\n    if n >= min && n <= max {\n        return n, true\n    }\n    return 0, false\n}"
          },
          {
            "id": "v11",
            "title": "String Split at Position",
            "description": "Write <code>func splitAt(s string, pos int) (string, string, bool)</code> that splits string at position. Return false if pos is out of bounds.",
            "hints": [
              "Check if <code>pos >= 0 && pos <= len(s)</code>",
              "Use slice notation: <code>s[:pos]</code> and <code>s[pos:]</code>"
            ],
            "solution": "func splitAt(s string, pos int) (string, string, bool) {\n    if pos < 0 || pos > len(s) {\n        return \"\", \"\", false\n    }\n    return s[:pos], s[pos:], true\n}"
          },
          {
            "id": "v12",
            "title": "Find First Occurrence",
            "description": "Write <code>func findFirst(items []string, target string) (int, bool)</code> that returns (index, true) if found, else (-1, false).",
            "hints": [
              "Use range to get both index and value",
              "Return immediately when target is found"
            ],
            "solution": "func findFirst(items []string, target string) (int, bool) {\n    for i, item := range items {\n        if item == target {\n            return i, true\n        }\n    }\n    return -1, false\n}"
          },
          {
            "id": "v13",
            "title": "Min and Max",
            "description": "Write <code>func minMax(nums []int) (int, int)</code> that returns both the minimum and maximum values in one call.",
            "hints": [
              "Initialize both to first element",
              "Update both in one loop using range"
            ],
            "solution": "func minMax(nums []int) (int, int) {\n    min, max := nums[0], nums[0]\n    for _, n := range nums {\n        if n < min {\n            min = n\n        }\n        if n > max {\n            max = n\n        }\n    }\n    return min, max\n}"
          }
        ]
      },
      {
        "id": "warmup_7",
        "concept": "Recursion",
        "variants": [
          {
            "id": "v1",
            "title": "Recursive Countdown",
            "description": "Write <code>func countdown(n int)</code> that prints numbers from n down to 1 using recursion (no loops!).",
            "hints": [
              "Base case: if n < 1, stop (return)",
              "Recursive case: print n, then call countdown(n-1)"
            ],
            "solution": "func countdown(n int) {\n    if n < 1 {\n        return\n    }\n    fmt.Println(n)\n    countdown(n - 1)\n}"
          },
          {
            "id": "v2",
            "title": "Recursive Sum",
            "description": "Write <code>func sumTo(n int) int</code> that returns the sum of 1 + 2 + ... + n using recursion.",
            "hints": [
              "Base case: sumTo(0) = 0",
              "Recursive case: sumTo(n) = n + sumTo(n-1)"
            ],
            "solution": "func sumTo(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    return n + sumTo(n-1)\n}"
          },
          {
            "id": "v3",
            "title": "Recursive Factorial",
            "description": "Write <code>func factorial(n int) int</code> that returns n! (n factorial) using recursion. 0! = 1.",
            "hints": [
              "Base case: factorial(0) = 1",
              "Recursive case: factorial(n) = n * factorial(n-1)"
            ],
            "solution": "func factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    return n * factorial(n-1)\n}"
          },
          {
            "id": "v4",
            "title": "Recursive Power",
            "description": "Write <code>func power(base, exp int) int</code> that returns base^exp using recursion. Assume exp >= 0.",
            "hints": [
              "Base case: power(base, 0) = 1",
              "Recursive case: power(base, exp) = base * power(base, exp-1)"
            ],
            "solution": "func power(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    return base * power(base, exp-1)\n}"
          },
          {
            "id": "v5",
            "title": "Recursive Length",
            "description": "Write <code>func length(items []int) int</code> that counts elements in a slice using recursion (don't use len!).",
            "hints": [
              "Base case: empty slice has length 0",
              "Recursive case: 1 + length(items[1:])"
            ],
            "solution": "func length(items []int) int {\n    if len(items) == 0 {\n        return 0\n    }\n    return 1 + length(items[1:])\n}"
          },
          {
            "id": "v6",
            "title": "Recursive Contains",
            "description": "Write <code>func contains(items []int, target int) bool</code> that checks if target is in the slice using recursion.",
            "hints": [
              "Base case: empty slice ‚Üí false",
              "Check first element, then recurse on the rest: items[1:]"
            ],
            "solution": "func contains(items []int, target int) bool {\n    if len(items) == 0 {\n        return false\n    }\n    if items[0] == target {\n        return true\n    }\n    return contains(items[1:], target)\n}"
          },
          {
            "id": "v7",
            "title": "Recursive Max",
            "description": "Write <code>func max(items []int) int</code> that finds the maximum value in a non-empty slice using recursion.",
            "hints": [
              "Base case: one element ‚Üí return it",
              "Compare first element with max of the rest"
            ],
            "solution": "func max(items []int) int {\n    if len(items) == 1 {\n        return items[0]\n    }\n    rest := max(items[1:])\n    if items[0] > rest {\n        return items[0]\n    }\n    return rest\n}"
          },
          {
            "id": "v8",
            "title": "Recursive Sum Slice",
            "description": "Write <code>func sumSlice(items []int) int</code> that sums all elements in a slice using recursion.",
            "hints": [
              "Base case: empty slice ‚Üí 0",
              "Recursive case: items[0] + sumSlice(items[1:])"
            ],
            "solution": "func sumSlice(items []int) int {\n    if len(items) == 0 {\n        return 0\n    }\n    return items[0] + sumSlice(items[1:])\n}"
          },
          {
            "id": "v9",
            "title": "Recursive Reverse",
            "description": "Write <code>func reverse(s string) string</code> that reverses a string using recursion.",
            "hints": [
              "Base case: empty string or single char ‚Üí return s",
              "Recursive case: reverse(s[1:]) + first character"
            ],
            "solution": "func reverse(s string) string {\n    if len(s) <= 1 {\n        return s\n    }\n    return reverse(s[1:]) + string(s[0])\n}"
          },
          {
            "id": "v10",
            "title": "Recursive Fibonacci",
            "description": "Write <code>func fib(n int) int</code> that returns the nth Fibonacci number. fib(0)=0, fib(1)=1.",
            "hints": [
              "Base cases: fib(0) = 0, fib(1) = 1",
              "Recursive case: fib(n) = fib(n-1) + fib(n-2)"
            ],
            "solution": "func fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)\n}"
          },
          {
            "id": "v11",
            "title": "Recursive Count",
            "description": "Write <code>func countOccurrences(items []int, target int) int</code> that counts how many times target appears using recursion.",
            "hints": [
              "Base case: empty slice ‚Üí 0",
              "If first matches, 1 + recurse on rest; else 0 + recurse on rest"
            ],
            "solution": "func countOccurrences(items []int, target int) int {\n    if len(items) == 0 {\n        return 0\n    }\n    count := 0\n    if items[0] == target {\n        count = 1\n    }\n    return count + countOccurrences(items[1:], target)\n}"
          },
          {
            "id": "v12",
            "title": "Recursive String Repeat",
            "description": "Write <code>func repeatStr(s string, n int) string</code> that returns s repeated n times using recursion.",
            "hints": [
              "Base case: n <= 0 ‚Üí empty string",
              "Recursive case: s + repeatStr(s, n-1)"
            ],
            "solution": "func repeatStr(s string, n int) string {\n    if n <= 0 {\n        return \"\"\n    }\n    return s + repeatStr(s, n-1)\n}"
          },
          {
            "id": "v13",
            "title": "Recursive Is Palindrome",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards, using recursion.",
            "hints": [
              "Base case: length 0 or 1 ‚Üí true",
              "Check first == last, then recurse on the middle: s[1:len(s)-1]"
            ],
            "solution": "func isPalindrome(s string) bool {\n    if len(s) <= 1 {\n        return true\n    }\n    if s[0] != s[len(s)-1] {\n        return false\n    }\n    return isPalindrome(s[1 : len(s)-1])\n}"
          }
        ]
      },
      {
        "id": "warmup_8",
        "concept": "Strings",
        "variants": [
          {
            "id": "v1",
            "title": "String Length",
            "description": "Write <code>func strLen(s string) int</code> that returns the length of string s.",
            "hints": [
              "Use the built-in <code>len(s)</code> function"
            ],
            "solution": "func strLen(s string) int {\n    return len(s)\n}"
          },
          {
            "id": "v2",
            "title": "First Character",
            "description": "Write <code>func firstChar(s string) byte</code> that returns the first character of s. Assume s is non-empty.",
            "hints": [
              "Access the first byte with <code>s[0]</code>"
            ],
            "solution": "func firstChar(s string) byte {\n    return s[0]\n}"
          },
          {
            "id": "v3",
            "title": "Last Character",
            "description": "Write <code>func lastChar(s string) byte</code> that returns the last character of s. Assume s is non-empty.",
            "hints": [
              "Use <code>s[len(s)-1]</code> to get the last byte"
            ],
            "solution": "func lastChar(s string) byte {\n    return s[len(s)-1]\n}"
          },
          {
            "id": "v4",
            "title": "Concatenate",
            "description": "Write <code>func concat(a, b string) string</code> that concatenates two strings.",
            "hints": [
              "Use the <code>+</code> operator: <code>a + b</code>"
            ],
            "solution": "func concat(a, b string) string {\n    return a + b\n}"
          },
          {
            "id": "v5",
            "title": "Contains Check",
            "description": "Write <code>func hasSubstring(s, sub string) bool</code> that checks if s contains sub. Import \"strings\".",
            "hints": [
              "Use <code>strings.Contains(s, sub)</code>"
            ],
            "solution": "func hasSubstring(s, sub string) bool {\n    return strings.Contains(s, sub)\n}"
          },
          {
            "id": "v6",
            "title": "To Uppercase",
            "description": "Write <code>func toUpper(s string) string</code> that returns s in all uppercase. Import \"strings\".",
            "hints": [
              "Use <code>strings.ToUpper(s)</code>"
            ],
            "solution": "func toUpper(s string) string {\n    return strings.ToUpper(s)\n}"
          },
          {
            "id": "v7",
            "title": "To Lowercase",
            "description": "Write <code>func toLower(s string) string</code> that returns s in all lowercase. Import \"strings\".",
            "hints": [
              "Use <code>strings.ToLower(s)</code>"
            ],
            "solution": "func toLower(s string) string {\n    return strings.ToLower(s)\n}"
          },
          {
            "id": "v8",
            "title": "Trim Spaces",
            "description": "Write <code>func trimSpaces(s string) string</code> that removes leading and trailing whitespace. Import \"strings\".",
            "hints": [
              "Use <code>strings.TrimSpace(s)</code>"
            ],
            "solution": "func trimSpaces(s string) string {\n    return strings.TrimSpace(s)\n}"
          },
          {
            "id": "v9",
            "title": "Split String",
            "description": "Write <code>func splitByComma(s string) []string</code> that splits a string by commas. Import \"strings\".",
            "hints": [
              "Use <code>strings.Split(s, \",\")</code>"
            ],
            "solution": "func splitByComma(s string) []string {\n    return strings.Split(s, \",\")\n}"
          },
          {
            "id": "v10",
            "title": "Join Strings",
            "description": "Write <code>func joinWithDash(parts []string) string</code> that joins strings with a dash. Import \"strings\".",
            "hints": [
              "Use <code>strings.Join(parts, \"-\")</code>"
            ],
            "solution": "func joinWithDash(parts []string) string {\n    return strings.Join(parts, \"-\")\n}"
          },
          {
            "id": "v11",
            "title": "Replace",
            "description": "Write <code>func replaceAll(s, old, new string) string</code> that replaces all occurrences of old with new in s. Import \"strings\".",
            "hints": [
              "Use <code>strings.ReplaceAll(s, old, new)</code>"
            ],
            "solution": "func replaceAll(s, old, new string) string {\n    return strings.ReplaceAll(s, old, new)\n}"
          },
          {
            "id": "v12",
            "title": "Has Prefix",
            "description": "Write <code>func startsWith(s, prefix string) bool</code> that checks if s starts with prefix. Import \"strings\".",
            "hints": [
              "Use <code>strings.HasPrefix(s, prefix)</code>"
            ],
            "solution": "func startsWith(s, prefix string) bool {\n    return strings.HasPrefix(s, prefix)\n}"
          },
          {
            "id": "v13",
            "title": "Repeat String",
            "description": "Write <code>func repeat(s string, n int) string</code> that repeats s n times. Import \"strings\".",
            "hints": [
              "Use <code>strings.Repeat(s, n)</code>"
            ],
            "solution": "func repeat(s string, n int) string {\n    return strings.Repeat(s, n)\n}"
          }
        ]
      },
      {
        "id": "warmup_9",
        "concept": "Switch",
        "variants": [
          {
            "id": "v1",
            "title": "Day Name",
            "description": "Write <code>func dayName(n int) string</code> that returns the day name for 1=Monday through 7=Sunday. Return \"invalid\" for other values.",
            "hints": [
              "Use a switch statement on n",
              "Each case returns the day name"
            ],
            "solution": "func dayName(n int) string {\n    switch n {\n    case 1:\n        return \"Monday\"\n    case 2:\n        return \"Tuesday\"\n    case 3:\n        return \"Wednesday\"\n    case 4:\n        return \"Thursday\"\n    case 5:\n        return \"Friday\"\n    case 6:\n        return \"Saturday\"\n    case 7:\n        return \"Sunday\"\n    default:\n        return \"invalid\"\n    }\n}"
          },
          {
            "id": "v2",
            "title": "Month Name",
            "description": "Write <code>func monthName(n int) string</code> that returns the month name for 1-12. Return \"invalid\" otherwise.",
            "hints": [
              "Use a switch with cases 1 through 12"
            ],
            "solution": "func monthName(n int) string {\n    switch n {\n    case 1:\n        return \"January\"\n    case 2:\n        return \"February\"\n    case 3:\n        return \"March\"\n    case 4:\n        return \"April\"\n    case 5:\n        return \"May\"\n    case 6:\n        return \"June\"\n    case 7:\n        return \"July\"\n    case 8:\n        return \"August\"\n    case 9:\n        return \"September\"\n    case 10:\n        return \"October\"\n    case 11:\n        return \"November\"\n    case 12:\n        return \"December\"\n    default:\n        return \"invalid\"\n    }\n}"
          },
          {
            "id": "v3",
            "title": "Grade to Message",
            "description": "Write <code>func gradeMessage(grade string) string</code> that returns a message: A=\"Excellent\", B=\"Good\", C=\"Average\", D=\"Below Average\", F=\"Failing\". Default: \"Invalid grade\".",
            "hints": [
              "Switch on the grade string",
              "Use default for unknown grades"
            ],
            "solution": "func gradeMessage(grade string) string {\n    switch grade {\n    case \"A\":\n        return \"Excellent\"\n    case \"B\":\n        return \"Good\"\n    case \"C\":\n        return \"Average\"\n    case \"D\":\n        return \"Below Average\"\n    case \"F\":\n        return \"Failing\"\n    default:\n        return \"Invalid grade\"\n    }\n}"
          },
          {
            "id": "v4",
            "title": "Color to Hex",
            "description": "Write <code>func colorHex(color string) string</code> that returns hex for: \"red\"=\"#FF0000\", \"green\"=\"#00FF00\", \"blue\"=\"#0000FF\", \"white\"=\"#FFFFFF\", \"black\"=\"#000000\". Default: \"unknown\".",
            "hints": [
              "Switch on the color string"
            ],
            "solution": "func colorHex(color string) string {\n    switch color {\n    case \"red\":\n        return \"#FF0000\"\n    case \"green\":\n        return \"#00FF00\"\n    case \"blue\":\n        return \"#0000FF\"\n    case \"white\":\n        return \"#FFFFFF\"\n    case \"black\":\n        return \"#000000\"\n    default:\n        return \"unknown\"\n    }\n}"
          },
          {
            "id": "v5",
            "title": "Traffic Light",
            "description": "Write <code>func trafficAction(light string) string</code> that returns: \"red\"=\"stop\", \"yellow\"=\"caution\", \"green\"=\"go\". Default: \"invalid\".",
            "hints": [
              "Simple switch with three cases plus default"
            ],
            "solution": "func trafficAction(light string) string {\n    switch light {\n    case \"red\":\n        return \"stop\"\n    case \"yellow\":\n        return \"caution\"\n    case \"green\":\n        return \"go\"\n    default:\n        return \"invalid\"\n    }\n}"
          },
          {
            "id": "v6",
            "title": "Season",
            "description": "Write <code>func season(month int) string</code> that returns the season: 12,1,2=\"Winter\", 3,4,5=\"Spring\", 6,7,8=\"Summer\", 9,10,11=\"Fall\". Default: \"invalid\".",
            "hints": [
              "You can list multiple values in one case: <code>case 12, 1, 2:</code>"
            ],
            "solution": "func season(month int) string {\n    switch month {\n    case 12, 1, 2:\n        return \"Winter\"\n    case 3, 4, 5:\n        return \"Spring\"\n    case 6, 7, 8:\n        return \"Summer\"\n    case 9, 10, 11:\n        return \"Fall\"\n    default:\n        return \"invalid\"\n    }\n}"
          },
          {
            "id": "v7",
            "title": "Coin Name",
            "description": "Write <code>func coinName(cents int) string</code>: 1=\"penny\", 5=\"nickel\", 10=\"dime\", 25=\"quarter\". Default: \"unknown\".",
            "hints": [
              "Switch on the cent value"
            ],
            "solution": "func coinName(cents int) string {\n    switch cents {\n    case 1:\n        return \"penny\"\n    case 5:\n        return \"nickel\"\n    case 10:\n        return \"dime\"\n    case 25:\n        return \"quarter\"\n    default:\n        return \"unknown\"\n    }\n}"
          },
          {
            "id": "v8",
            "title": "HTTP Status",
            "description": "Write <code>func httpStatus(code int) string</code>: 200=\"OK\", 301=\"Moved Permanently\", 404=\"Not Found\", 500=\"Internal Server Error\". Default: \"Unknown\".",
            "hints": [
              "Switch on the status code integer"
            ],
            "solution": "func httpStatus(code int) string {\n    switch code {\n    case 200:\n        return \"OK\"\n    case 301:\n        return \"Moved Permanently\"\n    case 404:\n        return \"Not Found\"\n    case 500:\n        return \"Internal Server Error\"\n    default:\n        return \"Unknown\"\n    }\n}"
          },
          {
            "id": "v9",
            "title": "Calculator",
            "description": "Write <code>func calc(a int, op string, b int) int</code> that performs the operation: \"+\" add, \"-\" subtract, \"*\" multiply, \"/\" divide. Return 0 for unknown ops or division by zero.",
            "hints": [
              "Switch on op",
              "For division, check b != 0 before dividing"
            ],
            "solution": "func calc(a int, op string, b int) int {\n    switch op {\n    case \"+\":\n        return a + b\n    case \"-\":\n        return a - b\n    case \"*\":\n        return a * b\n    case \"/\":\n        if b != 0 {\n            return a / b\n        }\n        return 0\n    default:\n        return 0\n    }\n}"
          },
          {
            "id": "v10",
            "title": "Direction",
            "description": "Write <code>func fullDirection(abbr string) string</code>: \"N\"=\"North\", \"S\"=\"South\", \"E\"=\"East\", \"W\"=\"West\". Default: \"Unknown\".",
            "hints": [
              "Switch on the abbreviation string"
            ],
            "solution": "func fullDirection(abbr string) string {\n    switch abbr {\n    case \"N\":\n        return \"North\"\n    case \"S\":\n        return \"South\"\n    case \"E\":\n        return \"East\"\n    case \"W\":\n        return \"West\"\n    default:\n        return \"Unknown\"\n    }\n}"
          },
          {
            "id": "v11",
            "title": "Planet",
            "description": "Write <code>func planet(n int) string</code> that returns the planet name: 1=\"Mercury\", 2=\"Venus\", 3=\"Earth\", 4=\"Mars\", 5=\"Jupiter\", 6=\"Saturn\", 7=\"Uranus\", 8=\"Neptune\". Default: \"Unknown\".",
            "hints": [
              "Switch with 8 cases plus default"
            ],
            "solution": "func planet(n int) string {\n    switch n {\n    case 1:\n        return \"Mercury\"\n    case 2:\n        return \"Venus\"\n    case 3:\n        return \"Earth\"\n    case 4:\n        return \"Mars\"\n    case 5:\n        return \"Jupiter\"\n    case 6:\n        return \"Saturn\"\n    case 7:\n        return \"Uranus\"\n    case 8:\n        return \"Neptune\"\n    default:\n        return \"Unknown\"\n    }\n}"
          },
          {
            "id": "v12",
            "title": "Zodiac",
            "description": "Write <code>func zodiac(month int) string</code> that returns a simplified zodiac sign: 1=\"Capricorn\", 2=\"Aquarius\", 3=\"Pisces\", 4=\"Aries\", 5=\"Taurus\", 6=\"Gemini\", 7=\"Cancer\", 8=\"Leo\", 9=\"Virgo\", 10=\"Libra\", 11=\"Scorpio\", 12=\"Sagittarius\". Default: \"Unknown\".",
            "hints": [
              "Switch on month number, one case per month"
            ],
            "solution": "func zodiac(month int) string {\n    switch month {\n    case 1:\n        return \"Capricorn\"\n    case 2:\n        return \"Aquarius\"\n    case 3:\n        return \"Pisces\"\n    case 4:\n        return \"Aries\"\n    case 5:\n        return \"Taurus\"\n    case 6:\n        return \"Gemini\"\n    case 7:\n        return \"Cancer\"\n    case 8:\n        return \"Leo\"\n    case 9:\n        return \"Virgo\"\n    case 10:\n        return \"Libra\"\n    case 11:\n        return \"Scorpio\"\n    case 12:\n        return \"Sagittarius\"\n    default:\n        return \"Unknown\"\n    }\n}"
          },
          {
            "id": "v13",
            "title": "File Type",
            "description": "Write <code>func fileType(ext string) string</code>: \".go\"=\"Go source\", \".py\"=\"Python source\", \".js\"=\"JavaScript source\", \".html\"=\"HTML document\", \".css\"=\"CSS stylesheet\", \".json\"=\"JSON data\". Default: \"Unknown type\".",
            "hints": [
              "Switch on the extension string including the dot"
            ],
            "solution": "func fileType(ext string) string {\n    switch ext {\n    case \".go\":\n        return \"Go source\"\n    case \".py\":\n        return \"Python source\"\n    case \".js\":\n        return \"JavaScript source\"\n    case \".html\":\n        return \"HTML document\"\n    case \".css\":\n        return \"CSS stylesheet\"\n    case \".json\":\n        return \"JSON data\"\n    default:\n        return \"Unknown type\"\n    }\n}"
          }
        ]
      }
    ],
    "challenges": [
      {
        "id": "challenge_1",
        "block": 1,
        "difficulty": 1,
        "concept": "Accumulator Pattern",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "range loops"
          },
          {
            "url": "https://go.dev/ref/spec#Arithmetic_operators",
            "title": "Go Spec: Arithmetic operators",
            "note": "+= syntax"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop and update a running result (sum/product/string).",
          "bestApproach": "Initialize the identity value once, then update per element; sometimes early-return is possible.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Sum of Slice",
            "description": "Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.",
            "functionSignature": "func sum(numbers []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "15"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "üí° Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func sum(numbers []int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Join Words",
            "description": "Write <code>func joinWords(words []string) string</code> that joins all words with spaces.",
            "functionSignature": "func joinWords(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"is\", \"fun\"}",
                "output": "\"go is fun\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "üí° Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func joinWords(words []string) string {\n    result := \"\"\n    for i, word := range words {\n        if i > 0 {\n            result += \" \"\n        }\n        result += word\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Total String Length",
            "description": "Write <code>func totalLength(words []string) int</code> that returns total length of all strings.",
            "functionSignature": "func totalLength(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"is\", \"fun\"}",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "As you process each element, you need to build up a result. What variable do you need to track this running total?"
              },
              {
                "title": "üí° Hint",
                "content": "Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with initial value (0 for sums, \"\" for strings)\n2. For each element:\n   - Combine element with accumulator\n3. Return accumulator</pre>"
              }
            ],
            "solution": "func totalLength(words []string) int {\n    total := 0\n    for _, word := range words {\n        total += len(word)\n    }\n    return total\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Product of Slice",
            "description": "Write <code>func product(nums []int) int</code> that returns the product of all numbers (multiply them together).",
            "functionSignature": "func product(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 4}",
                "output": "24"
              },
              {
                "input": "[]int{5, 2, 1}",
                "output": "10"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Like sum, but multiply. What should your starting value be? (Hint: not 0!)"
              },
              {
                "title": "üí° Hint",
                "content": "Start with result := 1 (identity for multiplication). Multiply each element into the accumulator."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with result := 1\n2. For each element:\n   - result *= element\n3. Return result</pre>"
              }
            ],
            "solution": "func product(nums []int) int {\n    result := 1\n    for _, n := range nums {\n        result *= n\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Running Balance",
            "description": "Write <code>func balance(transactions []int) int</code> where positive numbers are deposits, negative are withdrawals. Return final balance.",
            "functionSignature": "func balance(transactions []int) int",
            "testCases": [
              {
                "input": "[]int{100, -30, 50, -20}",
                "output": "100",
                "note": "100 - 30 + 50 - 20 = 100"
              },
              {
                "input": "[]int{-10, 20, -5}",
                "output": "5"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is just a sum! Positive and negative numbers handle themselves."
              },
              {
                "title": "üí° Hint",
                "content": "Start with balance := 0. Add each transaction (negatives will subtract automatically)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with balance := 0\n2. For each transaction:\n   - balance += transaction\n3. Return balance</pre>"
              }
            ],
            "solution": "func balance(transactions []int) int {\n    bal := 0\n    for _, t := range transactions {\n        bal += t\n    }\n    return bal\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Concat All",
            "description": "Write <code>func concatAll(words []string) string</code> that concatenates all strings with no separator.",
            "functionSignature": "func concatAll(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"a\", \"b\", \"c\"}",
                "output": "\"abc\""
              },
              {
                "input": "[]string{\"Go\", \"Lang\"}",
                "output": "\"GoLang\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Build up a string by adding each word to the end."
              },
              {
                "title": "üí° Hint",
                "content": "Start with result := \"\". For each word, result += word."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with result := \"\"\n2. For each word:\n   - result += word\n3. Return result</pre>"
              }
            ],
            "solution": "func concatAll(words []string) string {\n    result := \"\"\n    for _, w := range words {\n        result += w\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Sum of Squares",
            "difficulty": 2,
            "description": "Write <code>func sumOfSquares(nums []int) int</code> that returns the sum of the squares of all numbers. For example, [1, 2, 3] ‚Üí 1¬≤ + 2¬≤ + 3¬≤ = 14.",
            "functionSignature": "func sumOfSquares(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}",
                "output": "14",
                "note": "1¬≤ + 2¬≤ + 3¬≤ = 1 + 4 + 9 = 14"
              },
              {
                "input": "[]int{2, 4}",
                "output": "20",
                "note": "2¬≤ + 4¬≤ = 4 + 16 = 20"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is accumulator pattern, but you need to transform each element before adding it. How do you square a number in Go?"
              },
              {
                "title": "üí° Hint",
                "content": "Start with sum := 0. For each number, calculate its square (n * n) and add that to the sum."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. sum := 0\n2. For each num:\n   - square := num * num\n   - sum += square\n3. Return sum</pre>"
              }
            ],
            "solution": "func sumOfSquares(nums []int) int {\n    sum := 0\n    for _, n := range nums {\n        sum += n * n\n    }\n    return sum\n}"
          },
          {
            "id": "v8",
            "title": "Weighted Sum",
            "difficulty": 3,
            "description": "Write <code>func weightedSum(values []int, weights []int) int</code> that returns the sum of values[i] √É¬ó weights[i]. Assume both slices have the same length.",
            "functionSignature": "func weightedSum(values []int, weights []int) int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30}, []int{1, 2, 3}",
                "output": "140",
                "note": "10√É¬ó1 + 20√É¬ó2 + 30√É¬ó3 = 10 + 40 + 90 = 140"
              },
              {
                "input": "[]int{5, 5, 5}, []int{1, 2, 3}",
                "output": "30",
                "note": "5√É¬ó1 + 5√É¬ó2 + 5√É¬ó3 = 5 + 10 + 15 = 30"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You're working with TWO slices, but they have the same length. How do you access corresponding elements from both?"
              },
              {
                "title": "üí° Hint",
                "content": "You can use range with index: for i := range values. Then access values[i] and weights[i] to multiply them together."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. sum := 0\n2. For i from 0 to len(values):\n   - sum += values[i] * weights[i]\n3. Return sum</pre>"
              }
            ],
            "solution": "func weightedSum(values []int, weights []int) int {\n    sum := 0\n    for i := range values {\n        sum += values[i] * weights[i]\n    }\n    return sum\n}"
          },
          {
            "id": "v9",
            "title": "Alternating Sum",
            "difficulty": 2,
            "description": "Write <code>func alternatingSum(nums []int) int</code> that returns nums[0] - nums[1] + nums[2] - nums[3] + ... (alternate adding and subtracting).",
            "functionSignature": "func alternatingSum(nums []int) int",
            "testCases": [
              {
                "input": "[]int{10, 5, 3, 2}",
                "output": "6",
                "note": "10 - 5 + 3 - 2 = 6"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "2",
                "note": "1 - 2 + 3 = 2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "The operation alternates based on position. How can you tell if an index is even or odd?"
              },
              {
                "title": "üí° Hint",
                "content": "Use the index! Even indices (0, 2, 4...) are added, odd indices (1, 3, 5...) are subtracted. Check i % 2 == 0."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. sum := 0\n2. For i, num in enumerate:\n   - If i is even: sum += num\n   - If i is odd: sum -= num\n3. Return sum</pre>"
              }
            ],
            "solution": "func alternatingSum(nums []int) int {\n    sum := 0\n    for i, n := range nums {\n        if i%2 == 0 {\n            sum += n\n        } else {\n            sum -= n\n        }\n    }\n    return sum\n}"
          },
          {
            "id": "v10",
            "title": "Total Revenue",
            "description": "Write <code>func totalRevenue(sales []float64, taxRate float64) float64</code> that sums all sales including tax.",
            "functionSignature": "func totalRevenue(sales []float64, taxRate float64) float64",
            "testCases": [
              {
                "input": "[]float64{100.0, 200.0, 50.0}, 0.08",
                "output": "378.0",
                "note": "350 * 1.08"
              },
              {
                "input": "[]float64{25.0, 75.0}, 0.10",
                "output": "110.0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "First sum all sales, then add tax to the total: total * (1 + taxRate)."
              },
              {
                "title": "üí° Hint",
                "content": "Accumulate sum, then multiply by (1 + taxRate) at the end."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. sum := 0.0\n2. For each sale:\n   - sum += sale\n3. Return sum * (1 + taxRate)</pre>"
              }
            ],
            "solution": "func totalRevenue(sales []float64, taxRate float64) float64 {\n    sum := 0.0\n    for _, sale := range sales {\n        sum += sale\n    }\n    return sum * (1 + taxRate)\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Dice Total",
            "description": "Write <code>func diceTotal(rolls []int) int</code> that sums dice rolls and returns -1 if any roll is invalid (not 1-6).",
            "functionSignature": "func diceTotal(rolls []int) int",
            "testCases": [
              {
                "input": "[]int{6, 3, 4, 2}",
                "output": "15"
              },
              {
                "input": "[]int{6, 7, 4}",
                "output": "-1",
                "note": "7 is invalid"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check validity while accumulating. If any roll is outside 1-6, return -1 immediately."
              },
              {
                "title": "üí° Hint",
                "content": "As you sum, check each roll. Use early return for invalid rolls."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. sum := 0\n2. For each roll:\n   - roll < 1 OR roll > 6? ‚Üí return -1\n   - sum += roll\n3. Return sum</pre>"
              }
            ],
            "solution": "func diceTotal(rolls []int) int {\n    sum := 0\n    for _, roll := range rolls {\n        if roll < 1 || roll > 6 { return -1 }\n        sum += roll\n    }\n    return sum\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Compound Interest",
            "description": "Write <code>func compoundInterest(deposits []float64, rate float64) float64</code> that calculates compound interest where each deposit earns interest at rate (as decimal) per period. Process deposits in order, adding interest to running balance before adding next deposit.",
            "functionSignature": "func compoundInterest(deposits []float64, rate float64) float64",
            "testCases": [
              {
                "input": "[]float64{100.0, 100.0}, 0.10",
                "output": "221.0",
                "note": "Period 1: 100. Period 2: 100*1.1 + 100 = 210. Final: 210*1.1 = 231 (approx)"
              },
              {
                "input": "[]float64{1000.0}, 0.05",
                "output": "1050.0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Each period, you apply interest to the current balance, then add the new deposit."
              },
              {
                "title": "üí° Hint",
                "content": "Keep a running balance. For each deposit: balance = balance * (1 + rate), then balance += deposit."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. balance := 0.0\n2. For each deposit:\n   - balance *= (1 + rate)\n   - balance += deposit\n3. Return balance</pre>"
              }
            ],
            "solution": "func compoundInterest(deposits []float64, rate float64) float64 {\n    balance := 0.0\n    for _, deposit := range deposits {\n        balance = balance * (1 + rate)\n        balance += deposit\n    }\n    return balance\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Running Max Product",
            "description": "Write <code>func runningMaxProduct(nums []int) []int</code> that returns a slice where each element is the maximum product of any two consecutive elements seen so far (including current position).",
            "functionSignature": "func runningMaxProduct(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[]int{0, 2, 6, 12}",
                "note": "Position 0: no pair (0), Pos 1: max(1*2)=2, Pos 2: max(1*2, 2*3)=6, Pos 3: max(1*2, 2*3, 3*4)=12"
              },
              {
                "input": "[]int{5, 1, 3, 2}",
                "output": "[]int{0, 5, 5, 6}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "At each position, you need to track the maximum product of consecutive pairs seen up to that point."
              },
              {
                "title": "üí° Hint",
                "content": "Keep track of maxProduct as you go. At position i, calculate nums[i-1]*nums[i] and update maxProduct if it's larger."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []int{0}, maxProduct := 0\n2. For i from 1 to len:\n   - product := nums[i-1] * nums[i]\n   - if product > maxProduct: maxProduct = product\n   - append maxProduct to result\n3. Return result</pre>"
              }
            ],
            "solution": "func runningMaxProduct(nums []int) []int {\n    result := []int{0}\n    maxProduct := 0\n    for i := 1; i < len(nums); i++ {\n        product := nums[i-1] * nums[i]\n        if product > maxProduct {\n            maxProduct = product\n        }\n        result = append(result, maxProduct)\n    }\n    return result\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_2",
        "block": 1,
        "difficulty": 1,
        "concept": "Conditional Counter",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#If_statements",
            "title": "Go Spec: If statements",
            "note": "conditionals"
          },
          {
            "url": "https://go.dev/ref/spec#Arithmetic_operators",
            "title": "Go Spec: Arithmetic operators",
            "note": "% modulo operator"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through, check condition for each element, increment counter.",
          "bestApproach": "Same approach - this is already optimal! Just loop once and count matches.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Evens",
            "description": "Write <code>func countEvens(nums []int) int</code> that counts even numbers.",
            "functionSignature": "func countEvens(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "üí° Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? ‚Üí increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num%2 == 0 {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Count Negatives",
            "description": "Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.",
            "functionSignature": "func countNegatives(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-1, 2, -3, 4}",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "üí° Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? ‚Üí increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countNegatives(nums []int) int {\n    count := 0\n    for _, num := range nums {\n        if num < 0 {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Count Passing Scores",
            "description": "Write <code>func countPassing(scores []int, threshold int) int</code> that counts scores >= threshold.",
            "functionSignature": "func countPassing(scores []int, threshold int) int",
            "testCases": [
              {
                "input": "[]int{55, 72, 68, 90, 45}, 60",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?"
              },
              {
                "title": "üí° Hint",
                "content": "Start a counter at 0. For each element, check your condition - if true, increment the counter."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start counter at 0\n2. For each element:\n   - Meets condition? ‚Üí increment counter\n3. Return counter</pre>"
              }
            ],
            "solution": "func countPassing(scores []int, threshold int) int {\n    count := 0\n    for _, score := range scores {\n        if score >= threshold {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Count Divisible By",
            "description": "Write <code>func countDivisible(nums []int, d int) int</code> that counts numbers divisible by d.",
            "functionSignature": "func countDivisible(nums []int, d int) int",
            "testCases": [
              {
                "input": "[]int{3, 6, 7, 9, 12}, 3",
                "output": "4",
                "note": "3, 6, 9, 12 are divisible by 3"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "How do you check if a number is divisible by another? What operation gives you the remainder?"
              },
              {
                "title": "üí° Hint",
                "content": "Use the modulo operator: num % d == 0 means num is divisible by d."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num % d == 0? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countDivisible(nums []int, d int) int {\n    count := 0\n    for _, n := range nums {\n        if n % d == 0 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Count Long Words",
            "description": "Write <code>func countLongWords(words []string, minLen int) int</code> that counts words with length >= minLen.",
            "functionSignature": "func countLongWords(words []string, minLen int) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\", \"rust\", \"c\"}, 4",
                "output": "2",
                "note": "python and rust have len >= 4"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\"}, 2",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Same counting pattern, just checking string length instead of numeric value."
              },
              {
                "title": "üí° Hint",
                "content": "Use len(word) >= minLen as your condition."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - len(word) >= minLen? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countLongWords(words []string, minLen int) int {\n    count := 0\n    for _, w := range words {\n        if len(w) >= minLen { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Count In Range",
            "description": "Write <code>func countInRange(nums []int, min, max int) int</code> that counts numbers where min <= num <= max.",
            "functionSignature": "func countInRange(nums []int, min, max int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 15, 20}, 5, 15",
                "output": "3",
                "note": "5, 10, 15 are in range"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2, 4",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to check TWO conditions: num >= min AND num <= max."
              },
              {
                "title": "üí° Hint",
                "content": "Combine conditions with &&: if num >= min && num <= max."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num >= min && num <= max? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countInRange(nums []int, min, max int) int {\n    count := 0\n    for _, n := range nums {\n        if n >= min && n <= max { count++ }\n    }\n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Count Prime Numbers",
            "difficulty": 3,
            "description": "Write <code>func countPrimes(nums []int) int</code> that counts how many prime numbers are in the slice. A prime number is greater than 1 and only divisible by 1 and itself.",
            "functionSignature": "func countPrimes(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 4, 5, 6, 7}",
                "output": "4",
                "note": "2, 3, 5, 7 are prime"
              },
              {
                "input": "[]int{1, 4, 6, 8, 9}",
                "output": "0",
                "note": "No primes"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Checking if a number is prime requires nested logic. For each number, you need to check if any number from 2 to n-1 divides it evenly."
              },
              {
                "title": "üí° Hint",
                "content": "Create a helper function isPrime(n int) bool. A number is prime if it's > 1 and no number from 2 to sqrt(n) divides it evenly. Then count how many numbers pass the isPrime test."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - If isPrime(num): count++\n3. Return count\n\nisPrime(n):\n  - If n <= 1: return false\n  - For i from 2 to sqrt(n):\n    - If n % i == 0: return false\n  - return true</pre>"
              }
            ],
            "solution": "func countPrimes(nums []int) int {\n    count := 0\n    for _, n := range nums {\n        if isPrime(n) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v8",
            "title": "Count Words Starting With Vowel",
            "difficulty": 2,
            "description": "Write <code>func countVowelStart(words []string) int</code> that counts how many words start with a vowel (a, e, i, o, u). Use lowercase comparison.",
            "functionSignature": "func countVowelStart(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"apple\", \"banana\", \"orange\", \"grape\"}",
                "output": "2",
                "note": "apple and orange start with vowels"
              },
              {
                "input": "[]string{\"Go\", \"is\", \"awesome\"}",
                "output": "2",
                "note": "is and awesome start with vowels"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to check the first character of each word. How do you get the first character, and how do you check if it's in the set {a, e, i, o, u}?"
              },
              {
                "title": "üí° Hint",
                "content": "Use strings.ToLower() to convert to lowercase, then check if word[0] is one of the vowel bytes. You can use multiple OR conditions, or create a helper function."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - Get first character (lowercase)\n   - If it's a, e, i, o, or u: count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countVowelStart(words []string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) > 0 {\n            first := strings.ToLower(string(word[0]))\n            if first == \"a\" || first == \"e\" || first == \"i\" || first == \"o\" || first == \"u\" {\n                count++\n            }\n        }\n    }\n    return count\n}"
          },
          {
            "id": "v9",
            "title": "Three Letter Words",
            "description": "Write <code>func threeLetterWords(words []string) int</code> that counts words with exactly 3 letters.",
            "functionSignature": "func threeLetterWords(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"cat\", \"dog\", \"elephant\", \"bat\"}",
                "output": "3"
              },
              {
                "input": "[]string{\"hello\", \"world\"}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Count words where len(word) == 3."
              },
              {
                "title": "üí° Hint",
                "content": "Simple counter with condition: if len(word) == 3, count++"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - len(word) == 3? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func threeLetterWords(words []string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) == 3 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Temperature Extremes",
            "description": "Write <code>func tempExtremes(temps []int) int</code> that counts how many temps are below 0 or above 100.",
            "functionSignature": "func tempExtremes(temps []int) int",
            "testCases": [
              {
                "input": "[]int{-5, 50, 105, 25, -10}",
                "output": "3"
              },
              {
                "input": "[]int{20, 30, 40}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Count temperatures that are < 0 OR > 100."
              },
              {
                "title": "üí° Hint",
                "content": "if temp < 0 || temp > 100, increment count."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each temp:\n   - temp < 0 OR temp > 100? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func tempExtremes(temps []int) int {\n    count := 0\n    for _, temp := range temps {\n        if temp < 0 || temp > 100 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Count By Multiple Criteria",
            "description": "Write <code>func countByCriteria(words []string, minLen, maxLen int, mustContain string) int</code> that counts words where length is between minLen and maxLen (inclusive) AND the word contains the substring mustContain.",
            "functionSignature": "func countByCriteria(words []string, minLen, maxLen int, mustContain string) int",
            "testCases": [
              {
                "input": "[\"hello\", \"world\", \"hi\", \"help\"], 4, 6, \"el\"",
                "output": "2",
                "note": "hello and help both have length 4-5 and contain 'el'"
              },
              {
                "input": "[\"go\", \"gopher\", \"golang\", \"rust\"], 2, 6, \"go\"",
                "output": "3",
                "note": "go, gopher, golang all contain 'go' and fit length constraint"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to check THREE conditions for each word: minimum length, maximum length, and contains substring. Use strings.Contains() to check for substring."
              },
              {
                "title": "üí° Hint",
                "content": "Import strings package. For each word, check: len(word) >= minLen AND len(word) <= maxLen AND strings.Contains(word, mustContain). Only count if all three are true."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - length in range? AND\n   - contains substring?\n   - Both true? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countByCriteria(words []string, minLen, maxLen int, mustContain string) int {\n    count := 0\n    for _, word := range words {\n        if len(word) >= minLen && len(word) <= maxLen && strings.Contains(word, mustContain) {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Valid Pairs",
            "description": "Write <code>func countValidPairs(nums []int, targetSum int) int</code> that counts how many pairs of adjacent elements sum to targetSum.",
            "functionSignature": "func countValidPairs(nums []int, targetSum int) int",
            "testCases": [
              {
                "input": "[]int{1, 4, 3, 2, 5}, 5",
                "output": "2",
                "note": "pairs (1,4) and (3,2) both sum to 5"
              },
              {
                "input": "[]int{2, 3, 2, 3}, 5",
                "output": "3",
                "note": "all three adjacent pairs (2,3), (3,2), (2,3) sum to 5"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to look at each pair of consecutive elements. For position i, check if nums[i] + nums[i+1] equals targetSum."
              },
              {
                "title": "üí° Hint",
                "content": "Loop from i=0 to len(nums)-2 (so i+1 is valid). For each i, check if nums[i] + nums[i+1] == targetSum."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For i from 0 to len-2:\n   - nums[i] + nums[i+1] == target?\n   - Yes ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countValidPairs(nums []int, targetSum int) int {\n    count := 0\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] + nums[i+1] == targetSum {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Count Pattern Match",
            "description": "Write <code>func countPatternMatch(words []string, prefix, suffix string) int</code> that counts words that start with prefix AND end with suffix.",
            "functionSignature": "func countPatternMatch(words []string, prefix, suffix string) int",
            "testCases": [
              {
                "input": "[\"hello\", \"hero\", \"hermit\", \"world\"], \"he\", \"o\"",
                "output": "2",
                "note": "hello and hero both start with 'he' and end with 'o'"
              },
              {
                "input": "[\"testing\", \"resting\", \"test\", \"ing\"], \"test\", \"ing\"",
                "output": "1",
                "note": "only 'testing' starts with 'test' and ends with 'ing'"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Use strings.HasPrefix() and strings.HasSuffix() to check both ends of each word. Count only if both conditions are true."
              },
              {
                "title": "üí° Hint",
                "content": "Import strings package. For each word: if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix), increment count."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - starts with prefix? AND\n   - ends with suffix?\n   - Both true? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countPatternMatch(words []string, prefix, suffix string) int {\n    count := 0\n    for _, word := range words {\n        if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix) {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 3
          },
          {
            "id": "v14",
            "title": "Count Words Starting With Letter",
            "description": "Write <code>func countStartsWith(words []string, letter rune) int</code> that counts words starting with the given letter (case-insensitive).",
            "functionSignature": "func countStartsWith(words []string, letter rune) int",
            "testCases": [
              {
                "input": "[\"Hello\", \"world\", \"Hi\"], 'h'",
                "output": "2",
                "note": "Hello and Hi start with h (case-insensitive)"
              },
              {
                "input": "[\"Go\", \"Python\", \"Rust\", \"Go\"], 'g'",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check the first character of each word. Convert both to lowercase for case-insensitive comparison."
              },
              {
                "title": "üí° Hint",
                "content": "Use strings.ToLower() on the first character. Get first rune with rune(word[0]) if word is non-empty."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each word:\n   - Get first letter (lowercase)\n   - Matches target letter? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc countStartsWith(words []string, letter rune) int {\n    count := 0\n    targetLower := strings.ToLower(string(letter))\n    \n    for _, word := range words {\n        if len(word) > 0 {\n            firstLetter := strings.ToLower(string(word[0]))\n            if firstLetter == targetLower {\n                count++\n            }\n        }\n    }\n    \n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v15",
            "title": "Count Between (Exclusive)",
            "description": "Write <code>func countBetween(nums []int, low, high int) int</code> that counts numbers strictly between low and high (exclusive on both ends: low < num < high).",
            "functionSignature": "func countBetween(nums []int, low, high int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 15, 20}, 5, 15",
                "output": "1",
                "note": "only 10 is strictly between 5 and 15"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 1, 5",
                "output": "3",
                "note": "2, 3, 4 are between 1 and 5 (exclusive)"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Exclusive means not including the boundaries. Check num > low AND num < high (not >= or <=)."
              },
              {
                "title": "üí° Hint",
                "content": "Use strict inequality: if num > low && num < high, count it."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num > low AND num < high? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countBetween(nums []int, low, high int) int {\n    count := 0\n    for _, num := range nums {\n        if num > low && num < high {\n            count++\n        }\n    }\n    return count\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_3",
        "block": 1,
        "difficulty": 1,
        "concept": "Branching Logic",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#If_statements",
            "title": "Go Spec: If statements",
            "note": "else-if chains"
          },
          {
            "url": "https://go.dev/ref/spec#Comparison_operators",
            "title": "Go Spec: Comparison operators",
            "note": ">=, <, == etc."
          }
        ],
        "variants": [
          {
            "id": "v1",
            "title": "FizzBuzz",
            "description": "Print 1-20. Multiples of 3: \"Fizz\", 5: \"Buzz\", both: \"FizzBuzz\".",
            "functionSignature": "// loop",
            "testCases": [
              {
                "input": "15",
                "output": "FizzBuzz"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?"
              },
              {
                "title": "üí° Hint",
                "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Check most specific condition first\n2. Then check less specific conditions\n3. Default case last\n(Order matters: check \"both 3 AND 5\" before \"just 3\" or \"just 5\")</pre>"
              }
            ],
            "solution": "for i := 1; i <= 20; i++ {\n    if i%15 == 0 {\n        fmt.Println(\"FizzBuzz\")\n    } else if i%3 == 0 {\n        fmt.Println(\"Fizz\")\n    } else if i%5 == 0 {\n        fmt.Println(\"Buzz\")\n    } else {\n        fmt.Println(i)\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v2",
            "title": "Grade Classifier",
            "description": "Write <code>func grade(score int) string</code> returning A/B/C/D/F.",
            "functionSignature": "func grade(score int) string",
            "testCases": [
              {
                "input": "85",
                "output": "\"B\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?"
              },
              {
                "title": "üí° Hint",
                "content": "Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Check most specific condition first\n2. Then check less specific conditions\n3. Default case last\n(Order matters: check \"both 3 AND 5\" before \"just 3\" or \"just 5\")</pre>"
              }
            ],
            "solution": "func grade(score int) string {\n    if score >= 90 { return \"A\" }\n    if score >= 80 { return \"B\" }\n    if score >= 70 { return \"C\" }\n    if score >= 60 { return \"D\" }\n    return \"F\"\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Age Category",
            "description": "Write <code>func ageCategory(age int) string</code> returning \"infant\" (0-1), \"toddler\" (2-3), \"child\" (4-12), \"teen\" (13-19), or \"adult\" (20+).",
            "functionSignature": "func ageCategory(age int) string",
            "testCases": [
              {
                "input": "15",
                "output": "\"teen\""
              },
              {
                "input": "2",
                "output": "\"toddler\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "When you have multiple age ranges to check, what order should you check them in to avoid incorrect matches?"
              },
              {
                "title": "üí° Hint",
                "content": "Check ranges in ascending order using upper bounds. If age <= 1, it's infant. If age <= 3, it's toddler. And so on."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Check ranges in order from youngest to oldest\n2. Use upper bounds (<=) for each category\n3. Default to \"adult\" for 20+</pre>"
              }
            ],
            "solution": "func ageCategory(age int) string {\n    if age <= 1 { return \"infant\" }\n    if age <= 3 { return \"toddler\" }\n    if age <= 12 { return \"child\" }\n    if age <= 19 { return \"teen\" }\n    return \"adult\"\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Number Sign",
            "description": "Write <code>func sign(n int) string</code> returning \"positive\", \"negative\", or \"zero\".",
            "functionSignature": "func sign(n int) string",
            "testCases": [
              {
                "input": "5",
                "output": "\"positive\""
              },
              {
                "input": "-3",
                "output": "\"negative\""
              },
              {
                "input": "0",
                "output": "\"zero\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Three cases: greater than 0, less than 0, or equal to 0."
              },
              {
                "title": "üí° Hint",
                "content": "Check n > 0, then n < 0, else it's zero."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if n > 0 { return \"positive\" }\nif n < 0 { return \"negative\" }\nreturn \"zero\"</pre>"
              }
            ],
            "solution": "func sign(n int) string {\n    if n > 0 { return \"positive\" }\n    if n < 0 { return \"negative\" }\n    return \"zero\"\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Ticket Price",
            "description": "Write <code>func ticketPrice(age int) int</code>: children (0-12) pay 5, teens (13-17) pay 8, adults (18-64) pay 12, seniors (65+) pay 7.",
            "functionSignature": "func ticketPrice(age int) int",
            "testCases": [
              {
                "input": "10",
                "output": "5"
              },
              {
                "input": "15",
                "output": "8"
              },
              {
                "input": "30",
                "output": "12"
              },
              {
                "input": "70",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Multiple age ranges with different prices. Check from youngest to oldest."
              },
              {
                "title": "üí° Hint",
                "content": "Use if-else chain checking upper bounds: <= 12, <= 17, <= 64, else senior."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if age <= 12 { return 5 }\nif age <= 17 { return 8 }\nif age <= 64 { return 12 }\nreturn 7</pre>"
              }
            ],
            "solution": "func ticketPrice(age int) int {\n    if age <= 12 { return 5 }\n    if age <= 17 { return 8 }\n    if age <= 64 { return 12 }\n    return 7\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Shipping Cost",
            "description": "Write <code>func shippingCost(weight int) int</code>: 0-1kg costs 5, 2-5kg costs 10, 6-10kg costs 20, over 10kg costs 50.",
            "functionSignature": "func shippingCost(weight int) int",
            "testCases": [
              {
                "input": "1",
                "output": "5"
              },
              {
                "input": "3",
                "output": "10"
              },
              {
                "input": "8",
                "output": "20"
              },
              {
                "input": "15",
                "output": "50"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Multiple weight brackets. Check from lightest to heaviest."
              },
              {
                "title": "üí° Hint",
                "content": "Check upper bounds: <= 1, <= 5, <= 10, else heavy."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if weight <= 1 { return 5 }\nif weight <= 5 { return 10 }\nif weight <= 10 { return 20 }\nreturn 50</pre>"
              }
            ],
            "solution": "func shippingCost(weight int) int {\n    if weight <= 1 { return 5 }\n    if weight <= 5 { return 10 }\n    if weight <= 10 { return 20 }\n    return 50\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Tax Bracket Calculator",
            "difficulty": 3,
            "description": "Write <code>func calculateTax(income int) int</code>. Tax brackets: 0-10k: 0%, 10k-50k: 10%, 50k-100k: 20%, 100k+: 30%. Calculate progressive tax (each bracket taxed at its rate).",
            "functionSignature": "func calculateTax(income int) int",
            "testCases": [
              {
                "input": "15000",
                "output": "500",
                "note": "First 10k: 0, next 5k at 10% = 500"
              },
              {
                "input": "60000",
                "output": "6000",
                "note": "10k@0% + 40k@10% + 10k@20% = 0 + 4000 + 2000 = 6000"
              },
              {
                "input": "5000",
                "output": "0",
                "note": "All in 0% bracket"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is NOT a simple if-else! Each bracket taxes only the portion of income in that range. Someone earning 60k pays 10% on the middle 40k, not on all 60k."
              },
              {
                "title": "üí° Hint",
                "content": "Calculate tax bracket by bracket. For each bracket, determine how much income falls in it (min of remaining income and bracket size), multiply by rate, add to total tax."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. tax := 0, remaining := income\n2. First bracket (0-10k at 0%):\n   - amount = min(remaining, 10000)\n   - tax += amount * 0.0\n   - remaining -= amount\n3. Repeat for each bracket\n4. Return tax</pre>"
              }
            ],
            "solution": "func calculateTax(income int) int {\n    if income <= 10000 {\n        return 0\n    }\n    tax := 0\n    if income > 10000 {\n        taxable := income - 10000\n        if taxable > 40000 {\n            taxable = 40000\n        }\n        tax += taxable * 10 / 100\n    }\n    if income > 50000 {\n        taxable := income - 50000\n        if taxable > 50000 {\n            taxable = 50000\n        }\n        tax += taxable * 20 / 100\n    }\n    if income > 100000 {\n        tax += (income - 100000) * 30 / 100\n    }\n    return tax\n}"
          },
          {
            "id": "v8",
            "title": "Rock Paper Scissors",
            "difficulty": 2,
            "description": "Write <code>func rps(p1, p2 string) string</code> that takes \"rock\", \"paper\", or \"scissors\" and returns \"p1\", \"p2\", or \"tie\".",
            "functionSignature": "func rps(p1, p2 string) string",
            "testCases": [
              {
                "input": "\"rock\", \"scissors\"",
                "output": "\"p1\"",
                "note": "Rock beats scissors"
              },
              {
                "input": "\"paper\", \"rock\"",
                "output": "\"p1\"",
                "note": "Paper beats rock"
              },
              {
                "input": "\"rock\", \"rock\"",
                "output": "\"tie\""
              },
              {
                "input": "\"scissors\", \"paper\"",
                "output": "\"p1\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "There are 9 possible combinations (3√É¬ó3), but some simplify. Check for tie first, then you have 6 win cases to check."
              },
              {
                "title": "üí° Hint",
                "content": "First check if p1 == p2 (tie). Then check the three cases where p1 wins: (rock, scissors), (paper, rock), (scissors, paper). Otherwise p2 wins."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. If p1 == p2: return \"tie\"\n2. If (p1==rock && p2==scissors) OR\n      (p1==paper && p2==rock) OR\n      (p1==scissors && p2==paper):\n      return \"p1\"\n3. Else: return \"p2\"</pre>"
              }
            ],
            "solution": "func rps(p1, p2 string) string {\n    if p1 == p2 {\n        return \"tie\"\n    }\n    if (p1 == \"rock\" && p2 == \"scissors\") ||\n       (p1 == \"paper\" && p2 == \"rock\") ||\n       (p1 == \"scissors\" && p2 == \"paper\") {\n        return \"p1\"\n    }\n    return \"p2\"\n}"
          },
          {
            "id": "v9",
            "title": "Rating Categories",
            "description": "Write <code>func ratingCategory(rating int) string</code>: \"Poor\" (0-2), \"Fair\" (3-5), \"Good\" (6-8), \"Excellent\" (9-10).",
            "functionSignature": "func ratingCategory(rating int) string",
            "testCases": [
              {
                "input": "8",
                "output": "\"Good\""
              },
              {
                "input": "10",
                "output": "\"Excellent\""
              },
              {
                "input": "1",
                "output": "\"Poor\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Use if-else chain to check ranges. Order matters - check highest first or use <= appropriately."
              },
              {
                "title": "üí° Hint",
                "content": "if rating <= 2 return \"Poor\", else if rating <= 5 return \"Fair\", etc."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if rating <= 2: Poor\nelse if rating <= 5: Fair\nelse if rating <= 8: Good\nelse: Excellent</pre>"
              }
            ],
            "solution": "func ratingCategory(rating int) string {\n    if rating <= 2 { return \"Poor\" }\n    if rating <= 5 { return \"Fair\" }\n    if rating <= 8 { return \"Good\" }\n    return \"Excellent\"\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Message Priority",
            "description": "Write <code>func messagePriority(msg string) string</code>: \"URGENT\" if contains \"ASAP\", \"High\" if starts with \"Important\", else \"Normal\".",
            "functionSignature": "func messagePriority(msg string) string",
            "testCases": [
              {
                "input": "\"Please reply ASAP\"",
                "output": "\"URGENT\""
              },
              {
                "input": "\"Important meeting tomorrow\"",
                "output": "\"High\""
              },
              {
                "input": "\"Hello there\"",
                "output": "\"Normal\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check for \"ASAP\" first (most urgent), then check prefix, otherwise default to Normal."
              },
              {
                "title": "üí° Hint",
                "content": "Use strings.Contains() for ASAP, strings.HasPrefix() for Important."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if contains \"ASAP\": URGENT\nelse if starts with \"Important\": High\nelse: Normal</pre>"
              }
            ],
            "solution": "func messagePriority(msg string) string {\n    if strings.Contains(msg, \"ASAP\") { return \"URGENT\" }\n    if strings.HasPrefix(msg, \"Important\") { return \"High\" }\n    return \"Normal\"\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "BMI Category",
            "description": "Write <code>func bmiCategory(bmi float64) string</code> returning \"Underweight\" (bmi < 18.5), \"Normal\" (18.5-24.9), \"Overweight\" (25-29.9), or \"Obese\" (30+).",
            "functionSignature": "func bmiCategory(bmi float64) string",
            "testCases": [
              {
                "input": "22.5",
                "output": "\"Normal\""
              },
              {
                "input": "17.0",
                "output": "\"Underweight\""
              },
              {
                "input": "31.5",
                "output": "\"Obese\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Multiple ranges to check. What order should you check them to avoid incorrect matches?"
              },
              {
                "title": "üí° Hint",
                "content": "Check from lowest to highest using upper bounds: if bmi < 18.5, if bmi < 25, if bmi < 30, else."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if bmi < 18.5 { return \"Underweight\" }\nif bmi < 25 { return \"Normal\" }\nif bmi < 30 { return \"Overweight\" }\nreturn \"Obese\"</pre>"
              }
            ],
            "solution": "func bmiCategory(bmi float64) string {\n    if bmi < 18.5 { return \"Underweight\" }\n    if bmi < 25 { return \"Normal\" }\n    if bmi < 30 { return \"Overweight\" }\n    return \"Obese\"\n}",
            "difficulty": 1
          },
          {
            "id": "v12",
            "title": "Water State",
            "description": "Write <code>func waterState(temp int) string</code> returning \"ice\" (temp <= 0), \"water\" (1-99), or \"steam\" (temp >= 100). Temperatures in Celsius.",
            "functionSignature": "func waterState(temp int) string",
            "testCases": [
              {
                "input": "25",
                "output": "\"water\""
              },
              {
                "input": "-5",
                "output": "\"ice\""
              },
              {
                "input": "100",
                "output": "\"steam\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Three states with specific temperature boundaries. What's the cleanest order to check them?"
              },
              {
                "title": "üí° Hint",
                "content": "Check boundaries in order: if temp <= 0 (ice), else if temp >= 100 (steam), else (water)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if temp <= 0 { return \"ice\" }\nif temp >= 100 { return \"steam\" }\nreturn \"water\"</pre>"
              }
            ],
            "solution": "func waterState(temp int) string {\n    if temp <= 0 { return \"ice\" }\n    if temp >= 100 { return \"steam\" }\n    return \"water\"\n}",
            "difficulty": 1
          },
          {
            "id": "v13",
            "title": "Discount Calculator",
            "description": "Write <code>func discount(price int, isPremium bool, quantity int) int</code>. Premium members get 20% off. Non-premium get 10% off if quantity >= 5, else no discount. Return final price.",
            "functionSignature": "func discount(price int, isPremium bool, quantity int) int",
            "testCases": [
              {
                "input": "100, true, 1",
                "output": "80",
                "note": "Premium: 20% off"
              },
              {
                "input": "100, false, 6",
                "output": "90",
                "note": "Non-premium bulk: 10% off"
              },
              {
                "input": "100, false, 3",
                "output": "100",
                "note": "Non-premium small: no discount"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Multiple conditions that interact: membership status AND quantity. Check premium first since it's simpler."
              },
              {
                "title": "üí° Hint",
                "content": "if isPremium ‚Üí 20% off. else if quantity >= 5 ‚Üí 10% off. else ‚Üí no discount."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if isPremium { return price * 80 / 100 }\nif quantity >= 5 { return price * 90 / 100 }\nreturn price</pre>"
              }
            ],
            "solution": "func discount(price int, isPremium bool, quantity int) int {\n    if isPremium { return price * 80 / 100 }\n    if quantity >= 5 { return price * 90 / 100 }\n    return price\n}",
            "difficulty": 1
          },
          {
            "id": "v14",
            "title": "Categorize Numbers",
            "description": "Write <code>func categorizeNumbers(nums []int) map[string][]int</code> that categorizes numbers into \"small\" (<10), \"medium\" (10-99), or \"large\" (>=100). Returns a map where keys are categories and values are slices of numbers in that category.",
            "functionSignature": "func categorizeNumbers(nums []int) map[string][]int",
            "testCases": [
              {
                "input": "[]int{5, 15, 150, 8, 25, 200}",
                "output": "map[\"small\":[5, 8] \"medium\":[15, 25] \"large\":[150, 200]]"
              },
              {
                "input": "[]int{1, 10, 100}",
                "output": "map[\"small\":[1] \"medium\":[10] \"large\":[100]]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Create a map where each category name maps to a slice of integers. For each number, determine which category it belongs to and append it to that category's slice."
              },
              {
                "title": "üí° Hint",
                "content": "Initialize map with three empty slices. Use if-else to check: num < 10, num < 100, else. Append to the appropriate slice."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create map[string][]int\n2. For each num:\n   - num < 10? ‚Üí append to \"small\"\n   - num < 100? ‚Üí append to \"medium\"\n   - else ‚Üí append to \"large\"\n3. Return map</pre>"
              }
            ],
            "solution": "func categorizeNumbers(nums []int) map[string][]int {\n    categories := map[string][]int{\n        \"small\": {},\n        \"medium\": {},\n        \"large\": {},\n    }\n    \n    for _, num := range nums {\n        if num < 10 {\n            categories[\"small\"] = append(categories[\"small\"], num)\n        } else if num < 100 {\n            categories[\"medium\"] = append(categories[\"medium\"], num)\n        } else {\n            categories[\"large\"] = append(categories[\"large\"], num)\n        }\n    }\n    \n    return categories\n}",
            "difficulty": 3
          },
          {
            "id": "v15",
            "title": "Score to Grade with Plus/Minus",
            "description": "Write <code>func scoreToGradePlus(score int) string</code> that converts a score to a letter grade with +/- modifiers. A+ (97-100), A (93-96), A- (90-92), B+ (87-89), B (83-86), B- (80-82), etc. Below 60 is F.",
            "functionSignature": "func scoreToGradePlus(score int) string",
            "testCases": [
              {
                "input": "98",
                "output": "\"A+\""
              },
              {
                "input": "85",
                "output": "\"B\""
              },
              {
                "input": "72",
                "output": "\"C-\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need precise range checking for 12 different grade levels. Start from the top (100) and work down with else-if chains."
              },
              {
                "title": "üí° Hint",
                "content": "Check score >= 97 for A+, >= 93 for A, >= 90 for A-, >= 87 for B+, and so on. Each check needs exact boundaries."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if score >= 97 { return \"A+\" }\nif score >= 93 { return \"A\" }\nif score >= 90 { return \"A-\" }\n... continue pattern ...\nreturn \"F\"</pre>"
              }
            ],
            "solution": "func scoreToGradePlus(score int) string {\n    if score >= 97 { return \"A+\" }\n    if score >= 93 { return \"A\" }\n    if score >= 90 { return \"A-\" }\n    if score >= 87 { return \"B+\" }\n    if score >= 83 { return \"B\" }\n    if score >= 80 { return \"B-\" }\n    if score >= 77 { return \"C+\" }\n    if score >= 73 { return \"C\" }\n    if score >= 70 { return \"C-\" }\n    if score >= 67 { return \"D+\" }\n    if score >= 63 { return \"D\" }\n    if score >= 60 { return \"D-\" }\n    return \"F\"\n}",
            "difficulty": 3
          },
          {
            "id": "v16",
            "title": "Calculate Shipping Cost",
            "description": "Write <code>func calculateShipping(weight float64, distance int, isPriority bool) float64</code> that calculates shipping cost. Base cost = weight * 0.5 + distance * 0.1. If isPriority, multiply total by 1.5. If weight > 50, add $10. If distance > 1000, add $20.",
            "functionSignature": "func calculateShipping(weight float64, distance int, isPriority bool) float64",
            "testCases": [
              {
                "input": "30.0, 500, false",
                "output": "65.0",
                "note": "30*0.5 + 500*0.1 = 15 + 50 = 65"
              },
              {
                "input": "60.0, 1200, true",
                "output": "247.5",
                "note": "(60*0.5 + 1200*0.1 + 10 + 20) * 1.5 = 165 * 1.5 = 247.5"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Calculate base cost first. Then add conditional fees. Finally, apply priority multiplier if needed. Order matters!"
              },
              {
                "title": "üí° Hint",
                "content": "Start: cost = weight * 0.5 + distance * 0.1. Then: if weight > 50, cost += 10. if distance > 1000, cost += 20. Finally: if isPriority, cost *= 1.5."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Calculate base: weight*0.5 + distance*0.1\n2. Add weight surcharge if needed\n3. Add distance surcharge if needed\n4. Apply priority multiplier if needed\n5. Return total</pre>"
              }
            ],
            "solution": "func calculateShipping(weight float64, distance int, isPriority bool) float64 {\n    cost := weight * 0.5 + float64(distance) * 0.1\n    \n    if weight > 50 {\n        cost += 10\n    }\n    \n    if distance > 1000 {\n        cost += 20\n    }\n    \n    if isPriority {\n        cost *= 1.5\n    }\n    \n    return cost\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_4",
        "block": 1,
        "difficulty": 1,
        "concept": "Finding Extrema",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "accessing slice elements"
          },
          {
            "url": "https://pkg.go.dev/builtin#len",
            "title": "Builtin len()",
            "note": "string and slice length"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Track the current best value; update whenever you find a better one.",
          "bestApproach": "Same approach - initialize to first element, then compare each subsequent element.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Find Maximum",
            "description": "Write <code>func max(nums []int) int</code> that returns the largest number.",
            "functionSignature": "func max(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9}",
                "output": "9"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "üí° Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? ‚Üí update best\n3. Return best</pre>"
              }
            ],
            "solution": "func max(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n > m { m = n }\n    }\n    return m\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Find Minimum",
            "description": "Write <code>func min(nums []int) int</code> that returns the smallest number.",
            "functionSignature": "func min(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9}",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "üí° Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? ‚Üí update best\n3. Return best</pre>"
              }
            ],
            "solution": "func min(nums []int) int {\n    m := nums[0]\n    for _, n := range nums {\n        if n < m { m = n }\n    }\n    return m\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Longest String",
            "description": "Write <code>func longest(words []string) string</code> that returns the longest word.",
            "functionSignature": "func longest(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\"}",
                "output": "\"python\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "üí° Hint",
                "content": "Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Better than current best? ‚Üí update best\n3. Return best</pre>"
              }
            ],
            "solution": "func longest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) > len(r) { r = w }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Shortest String",
            "description": "Write <code>func shortest(words []string) string</code> that returns the shortest word.",
            "functionSignature": "func shortest(words []string) string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\", \"java\"}",
                "output": "\"go\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?"
              },
              {
                "title": "üí° Hint",
                "content": "Initialize with the first element. Compare each subsequent element - if it's shorter, update your best."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with first element as \"best so far\"\n2. For each remaining element:\n   - Shorter than current best? ‚Üí update best\n3. Return best</pre>"
              }
            ],
            "solution": "func shortest(words []string) string {\n    r := words[0]\n    for _, w := range words {\n        if len(w) < len(r) { r = w }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Second Largest",
            "description": "Write <code>func secondLargest(nums []int) int</code> that returns the second largest number. Assume at least 2 distinct numbers.",
            "functionSignature": "func secondLargest(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 1, 9, 3}",
                "output": "5"
              },
              {
                "input": "[]int{10, 10, 8, 5}",
                "output": "8"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to track TWO values: the best so far AND the second best. When should each one update?"
              },
              {
                "title": "üí° Hint",
                "content": "Track first and second. When you find a new max, the old max becomes second. When you find something bigger than second but smaller than first, that becomes the new second."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Initialize first and second with smallest possible values\n2. For each element:\n   - Bigger than first? ‚Üí second = first, first = element\n   - Bigger than second (and != first)? ‚Üí second = element\n3. Return second</pre>"
              }
            ],
            "solution": "func secondLargest(nums []int) int {\n    first, second := nums[0], nums[1]\n    if second > first { first, second = second, first }\n    for _, n := range nums[2:] {\n        if n > first { second, first = first, n\n        } else if n > second && n != first { second = n }\n    }\n    return second\n}",
            "difficulty": 3
          },
          {
            "id": "v6",
            "title": "Smallest Positive",
            "description": "Write <code>func smallestPositive(nums []int) int</code> that returns the smallest positive number, or -1 if none exist.",
            "functionSignature": "func smallestPositive(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-5, 3, -1, 7, 2}",
                "output": "2"
              },
              {
                "input": "[]int{-3, -1, 0}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to find an extrema (minimum) but with a condition (must be positive). What's tricky about initializing the 'best so far'?"
              },
              {
                "title": "üí° Hint",
                "content": "You can't initialize with nums[0] if it might not be positive. Either find the first positive to initialize, or use a flag to track if you've found any positive."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Initialize result to -1 (not found)\n2. For each element:\n   - Is positive AND (first positive OR smaller than result)?\n   ‚Üí update result\n3. Return result</pre>"
              }
            ],
            "solution": "func smallestPositive(nums []int) int {\n    result := -1\n    for _, n := range nums {\n        if n > 0 && (result == -1 || n < result) {\n            result = n\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Highest Temperature",
            "description": "Write <code>func highestTemp(temps []float64) float64</code> that returns the highest temperature reading.",
            "functionSignature": "func highestTemp(temps []float64) float64",
            "testCases": [
              {
                "input": "[]float64{23.5, 28.7, 22.1, 30.2}",
                "output": "30.2"
              },
              {
                "input": "[]float64{-5.5, -2.0, -10.0}",
                "output": "-2.0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track the highest temperature seen so far. Initialize with the first reading."
              },
              {
                "title": "üí° Hint",
                "content": "Same pattern as finding max - start with first element, update when you find a higher value."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. highest := temps[0]\n2. For each temp:\n   - temp > highest? ‚Üí highest = temp\n3. Return highest</pre>"
              }
            ],
            "solution": "func highestTemp(temps []float64) float64 {\n    highest := temps[0]\n    for _, t := range temps {\n        if t > highest { highest = t }\n    }\n    return highest\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Best Game Score",
            "description": "Write <code>func bestScore(scores []int) int</code> that finds the highest score. Return -1 if no valid scores (all negative).",
            "functionSignature": "func bestScore(scores []int) int",
            "testCases": [
              {
                "input": "[]int{450, 320, 580, 410}",
                "output": "580"
              },
              {
                "input": "[]int{-1, -5, -3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Find the maximum, but only count non-negative scores as valid. What if all scores are negative?"
              },
              {
                "title": "üí° Hint",
                "content": "Track the max, but initialize to -1. Only update if you find a score >= 0 that's also greater than current max."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. bestScore := -1\n2. For each score:\n   - score >= 0 AND score > bestScore?\n     ‚Üí bestScore = score\n3. Return bestScore</pre>"
              }
            ],
            "solution": "func bestScore(scores []int) int {\n    bestScore := -1\n    for _, s := range scores {\n        if s >= 0 && s > bestScore {\n            bestScore = s\n        }\n    }\n    return bestScore\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Most Expensive Item",
            "description": "Write <code>func mostExpensive(prices []float64) int</code> that returns the INDEX of the most expensive item.",
            "functionSignature": "func mostExpensive(prices []float64) int",
            "testCases": [
              {
                "input": "[]float64{12.99, 45.50, 23.75, 50.00}",
                "output": "3"
              },
              {
                "input": "[]float64{100.0, 200.0, 150.0}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Instead of tracking the maximum VALUE, track the INDEX where the maximum occurs."
              },
              {
                "title": "üí° Hint",
                "content": "Keep two variables: maxPrice and maxIndex. When you find a higher price, update both."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. maxPrice, maxIndex := prices[0], 0\n2. For i, price:\n   - price > maxPrice?\n     ‚Üí maxPrice = price, maxIndex = i\n3. Return maxIndex</pre>"
              }
            ],
            "solution": "func mostExpensive(prices []float64) int {\n    maxPrice, maxIndex := prices[0], 0\n    for i, price := range prices {\n        if price > maxPrice {\n            maxPrice = price\n            maxIndex = i\n        }\n    }\n    return maxIndex\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Find Two Largest",
            "description": "Write <code>func findTwoLargest(nums []int) (int, int)</code> that returns the two largest distinct values. First return value is the largest, second is second-largest.",
            "functionSignature": "func findTwoLargest(nums []int) (int, int)",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9, 5}",
                "output": "9, 7"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5, 4"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to track TWO values as you iterate: the largest and second-largest. When you find a new max, the old max becomes second-max."
              },
              {
                "title": "üí° Hint",
                "content": "Initialize first and second to very small values. For each number: if it's bigger than first, shift first to second, then update first. Else if it's bigger than second, update second."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. first, second := nums[0], nums[1]\n   (handle if first < second)\n2. For each remaining num:\n   - num > first? ‚Üí second = first, first = num\n   - num > second? ‚Üí second = num\n3. Return first, second</pre>"
              }
            ],
            "solution": "func findTwoLargest(nums []int) (int, int) {\n    first, second := nums[0], nums[1]\n    if first < second {\n        first, second = second, first\n    }\n    \n    for i := 2; i < len(nums); i++ {\n        if nums[i] > first {\n            second = first\n            first = nums[i]\n        } else if nums[i] > second {\n            second = nums[i]\n        }\n    }\n    \n    return first, second\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Longest String and Length",
            "description": "Write <code>func longestStringAndLen(words []string) (string, int)</code> that returns the longest string and its length. If multiple strings tie for longest, return the first one.",
            "functionSignature": "func longestStringAndLen(words []string) (string, int)",
            "testCases": [
              {
                "input": "[\"go\", \"rust\", \"python\"]",
                "output": "\"python\", 6"
              },
              {
                "input": "[\"hello\", \"world\"]",
                "output": "\"hello\", 5",
                "note": "both length 5, return first"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track both the longest word AND its length. For each word, compute len(word) and compare to current max length."
              },
              {
                "title": "üí° Hint",
                "content": "Keep longest string and maxLen. For each word, if len(word) > maxLen, update both longest and maxLen."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. longest := words[0], maxLen := len(words[0])\n2. For each word:\n   - len(word) > maxLen?\n     ‚Üí longest = word, maxLen = len(word)\n3. Return longest, maxLen</pre>"
              }
            ],
            "solution": "func longestStringAndLen(words []string) (string, int) {\n    longest := words[0]\n    maxLen := len(words[0])\n    \n    for _, word := range words {\n        if len(word) > maxLen {\n            longest = word\n            maxLen = len(word)\n        }\n    }\n    \n    return longest, maxLen\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Find Range (Max - Min)",
            "description": "Write <code>func findRange(nums []int) int</code> that returns the difference between the maximum and minimum values in the slice (range = max - min).",
            "functionSignature": "func findRange(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 7, 2, 9, 5}",
                "output": "7",
                "note": "9 - 2 = 7"
              },
              {
                "input": "[]int{1, 1, 1}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to find both the maximum and minimum values, then calculate their difference."
              },
              {
                "title": "üí° Hint",
                "content": "Track both max and min as you iterate. Initialize both to nums[0]. For each number, update max if larger, update min if smaller. Return max - min."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. max, min := nums[0], nums[0]\n2. For each num:\n   - num > max? ‚Üí max = num\n   - num < min? ‚Üí min = num\n3. Return max - min</pre>"
              }
            ],
            "solution": "func findRange(nums []int) int {\n    max, min := nums[0], nums[0]\n    \n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n        if num < min {\n            min = num\n        }\n    }\n    \n    return max - min\n}",
            "difficulty": 3
          },
          {
            "id": "v1",
            "title": "Best Time to Buy and Sell Stock",
            "description": "Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>",
            "functionSignature": "func maxProfit(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "5",
                "note": "buy at 1, sell at 6"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "prices only go down, no profit possible"
              },
              {
                "input": "[]int{2, 4, 1}",
                "output": "2",
                "note": "buy at 2, sell at 4"
              }
            ],
            "solution": "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n        return 0\n    }\n    \n    minPrice := prices[0]\n    maxProfit := 0\n    \n    for _, price := range prices {\n        if price < minPrice {\n            minPrice = price\n        } else if price - minPrice > maxProfit {\n            maxProfit = price - minPrice\n        }\n    }\n    return maxProfit\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Maximum Difference",
            "description": "Find the maximum difference between any two elements where the larger element comes after the smaller one. Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>",
            "functionSignature": "func maxDiff(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 10, 6, 4, 8, 1}",
                "output": "8",
                "note": "10 - 2 = 8"
              },
              {
                "input": "[]int{7, 9, 5, 6, 3, 2}",
                "output": "2",
                "note": "9 - 7 = 2"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "0",
                "note": "decreasing, no valid pair"
              }
            ],
            "solution": "func maxDiff(nums []int) int {\n    if len(nums) < 2 {\n        return 0\n    }\n    \n    minSoFar := nums[0]\n    maxDiff := 0\n    \n    for i := 1; i < len(nums); i++ {\n        diff := nums[i] - minSoFar\n        if diff > maxDiff {\n            maxDiff = diff\n        }\n        if nums[i] < minSoFar {\n            minSoFar = nums[i]\n        }\n    }\n    return maxDiff\n}",
            "solutionNotes": "This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position calculate the potential profit/difference.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Best Sightseeing Pair",
            "description": "Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func maxScoreSightseeingPair(values []int) int</code>",
            "functionSignature": "func maxScoreSightseeingPair(values []int) int",
            "testCases": [
              {
                "input": "[]int{8, 1, 5, 2, 6}",
                "output": "11",
                "note": "i=0, j=2: 8+5+0-2=11"
              },
              {
                "input": "[]int{1, 2}",
                "output": "2",
                "note": "1+2+0-1=2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "7",
                "note": "i=1, j=2: 3+5+1-2=7"
              }
            ],
            "solution": "func maxScoreSightseeingPair(values []int) int {\n    maxScore := 0\n    bestI := values[0] + 0  // values[i] + i\n    \n    for j := 1; j < len(values); j++ {\n        score := bestI + values[j] - j\n        if score > maxScore {\n            maxScore = score\n        }\n        if values[j] + j > bestI {\n            bestI = values[j] + j\n        }\n    }\n    return maxScore\n}",
            "solutionNotes": "Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for each j compute the score. Same pattern as stock problem!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Maximum Subarray (Kadane's)",
            "description": "Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>",
            "functionSignature": "func maxSubArray(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}",
                "output": "6",
                "note": "[4,-1,2,1] = 6"
              },
              {
                "input": "[]int{1}",
                "output": "1"
              },
              {
                "input": "[]int{-1, -2, -3}",
                "output": "-1",
                "note": "least negative"
              }
            ],
            "solution": "func maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if currentSum < 0 {\n            currentSum = nums[i]\n        } else {\n            currentSum += nums[i]\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track the best sum seen so far. Same 'best so far' pattern!",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Best Time to Buy and Sell Stock II",
            "description": "You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit. <code>func maxProfitII(prices []int) int</code>",
            "functionSignature": "func maxProfitII(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "7",
                "note": "buy@1 sell@5 (+4), buy@3 sell@6 (+3)"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "4",
                "note": "buy@1 sell@5, or buy/sell each day"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "no profit possible"
              }
            ],
            "solution": "func maxProfitII(prices []int) int {\n    profit := 0\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
            "solutionNotes": "Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all positive differences. Much simpler than it seems!",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Trapping Rain Water",
            "description": "Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining. <code>func trap(height []int) int</code>",
            "functionSignature": "func trap(height []int) int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}",
                "output": "6"
              },
              {
                "input": "[]int{4, 2, 0, 3, 2, 5}",
                "output": "9"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "strictly increasing, no trapping"
              }
            ],
            "solution": "func trap(height []int) int {\n    if len(height) == 0 {\n        return 0\n    }\n    \n    n := len(height)\n    maxLeft := make([]int, n)\n    maxRight := make([]int, n)\n    \n    maxLeft[0] = height[0]\n    for i := 1; i < n; i++ {\n        if height[i] > maxLeft[i-1] {\n            maxLeft[i] = height[i]\n        } else {\n            maxLeft[i] = maxLeft[i-1]\n        }\n    }\n    \n    maxRight[n-1] = height[n-1]\n    for i := n - 2; i >= 0; i-- {\n        if height[i] > maxRight[i+1] {\n            maxRight[i] = height[i]\n        } else {\n            maxRight[i] = maxRight[i+1]\n        }\n    }\n    \n    water := 0\n    for i := 0; i < n; i++ {\n        level := maxLeft[i]\n        if maxRight[i] < level {\n            level = maxRight[i]\n        }\n        water += level - height[i]\n    }\n    return water\n}",
            "solutionNotes": "At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using the 'best so far' pattern in both directions!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_5",
        "block": 2,
        "difficulty": 2,
        "concept": "Filter with Append",
        "docLinks": [
          {
            "url": "https://pkg.go.dev/builtin#append",
            "title": "Builtin append()",
            "note": "growing slices dynamically"
          },
          {
            "url": "https://go.dev/blog/slices-intro",
            "title": "Go Blog: Slices introduction",
            "note": "slice internals"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a new slice and append elements that pass the condition.",
          "bestApproach": "Same approach - loop once, append conditionally. Can't do better than O(n).",
          "typical": "Typically O(n) time, O(k) extra space where k = filtered elements"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Filter Positives",
            "description": "Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.",
            "functionSignature": "func filterPositives(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-2, 3, -1, 5}",
                "output": "[3, 5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "üí° Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? ‚Üí add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterPositives(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > 0 { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Filter Evens",
            "description": "Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.",
            "functionSignature": "func filterEvens(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[2, 4]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "üí° Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? ‚Üí add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterEvens(nums []int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n%2 == 0 { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Filter Short Words",
            "description": "Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.",
            "functionSignature": "func filterShort(words []string, max int) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"python\"}, 3",
                "output": "[\"go\"]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "üí° Hint",
                "content": "Start with an empty slice. Loop through, check your condition, and append elements that pass."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result collection\n2. For each element:\n   - Passes test? ‚Üí add to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterShort(words []string, max int) []string {\n    r := []string{}\n    for _, w := range words {\n        if len(w) <= max { r = append(r, w) }\n    }\n    return r\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Filter Greater Than",
            "description": "Write <code>func filterGreater(nums []int, threshold int) []int</code> returning only numbers greater than threshold.",
            "functionSignature": "func filterGreater(nums []int, threshold int) []int",
            "testCases": [
              {
                "input": "[]int{1, 5, 3, 8, 2}, 3",
                "output": "[5, 8]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?"
              },
              {
                "title": "üí° Hint",
                "content": "Start with an empty slice. Loop through, check if n > threshold, and append elements that pass."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - Passes test? ‚Üí append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterGreater(nums []int, threshold int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n > threshold { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Filter Non-Empty",
            "description": "Write <code>func filterNonEmpty(words []string) []string</code> returning only non-empty strings.",
            "functionSignature": "func filterNonEmpty(words []string) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"\", \"python\", \"\"}",
                "output": "[\"go\", \"python\"]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to filter out empty strings. How do you check if a string is empty?"
              },
              {
                "title": "üí° Hint",
                "content": "Check if len(w) > 0 or equivalently w != \"\". Append only strings that pass this test."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - Not empty? ‚Üí append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterNonEmpty(words []string) []string {\n    r := []string{}\n    for _, w := range words {\n        if w != \"\" { r = append(r, w) }\n    }\n    return r\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Filter In Range",
            "description": "Write <code>func filterInRange(nums []int, min, max int) []int</code> returning numbers where min <= n <= max.",
            "functionSignature": "func filterInRange(nums []int, min, max int) []int",
            "testCases": [
              {
                "input": "[]int{1, 5, 3, 8, 2}, 2, 5",
                "output": "[5, 3, 2]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to check TWO conditions: the number must be >= min AND <= max."
              },
              {
                "title": "üí° Hint",
                "content": "Use n >= min && n <= max as your filter condition. Only append elements that satisfy both conditions."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Start with empty result slice\n2. For each element:\n   - In range [min, max]? ‚Üí append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterInRange(nums []int, min, max int) []int {\n    r := []int{}\n    for _, n := range nums {\n        if n >= min && n <= max { r = append(r, n) }\n    }\n    return r\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Filter Palindromes",
            "difficulty": 3,
            "description": "Write <code>func filterPalindromes(words []string) []string</code> that returns only palindromes (words that read the same forwards and backwards). Ignore case.",
            "functionSignature": "func filterPalindromes(words []string) []string",
            "testCases": [
              {
                "input": "[]string{\"racecar\", \"hello\", \"level\", \"world\", \"noon\"}",
                "output": "[\"racecar\", \"level\", \"noon\"]"
              },
              {
                "input": "[]string{\"Go\", \"was\", \"it\", \"a\", \"cat\", \"I\", \"saw\"}",
                "output": "[\"a\", \"I\"]",
                "note": "Single chars are palindromes"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to filter, but the condition itself is complex (checking if a word is a palindrome). You'll need a helper function."
              },
              {
                "title": "üí° Hint",
                "content": "Create isPalindrome(s string) bool that uses two pointers from opposite ends. Then filter: for each word, if isPalindrome(word), append it."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - If isPalindrome(word): append to result\n3. Return result\n\nisPalindrome(s):\n  - left, right pointers from ends\n  - Compare chars moving inward</pre>"
              }
            ],
            "solution": "func filterPalindromes(words []string) []string {\n    result := []string{}\n    for _, w := range words {\n        if isPalindrome(w) {\n            result = append(result, w)\n        }\n    }\n    return result\n}\n\nfunc isPalindrome(s string) bool {\n    s = strings.ToLower(s)\n    left, right := 0, len(s)-1\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}"
          },
          {
            "id": "v8",
            "title": "Filter Prime Numbers",
            "difficulty": 3,
            "description": "Write <code>func filterPrimes(nums []int) []int</code> that returns only prime numbers. A prime is > 1 and divisible only by 1 and itself.",
            "functionSignature": "func filterPrimes(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
                "output": "[2, 3, 5, 7]"
              },
              {
                "input": "[]int{11, 12, 13, 14, 15}",
                "output": "[11, 13]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Filtering + prime checking. You'll need an isPrime helper function that checks divisibility."
              },
              {
                "title": "üí° Hint",
                "content": "Create isPrime(n int) bool. A number is prime if n > 1 and no number from 2 to sqrt(n) divides it evenly. Then filter using this function."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - If isPrime(num): append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func filterPrimes(nums []int) []int {\n    result := []int{}\n    for _, n := range nums {\n        if isPrime(n) {\n            result = append(result, n)\n        }\n    }\n    return result\n}\n\nfunc isPrime(n int) bool {\n    if n <= 1 {\n        return false\n    }\n    for i := 2; i*i <= n; i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v9",
            "title": "Affordable Items",
            "description": "Write <code>func affordableItems(prices []float64, budget float64) []float64</code> that returns prices within budget.",
            "functionSignature": "func affordableItems(prices []float64, budget float64) []float64",
            "testCases": [
              {
                "input": "[]float64{29.99, 45.00, 15.50, 60.00}, 40.0",
                "output": "[]float64{29.99, 15.50}"
              },
              {
                "input": "[]float64{100.0, 200.0}, 50.0",
                "output": "[]float64{}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Filter prices that are <= budget. Append matching prices to result slice."
              },
              {
                "title": "üí° Hint",
                "content": "Standard filter pattern: if price <= budget, append it."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []float64{}\n2. For each price:\n   - price <= budget? ‚Üí append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func affordableItems(prices []float64, budget float64) []float64 {\n    result := []float64{}\n    for _, price := range prices {\n        if price <= budget {\n            result = append(result, price)\n        }\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Valid Emails",
            "description": "Write <code>func validEmails(emails []string) []string</code> that returns emails containing '@' symbol.",
            "functionSignature": "func validEmails(emails []string) []string",
            "testCases": [
              {
                "input": "[]string{\"user@example.com\", \"invalid\", \"admin@site.org\"}",
                "output": "[]string{\"user@example.com\", \"admin@site.org\"}"
              },
              {
                "input": "[]string{\"nope\", \"nada\"}",
                "output": "[]string{}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Simple validation: check if email contains '@'. Use strings.Contains()."
              },
              {
                "title": "üí° Hint",
                "content": "Filter emails where strings.Contains(email, \"@\") is true."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []string{}\n2. For each email:\n   - contains '@'? ‚Üí append to result\n3. Return result</pre>"
              }
            ],
            "solution": "func validEmails(emails []string) []string {\n    result := []string{}\n    for _, email := range emails {\n        if strings.Contains(email, \"@\") {\n            result = append(result, email)\n        }\n    }\n    return result\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Filter By Length Range",
            "description": "Write <code>func filterByLengthRange(words []string, minLen, maxLen int) []string</code> that returns words where minLen <= len(word) <= maxLen.",
            "functionSignature": "func filterByLengthRange(words []string, minLen, maxLen int) []string",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\", \"c\"}, 2, 4",
                "output": "[]string{\"go\", \"rust\"}"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\", \"abcd\"}, 2, 3",
                "output": "[]string{\"ab\", \"abc\"}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check two conditions: length must be >= minLen AND <= maxLen."
              },
              {
                "title": "üí° Hint",
                "content": "Filter words where len(word) >= minLen && len(word) <= maxLen."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - len(word) in range? ‚Üí append\n3. Return result</pre>"
              }
            ],
            "solution": "func filterByLengthRange(words []string, minLen, maxLen int) []string {\n    result := []string{}\n    for _, word := range words {\n        if len(word) >= minLen && len(word) <= maxLen {\n            result = append(result, word)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Filter Multiples",
            "description": "Write <code>func filterMultiples(nums []int, divisor int) []int</code> that returns only numbers divisible by divisor (multiples of divisor).",
            "functionSignature": "func filterMultiples(nums []int, divisor int) []int",
            "testCases": [
              {
                "input": "[]int{3, 6, 7, 9, 12, 15}, 3",
                "output": "[]int{3, 6, 9, 12, 15}"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 2",
                "output": "[]int{2, 4, 6}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "A number is divisible by divisor if num % divisor == 0. Filter based on this condition."
              },
              {
                "title": "üí° Hint",
                "content": "For each number, check if num % divisor == 0, then append to result."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - num % divisor == 0? ‚Üí append\n3. Return result</pre>"
              }
            ],
            "solution": "func filterMultiples(nums []int, divisor int) []int {\n    result := []int{}\n    for _, num := range nums {\n        if num % divisor == 0 {\n            result = append(result, num)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v13",
            "title": "Filter Contains Substring",
            "description": "Write <code>func filterContains(words []string, substr string) []string</code> that returns words containing the substring.",
            "functionSignature": "func filterContains(words []string, substr string) []string",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"world\", \"help\", \"loop\"}, \"lo\"",
                "output": "[]string{\"hello\", \"loop\"}"
              },
              {
                "input": "[]string{\"go\", \"gopher\", \"python\"}, \"go\"",
                "output": "[]string{\"go\", \"gopher\"}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Use strings.Contains() to check if a word contains the substring."
              },
              {
                "title": "üí° Hint",
                "content": "Import strings. Filter words where strings.Contains(word, substr) is true."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []string{}\n2. For each word:\n   - contains substr? ‚Üí append\n3. Return result</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nfunc filterContains(words []string, substr string) []string {\n    result := []string{}\n    for _, word := range words {\n        if strings.Contains(word, substr) {\n            result = append(result, word)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_6",
        "block": 2,
        "difficulty": 2,
        "concept": "Find Index",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "range with index"
          },
          {
            "url": "https://go.dev/ref/spec#Return_statements",
            "title": "Go Spec: Return statements",
            "note": "early returns"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through, return index immediately when found; return -1 if not found.",
          "bestApproach": "Same approach - early return is already optimal! No need to continue after finding match.",
          "typical": "Typically O(n) time worst case, O(1) if found early, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Find Index",
            "description": "Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.",
            "functionSignature": "func findIndex(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30}, 20",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "üí° Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? ‚Üí return index immediately\n2. Loop finished? ‚Üí return -1 (not found)</pre>"
              }
            ],
            "solution": "func findIndex(nums []int, target int) int {\n    for i, n := range nums {\n        if n == target { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Find Word",
            "description": "Write <code>func findWord(words []string, target string) int</code> returning index or -1.",
            "functionSignature": "func findWord(words []string, target string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"py\"}, \"py\"",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "üí° Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? ‚Üí return index immediately\n2. Loop finished? ‚Üí return -1 (not found)</pre>"
              }
            ],
            "solution": "func findWord(words []string, target string) int {\n    for i, w := range words {\n        if w == target { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "First Negative Index",
            "description": "Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.",
            "functionSignature": "func firstNegIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, -2, 3}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If you're looking for something specific, when should you stop looking? What should you return if you never find it?"
              },
              {
                "title": "üí° Hint",
                "content": "Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each element with its index:\n   - Matches target? ‚Üí return index immediately\n2. Loop finished? ‚Üí return -1 (not found)</pre>"
              }
            ],
            "solution": "func firstNegIdx(nums []int) int {\n    for i, n := range nums {\n        if n < 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Find First Even",
            "description": "Write <code>func firstEvenIdx(nums []int) int</code> returning the index of the first even number, or -1 if none.",
            "functionSignature": "func firstEvenIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 4, 5}",
                "output": "2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "How do you check if a number is even? Use the modulo operator."
              },
              {
                "title": "üí° Hint",
                "content": "Check if n % 2 == 0. If so, return that index immediately. Otherwise keep looking."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each element with its index:\n   - Is even (n % 2 == 0)? ‚Üí return index\n2. Loop finished? ‚Üí return -1 (not found)</pre>"
              }
            ],
            "solution": "func firstEvenIdx(nums []int) int {\n    for i, n := range nums {\n        if n % 2 == 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Last Index Of",
            "description": "Write <code>func lastIndex(nums []int, target int) int</code> returning the LAST index where target appears, or -1.",
            "functionSignature": "func lastIndex(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 2, 1}, 2",
                "output": "3"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Unlike finding the FIRST match (where you return immediately), for the LAST match you need to keep track of matches as you go."
              },
              {
                "title": "üí° Hint",
                "content": "Initialize result to -1. Each time you find a match, update result to that index. After the loop, return result."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Initialize result := -1\n2. For each element with its index:\n   - Matches target? ‚Üí result = index\n3. Return result (last match, or -1)</pre>"
              }
            ],
            "solution": "func lastIndex(nums []int, target int) int {\n    result := -1\n    for i, n := range nums {\n        if n == target { result = i }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Find Long Word Index",
            "description": "Write <code>func findLongWordIdx(words []string, minLen int) int</code> returning the index of first word with length >= minLen, or -1.",
            "functionSignature": "func findLongWordIdx(words []string, minLen int) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"hi\", \"python\"}, 4",
                "output": "2"
              },
              {
                "input": "[]string{\"a\", \"bb\"}, 5",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Instead of matching an exact value, you're matching a condition (length >= minLen)."
              },
              {
                "title": "üí° Hint",
                "content": "Check if len(w) >= minLen. If so, return that index immediately. Otherwise keep looking."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each word with its index:\n   - Long enough? ‚Üí return index\n2. Loop finished? ‚Üí return -1 (not found)</pre>"
              }
            ],
            "solution": "func findLongWordIdx(words []string, minLen int) int {\n    for i, w := range words {\n        if len(w) >= minLen { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Find All Indices",
            "difficulty": 3,
            "description": "Write <code>func findAllIndices(nums []int, target int) []int</code> that returns a slice of ALL positions where target appears. Return empty slice if not found.",
            "functionSignature": "func findAllIndices(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 3, 7, 3}, 3",
                "output": "[1, 3, 5]",
                "note": "3 appears at indices 1, 3, and 5"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "[]",
                "note": "Not found, return empty slice"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Instead of returning on first match, you need to collect ALL matching indices and keep searching."
              },
              {
                "title": "üí° Hint",
                "content": "Create an empty result slice. Loop through all elements - whenever you find a match, append the index to result. Don't return early, keep searching."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. indices := []int{}\n2. For i, num in enumerate:\n   - If num == target: append i to indices\n3. Return indices (might be empty)</pre>"
              }
            ],
            "solution": "func findAllIndices(nums []int, target int) []int {\n    indices := []int{}\n    for i, n := range nums {\n        if n == target {\n            indices = append(indices, i)\n        }\n    }\n    return indices\n}"
          },
          {
            "id": "v8",
            "title": "Binary Search Index",
            "difficulty": 3,
            "description": "Write <code>func binarySearch(nums []int, target int) int</code> that finds target in a SORTED slice using binary search. Return index or -1. Must use divide-and-conquer, not linear search.",
            "functionSignature": "func binarySearch(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 7, 9, 11}, 7",
                "output": "3"
              },
              {
                "input": "[]int{1, 3, 5, 7, 9, 11}, 4",
                "output": "-1"
              },
              {
                "input": "[]int{2, 4, 6, 8, 10}, 2",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Since the slice is sorted, you don't need to check every element. Compare target to the middle element - this tells you which half to search next."
              },
              {
                "title": "üí° Hint",
                "content": "Use two pointers: left = 0, right = len-1. While left <= right: calculate mid = (left+right)/2. If nums[mid] == target, found it! If target < nums[mid], search left half (right = mid-1). Otherwise search right half (left = mid+1)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left := 0, right := len(nums)-1\n2. While left <= right:\n   - mid := (left + right) / 2\n   - If nums[mid] == target: return mid\n   - If target < nums[mid]: right = mid - 1\n   - Else: left = mid + 1\n3. Return -1 (not found)</pre>"
              }
            ],
            "solution": "func binarySearch(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n    for left <= right {\n        mid := (left + right) / 2\n        if nums[mid] == target {\n            return mid\n        } else if target < nums[mid] {\n            right = mid - 1\n        } else {\n            left = mid + 1\n        }\n    }\n    return -1\n}"
          },
          {
            "id": "v9",
            "title": "First Negative Index",
            "description": "Write <code>func firstNegativeIdx(nums []int) int</code> that returns index of first negative number, or -1.",
            "functionSignature": "func firstNegativeIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 3, -2, 8}",
                "output": "2"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Return index as soon as you find num < 0."
              },
              {
                "title": "üí° Hint",
                "content": "Early return pattern: for i, num := range nums { if num < 0 { return i } }"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i, num:\n   - num < 0? ‚Üí return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func firstNegativeIdx(nums []int) int {\n    for i, num := range nums {\n        if num < 0 { return i }\n    }\n    return -1\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Find Keyword Position",
            "description": "Write <code>func findKeyword(words []string, keyword string) int</code> that returns index of keyword (case-insensitive).",
            "functionSignature": "func findKeyword(words []string, keyword string) int",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"WORLD\", \"Go\"}, \"world\"",
                "output": "1"
              },
              {
                "input": "[]string{\"apple\", \"banana\"}, \"orange\"",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare lowercase versions of both word and keyword."
              },
              {
                "title": "üí° Hint",
                "content": "Use strings.ToLower() to normalize before comparing."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i, word:\n   - ToLower(word) == ToLower(keyword)?\n     ‚Üí return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func findKeyword(words []string, keyword string) int {\n    keyword = strings.ToLower(keyword)\n    for i, word := range words {\n        if strings.ToLower(word) == keyword {\n            return i\n        }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Find First Negative",
            "description": "Write <code>func findFirstNegative(nums []int) int</code> that returns the index of the first negative number, or -1 if none found.",
            "functionSignature": "func findFirstNegative(nums []int) int",
            "testCases": [
              {
                "input": "[]int{5, 3, -2, 8, -1}",
                "output": "2"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through and check each number. Return the index as soon as you find a negative."
              },
              {
                "title": "üí° Hint",
                "content": "Use early return: if num < 0, return i immediately."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i, num:\n   - num < 0? ‚Üí return i\n2. Return -1 (not found)</pre>"
              }
            ],
            "solution": "func findFirstNegative(nums []int) int {\n    for i, num := range nums {\n        if num < 0 {\n            return i\n        }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Find Last Index Of",
            "description": "Write <code>func findLastIndexOf(nums []int, target int) int</code> that returns the index of the LAST occurrence of target, or -1 if not found.",
            "functionSignature": "func findLastIndexOf(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 2, 5}, 2",
                "output": "3",
                "note": "last occurrence of 2 is at index 3"
              },
              {
                "input": "[]int{5, 5, 5}, 5",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through all elements and track the most recent index where you found the target."
              },
              {
                "title": "üí° Hint",
                "content": "Keep updating lastIndex whenever you find target. Initialize to -1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. lastIndex := -1\n2. For i, num:\n   - num == target? ‚Üí lastIndex = i\n3. Return lastIndex</pre>"
              }
            ],
            "solution": "func findLastIndexOf(nums []int, target int) int {\n    lastIndex := -1\n    for i, num := range nums {\n        if num == target {\n            lastIndex = i\n        }\n    }\n    return lastIndex\n}",
            "difficulty": 2
          },
          {
            "id": "v13",
            "title": "Find Index of Longest Word",
            "description": "Write <code>func findLongestWordIndex(words []string) int</code> that returns the index of the longest word. If multiple words tie, return the first occurrence.",
            "functionSignature": "func findLongestWordIndex(words []string) int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\", \"c\"}",
                "output": "2",
                "note": "python is longest at index 2"
              },
              {
                "input": "[]string{\"hello\", \"world\"}",
                "output": "0",
                "note": "both length 5, return first"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track both the maximum length seen and the index where it occurred."
              },
              {
                "title": "üí° Hint",
                "content": "Keep maxLen and maxIndex. For each word, if len(word) > maxLen, update both."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. maxLen := 0, maxIndex := 0\n2. For i, word:\n   - len(word) > maxLen?\n     ‚Üí maxLen = len(word), maxIndex = i\n3. Return maxIndex</pre>"
              }
            ],
            "solution": "func findLongestWordIndex(words []string) int {\n    maxLen := 0\n    maxIndex := 0\n    \n    for i, word := range words {\n        if len(word) > maxLen {\n            maxLen = len(word)\n            maxIndex = i\n        }\n    }\n    \n    return maxIndex\n}",
            "difficulty": 2
          }
        ]
      },
      {
        "id": "challenge_7",
        "block": 2,
        "difficulty": 2,
        "concept": "Frequency Map",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "map operations"
          },
          {
            "url": "https://go.dev/ref/spec#Making_slices_maps_and_channels",
            "title": "Go Spec: make()",
            "note": "creating maps"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Nested loops: for each unique element, scan the entire array again to count occurrences.",
          "bestApproach": "Single pass with a map, incrementing counts[element]++ as we go. Map automatically tracks unique keys.",
          "typical": "Typically O(n) time, O(n) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Occurrences",
            "description": "Write <code>func countOccurrences(nums []int) map[int]int</code>.",
            "functionSignature": "func countOccurrences(nums []int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "map[1:1 2:2 3:3]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func countOccurrences(nums []int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Count Characters",
            "description": "Write <code>func countChars(s string) map[rune]int</code>.",
            "functionSignature": "func countChars(s string) map[rune]int",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "map[e:1 h:1 l:2 o:1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func countChars(s string) map[rune]int {\n    c := make(map[rune]int)\n    for _, r := range s { c[r]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Word Frequency",
            "description": "Write <code>func wordFreq(words []string) map[string]int</code>.",
            "functionSignature": "func wordFreq(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"go\", \"py\"}",
                "output": "map[go:2 py:1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Increment count for that element\n3. Return map</pre>"
              }
            ],
            "solution": "func wordFreq(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words { c[w]++ }\n    return c\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Count Even and Odd",
            "description": "Write <code>func countEvenOdd(nums []int) map[string]int</code> returning a map with keys \"even\" and \"odd\" showing how many of each.",
            "functionSignature": "func countEvenOdd(nums []int) map[string]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "map[even:2 odd:3]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Similar to counting positives/negatives, but now store the counts in a map instead of separate variables."
              },
              {
                "title": "üí° Hint",
                "content": "Use num % 2 to check: if it equals 0, the number is even. Increment the appropriate key in your map."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each element:\n   - Is it even (num % 2 == 0)? ‚Üí increment \"even\"\n   - Otherwise ‚Üí increment \"odd\"\n3. Return map</pre>"
              }
            ],
            "solution": "func countEvenOdd(nums []int) map[string]int {\n    c := make(map[string]int)\n    for _, n := range nums {\n        if n % 2 == 0 { c[\"even\"]++ } else { c[\"odd\"]++ }\n    }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Invert Count Map",
            "description": "Write <code>func invertCounts(counts map[string]int) map[int][]string</code> that inverts a frequency map. Keys become values grouped by their original values.",
            "functionSignature": "func invertCounts(counts map[string]int) map[int][]string",
            "testCases": [
              {
                "input": "map[string]int{\"a\": 2, \"b\": 1, \"c\": 2}",
                "output": "map[1:[b] 2:[a c]]",
                "note": "words with count 1: [b], words with count 2: [a, c]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You're flipping the relationship: instead of word‚Üícount, you want count‚Üí[words with that count]."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through the original map. For each key-value pair, append the key to the slice stored at the value in your new map."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create result map[int][]string\n2. For each word, count in original:\n   - Append word to result[count]\n3. Return result</pre>"
              }
            ],
            "solution": "func invertCounts(counts map[string]int) map[int][]string {\n    result := make(map[int][]string)\n    for word, count := range counts {\n        result[count] = append(result[count], word)\n    }\n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v6",
            "title": "Count by Length",
            "description": "Write <code>func countByLength(words []string) map[int]int</code> that groups words by their length and counts how many words are in each group. Keys are lengths, values are counts.",
            "functionSignature": "func countByLength(words []string) map[int]int",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"c\", \"js\"}",
                "output": "map[1:1 2:2 4:1]",
                "note": "1 word of length 1 (c), 2 words of length 2 (go, js), 1 word of length 4 (rust)"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Instead of counting the words themselves, you're counting a property of each word. What property? Its length."
              },
              {
                "title": "üí° Hint",
                "content": "Use len(word) as the key. Same counting pattern, just using the length instead of the word itself."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each word:\n   - Get its length with len(word)\n   - Increment count for that length\n3. Return map</pre>"
              }
            ],
            "solution": "func countByLength(words []string) map[int]int {\n    c := make(map[int]int)\n    for _, w := range words { c[len(w)]++ }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Count by Remainder",
            "description": "Write <code>func countByRemainder(nums []int, divisor int) map[int]int</code> that groups numbers by their remainder when divided by divisor.",
            "functionSignature": "func countByRemainder(nums []int, divisor int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 3",
                "output": "map[0:2 1:2 2:2]",
                "note": "3,6 have remainder 0; 1,4 have remainder 1; 2,5 have remainder 2"
              },
              {
                "input": "[]int{10, 20, 30}, 10",
                "output": "map[0:3]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "The key is num % divisor (the remainder). Count how many numbers give each remainder."
              },
              {
                "title": "üí° Hint",
                "content": "Same counting pattern as before, but use num % divisor as the key."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each num:\n   - remainder := num % divisor\n   - counts[remainder]++\n3. Return counts</pre>"
              }
            ],
            "solution": "func countByRemainder(nums []int, divisor int) map[int]int {\n    c := make(map[int]int)\n    for _, n := range nums { c[n % divisor]++ }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Group by First Letter",
            "description": "Write <code>func countByFirstLetter(words []string) map[string]int</code> that counts how many words start with each letter. Use lowercase keys.",
            "functionSignature": "func countByFirstLetter(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"apple\", \"ant\", \"bear\", \"ace\"}",
                "output": "map[a:3 b:1]"
              },
              {
                "input": "[]string{\"Go\", \"great\", \"Python\"}",
                "output": "map[g:2 p:1]",
                "note": "lowercase keys"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Extract the first character of each word and use it as the key. How do you get the first character of a string?"
              },
              {
                "title": "üí° Hint",
                "content": "Use strings.ToLower(string(word[0])) to get the lowercase first letter as a string. Then count like before."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty count map\n2. For each word:\n   - Get first letter (lowercase)\n   - Increment count for that letter\n3. Return map</pre>"
              }
            ],
            "solution": "func countByFirstLetter(words []string) map[string]int {\n    c := make(map[string]int)\n    for _, w := range words {\n        if len(w) > 0 {\n            first := strings.ToLower(string(w[0]))\n            c[first]++\n        }\n    }\n    return c\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Vote Tally",
            "description": "Write <code>func voteTally(votes []string) map[string]int</code> that counts votes for each candidate.",
            "functionSignature": "func voteTally(votes []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"Alice\", \"Bob\", \"Alice\", \"Charlie\", \"Alice\"}",
                "output": "map[string]int{\"Alice\": 3, \"Bob\": 1, \"Charlie\": 1}"
              },
              {
                "input": "[]string{\"Yes\", \"No\", \"Yes\"}",
                "output": "map[string]int{\"Yes\": 2, \"No\": 1}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Standard frequency map: increment count for each vote."
              },
              {
                "title": "üí° Hint",
                "content": "counts[vote]++ for each vote."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. counts := make(map[string]int)\n2. For each vote:\n   - counts[vote]++\n3. Return counts</pre>"
              }
            ],
            "solution": "func voteTally(votes []string) map[string]int {\n    counts := make(map[string]int)\n    for _, vote := range votes {\n        counts[vote]++\n    }\n    return counts\n}",
            "difficulty": 1
          },
          {
            "id": "v10",
            "title": "Grade Distribution",
            "description": "Write <code>func gradeDistribution(grades []string) map[string]int</code> that counts how many of each letter grade.",
            "functionSignature": "func gradeDistribution(grades []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"A\", \"B\", \"A\", \"C\", \"A\", \"B\"}",
                "output": "map[string]int{\"A\": 3, \"B\": 2, \"C\": 1}"
              },
              {
                "input": "[]string{\"F\", \"F\", \"D\"}",
                "output": "map[string]int{\"F\": 2, \"D\": 1}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Another frequency map - count occurrences of each grade."
              },
              {
                "title": "üí° Hint",
                "content": "Same pattern: dist[grade]++ for each grade."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. dist := make(map[string]int)\n2. For each grade:\n   - dist[grade]++\n3. Return dist</pre>"
              }
            ],
            "solution": "func gradeDistribution(grades []string) map[string]int {\n    dist := make(map[string]int)\n    for _, grade := range grades {\n        dist[grade]++\n    }\n    return dist\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "Most Common Element",
            "description": "Write <code>func mostCommonElement(items []string) string</code> that returns the element appearing most frequently. If multiple items tie for most common, return the one that appeared first.",
            "functionSignature": "func mostCommonElement(items []string) string",
            "testCases": [
              {
                "input": "[\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"dog\"]",
                "output": "\"dog\"",
                "note": "dog appears 3 times"
              },
              {
                "input": "[\"a\", \"b\", \"a\"]",
                "output": "\"a\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "First build a frequency map to count all items. Then find the key with the highest value. Track both the item and its frequency as you search."
              },
              {
                "title": "üí° Hint",
                "content": "Build frequency map with freq[item]++. Then loop through the map to find the key with maximum value. Keep track of maxCount and mostCommon item."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Build frequency map\n2. maxCount := 0, mostCommon := \"\"\n3. For each item, count in map:\n   - count > maxCount?\n     ‚Üí maxCount = count, mostCommon = item\n4. Return mostCommon</pre>"
              }
            ],
            "solution": "func mostCommonElement(items []string) string {\n    freq := make(map[string]int)\n    for _, item := range items {\n        freq[item]++\n    }\n    \n    maxCount := 0\n    mostCommon := \"\"\n    \n    for item, count := range freq {\n        if count > maxCount {\n            maxCount = count\n            mostCommon = item\n        }\n    }\n    \n    return mostCommon\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Frequency Histogram",
            "description": "Write <code>func frequencyHistogram(nums []int) map[int]int</code> that returns a \"meta-map\" showing how many elements appear each number of times. For example, if 2 elements appear once and 1 element appears twice, return map[1:2, 2:1].",
            "functionSignature": "func frequencyHistogram(nums []int) map[int]int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2, 3, 3, 3}",
                "output": "map[1:1 2:2 3:1]",
                "note": "one element appears 1x (2), two elements appear 2x (1), one element appears 3x (3)"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "map[4:1]",
                "note": "one element appears 4 times"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Build a frequency map first to count how often each number appears. Then build a second map that counts how many numbers have each frequency."
              },
              {
                "title": "üí° Hint",
                "content": "Step 1: Build freq map with freq[num]++. Step 2: Build histogram with histogram[count]++ for each count in freq. This creates a frequency-of-frequencies map."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Build freq map (num ‚Üí count)\n2. Create histogram map[int]int\n3. For each count in freq.values:\n   - histogram[count]++\n4. Return histogram</pre>"
              }
            ],
            "solution": "func frequencyHistogram(nums []int) map[int]int {\n    freq := make(map[int]int)\n    for _, num := range nums {\n        freq[num]++\n    }\n    \n    histogram := make(map[int]int)\n    for _, count := range freq {\n        histogram[count]++\n    }\n    \n    return histogram\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Merge Frequency Maps",
            "description": "Write <code>func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int</code> that merges two frequency maps by adding their counts. If a key exists in both maps, add the counts together.",
            "functionSignature": "func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int",
            "testCases": [
              {
                "input": "map[\"a\":2, \"b\":1], map[\"a\":1, \"c\":3]",
                "output": "map[\"a\":3 \"b\":1 \"c\":3]"
              },
              {
                "input": "map[\"x\":5], map[\"x\":3]",
                "output": "map[\"x\":8]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Copy all entries from map1 to result. Then iterate through map2, adding each count to result (which may already have that key)."
              },
              {
                "title": "üí° Hint",
                "content": "Create result map. Copy map1: result[k] = v. Then for each k, v in map2: result[k] += v. This adds to existing or creates new entry."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create result map\n2. Copy all from map1 to result\n3. For each key, value in map2:\n   - result[key] += value\n4. Return result</pre>"
              }
            ],
            "solution": "func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int {\n    result := make(map[string]int)\n    \n    for k, v := range map1 {\n        result[k] = v\n    }\n    \n    for k, v := range map2 {\n        result[k] += v\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v1",
            "title": "Contains Duplicate",
            "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
            "functionSignature": "func containsDuplicate(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "true"
              }
            ],
            "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "First Duplicate Value",
            "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
            "functionSignature": "func firstDuplicate(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 3, 5, 3, 2}",
                "output": "3",
                "note": "3 is seen again before 2 is"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "-1"
              },
              {
                "input": "[]int{1, 1, 2, 2}",
                "output": "1"
              }
            ],
            "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num\n        }\n        seen[num] = true\n    }\n    return -1\n}",
            "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Count Unique Elements",
            "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "1"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
            "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Find All Duplicates",
            "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
            "functionSignature": "func findDuplicates(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}",
                "output": "[2, 3]"
              },
              {
                "input": "[]int{1, 1, 2, 2, 3, 3}",
                "output": "[1, 2, 3]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[]"
              }
            ],
            "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
            "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Common Elements",
            "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
            "functionSignature": "func hasCommon(a, b []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, []int{3, 4, 5}",
                "output": "true",
                "note": "3 is common"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1}, []int{1}",
                "output": "true"
              }
            ],
            "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
            "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Find Intersection",
            "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
            "functionSignature": "func intersection(a, b []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}, []int{2, 2}",
                "output": "[2]"
              },
              {
                "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}",
                "output": "[9, 4]",
                "note": "or [4, 9] - order doesn't matter"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "[]"
              }
            ],
            "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
            "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result.",
            "difficulty": 4
          },
          {
            "id": "v1",
            "title": "Word Counter",
            "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
            "functionSignature": "func wordCount(s string) map[string]int",
            "testCases": [
              {
                "input": "\"the quick brown fox jumps over the lazy dog\"",
                "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]"
              }
            ],
            "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Most Frequent Element",
            "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
            "functionSignature": "func mostFrequent(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 1, 4, 1}",
                "output": "1",
                "note": "1 appears 3 times"
              },
              {
                "input": "[]int{5, 5, 4, 4, 4}",
                "output": "4"
              },
              {
                "input": "[]int{7}",
                "output": "7"
              }
            ],
            "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
            "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "First Unique Character",
            "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
            "functionSignature": "func firstUniqChar(s string) int",
            "testCases": [
              {
                "input": "\"leetcode\"",
                "output": "0",
                "note": "'l' is first unique"
              },
              {
                "input": "\"loveleetcode\"",
                "output": "2",
                "note": "'v' is first unique"
              },
              {
                "input": "\"aabb\"",
                "output": "-1"
              }
            ],
            "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
            "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Is Anagram",
            "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
            "functionSignature": "func isAnagram(s, t string) bool",
            "testCases": [
              {
                "input": "\"anagram\", \"nagaram\"",
                "output": "true"
              },
              {
                "input": "\"rat\", \"car\"",
                "output": "false"
              },
              {
                "input": "\"listen\", \"silent\"",
                "output": "true"
              }
            ],
            "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Can Construct",
            "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
            "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
            "testCases": [
              {
                "input": "\"a\", \"b\"",
                "output": "false"
              },
              {
                "input": "\"aa\", \"aab\"",
                "output": "true"
              },
              {
                "input": "\"aa\", \"ab\"",
                "output": "false",
                "note": "need 2 a's but only 1"
              }
            ],
            "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Majority Element",
            "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
            "functionSignature": "func majorityElement(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 3}",
                "output": "3"
              },
              {
                "input": "[]int{2, 2, 1, 1, 1, 2, 2}",
                "output": "2"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "1"
              }
            ],
            "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1\n}",
            "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_8",
        "block": 3,
        "difficulty": 3,
        "concept": "Swap Pattern",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "tuple assignment (a, b = b, a)"
          },
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "slice indexing"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Use a temp variable: temp = a, a = b, b = temp (three operations).",
          "bestApproach": "Go's simultaneous assignment: a, b = b, a (evaluates right side first, then assigns).",
          "typical": "Typically O(1) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Swap Elements",
            "description": "Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.",
            "functionSignature": "func swap(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1,2,3}, 0, 2",
                "output": "[3,2,1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b."
              },
              {
                "title": "üí° Hint",
                "content": "Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Simultaneous assignment: left, right = right, left\n(Both sides evaluated before assignment - nothing lost!)</pre>"
              }
            ],
            "solution": "func swap(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Swap Using Temp",
            "description": "Write <code>func swapWithTemp(nums []int, i, j int)</code> that swaps elements using a temporary variable (not Go's simultaneous assignment).",
            "functionSignature": "func swapWithTemp(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 0, 3",
                "output": "[4,2,3,1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "The classic 3-step swap: save one value, overwrite it, then use the saved value."
              },
              {
                "title": "üí° Hint",
                "content": "temp := nums[i], then nums[i] = nums[j], then nums[j] = temp."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. temp := nums[i]  // save first value\n2. nums[i] = nums[j]  // overwrite with second\n3. nums[j] = temp  // put saved value in second spot</pre>"
              }
            ],
            "solution": "func swapWithTemp(nums []int, i, j int) {\n    temp := nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Swap Adjacent Pairs",
            "description": "Write <code>func swapPairs(nums []int)</code> that swaps elements at indices 0&1, 2&3, 4&5, etc. If odd length, last element stays.",
            "functionSignature": "func swapPairs(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}",
                "output": "[2,1,4,3,5]"
              },
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,1,4,3]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "How do you swap two values without losing one of them? Think about what happens if you just write a = b."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through the slice incrementing by 2 each time. Use Go's simultaneous assignment to swap pairs: nums[i], nums[i+1] = nums[i+1], nums[i]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Loop with i += 2\n2. Check i+1 < len to avoid out of bounds\n3. Swap: nums[i], nums[i+1] = nums[i+1], nums[i]</pre>"
              }
            ],
            "solution": "func swapPairs(nums []int) {\n    for i := 0; i+1 < len(nums); i += 2 {\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Swap First Two",
            "description": "Write <code>func swapFirstTwo(nums []int)</code> that swaps the elements at index 0 and index 1. Assume slice has at least 2 elements.",
            "functionSignature": "func swapFirstTwo(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,1,3,4]"
              },
              {
                "input": "[]int{5,10}",
                "output": "[10,5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is just one swap - no loop needed. What indices do you need?"
              },
              {
                "title": "üí° Hint",
                "content": "Swap nums[0] and nums[1] using simultaneous assignment."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[0], nums[1] = nums[1], nums[0]</pre>"
              }
            ],
            "solution": "func swapFirstTwo(nums []int) {\n    nums[0], nums[1] = nums[1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Swap Middle Two",
            "description": "Write <code>func swapMiddle(nums []int)</code> that swaps the two middle elements. Assume even length.",
            "functionSignature": "func swapMiddle(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[1,3,2,4]"
              },
              {
                "input": "[]int{10,20,30,40,50,60}",
                "output": "[10,20,40,30,50,60]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For a slice of length n, the two middle elements are at indices n/2-1 and n/2."
              },
              {
                "title": "üí° Hint",
                "content": "Calculate mid := len(nums)/2. Then swap nums[mid-1] and nums[mid]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>mid := len(nums) / 2\nnums[mid-1], nums[mid] = nums[mid], nums[mid-1]</pre>"
              }
            ],
            "solution": "func swapMiddle(nums []int) {\n    mid := len(nums) / 2\n    nums[mid-1], nums[mid] = nums[mid], nums[mid-1]\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Swap at Offset",
            "description": "Write <code>func swapAtOffset(nums []int, k int)</code> that swaps element at index k with element at index len-1-k (mirror positions from each end).",
            "functionSignature": "func swapAtOffset(nums []int, k int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}, 1",
                "output": "[1,4,3,2,5]",
                "note": "swaps index 1 with index 3"
              },
              {
                "input": "[]int{1,2,3,4,5}, 0",
                "output": "[5,2,3,4,1]",
                "note": "swaps index 0 with index 4 (same as swapEnds)"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "The mirror position of index k from the start is len-1-k from the end."
              },
              {
                "title": "üí° Hint",
                "content": "Swap nums[k] with nums[len(nums)-1-k]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]</pre>"
              }
            ],
            "solution": "func swapAtOffset(nums []int, k int) {\n    nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Swap Min and Max",
            "description": "Write <code>func swapMinMax(nums []int)</code> that finds the minimum and maximum elements and swaps their positions.",
            "functionSignature": "func swapMinMax(nums []int)",
            "testCases": [
              {
                "input": "[]int{3,1,4,1,5}",
                "output": "[3,5,4,1,1]"
              },
              {
                "input": "[]int{5,2,8,1}",
                "output": "[5,2,1,8]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "First you need to find WHERE the min and max are (their indices), then swap the elements at those positions."
              },
              {
                "title": "üí° Hint",
                "content": "Track minIdx and maxIdx as you loop. Start with both at 0. Update minIdx when you find a smaller value, maxIdx when you find a larger value. Then swap at the end."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Initialize minIdx = 0, maxIdx = 0\n2. Loop through slice:\n   - nums[i] < nums[minIdx]? ‚Üí minIdx = i\n   - nums[i] > nums[maxIdx]? ‚Üí maxIdx = i\n3. Swap: nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]</pre>"
              }
            ],
            "solution": "func swapMinMax(nums []int) {\n    minIdx, maxIdx := 0, 0\n    for i := range nums {\n        if nums[i] < nums[minIdx] { minIdx = i }\n        if nums[i] > nums[maxIdx] { maxIdx = i }\n    }\n    nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]\n}",
            "difficulty": 3
          },
          {
            "id": "v8",
            "title": "Rotate Left by One",
            "description": "Write <code>func rotateLeft(nums []int)</code> that shifts all elements one position left, wrapping the first element to the end. E.g., [1,2,3,4] ‚Üí [2,3,4,1].",
            "functionSignature": "func rotateLeft(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[2,3,4,1]"
              },
              {
                "input": "[]int{5,10,15}",
                "output": "[10,15,5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to save the first element, shift everything left, then put the saved element at the end."
              },
              {
                "title": "üí° Hint",
                "content": "Save first := nums[0]. Loop from i=0 to len-2, copying nums[i+1] to nums[i]. Finally set nums[len-1] = first."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Save first element: first := nums[0]\n2. Shift elements left: for i := 0; i < len-1; i++ ‚Üí nums[i] = nums[i+1]\n3. Place first at end: nums[len-1] = first</pre>"
              }
            ],
            "solution": "func rotateLeft(nums []int) {\n    if len(nums) == 0 { return }\n    first := nums[0]\n    for i := 0; i < len(nums)-1; i++ {\n        nums[i] = nums[i+1]\n    }\n    nums[len(nums)-1] = first\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Swap Halves",
            "description": "Write <code>func swapHalves(nums []int)</code> that swaps the first half with the second half. For [1,2,3,4] ‚Üí [3,4,1,2]. Assume even length.",
            "functionSignature": "func swapHalves(nums []int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "[3,4,1,2]"
              },
              {
                "input": "[]int{10,20,30,40,50,60}",
                "output": "[40,50,60,10,20,30]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to swap element 0 with element n/2, element 1 with element n/2+1, etc. How many swaps is that?"
              },
              {
                "title": "üí° Hint",
                "content": "Loop from i=0 to len/2. Each iteration swaps nums[i] with nums[i + len/2]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Calculate mid := len(nums) / 2\n2. Loop i from 0 to mid:\n   - Swap nums[i] with nums[i + mid]\n</pre>"
              }
            ],
            "solution": "func swapHalves(nums []int) {\n    mid := len(nums) / 2\n    for i := 0; i < mid; i++ {\n        nums[i], nums[i+mid] = nums[i+mid], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Bubble Up",
            "description": "Write <code>func bubbleUp(nums []int, idx int)</code> that 'bubbles' the element at idx towards the front by swapping with its left neighbor until it reaches index 0.",
            "functionSignature": "func bubbleUp(nums []int, idx int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 3",
                "output": "[4,1,2,3]",
                "note": "4 bubbles from idx 3 to idx 0"
              },
              {
                "input": "[]int{5,10,15}, 1",
                "output": "[10,5,15]",
                "note": "10 bubbles from idx 1 to idx 0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Start at idx and work backwards to 0, swapping adjacent elements each step."
              },
              {
                "title": "üí° Hint",
                "content": "Loop from idx down to 1: for i := idx; i > 0; i--. Each iteration swap nums[i] with nums[i-1]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. for i := idx; i > 0; i--\n2.   swap nums[i] and nums[i-1]\n(Element 'bubbles' left one position each iteration)</pre>"
              }
            ],
            "solution": "func bubbleUp(nums []int, idx int) {\n    for i := idx; i > 0; i-- {\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    }\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Swap If Out of Order",
            "description": "Write <code>func swapIfGreater(nums []int, i, j int)</code> that swaps elements at i and j only if nums[i] > nums[j]. This is a building block for sorting!",
            "functionSignature": "func swapIfGreater(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{5,2,8,1}, 0, 1",
                "output": "[2,5,8,1]",
                "note": "5 > 2, so swap"
              },
              {
                "input": "[]int{1,5,3,4}, 0, 1",
                "output": "[1,5,3,4]",
                "note": "1 < 5, no swap"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check if the first element is greater. If yes, swap. If no, do nothing."
              },
              {
                "title": "üí° Hint",
                "content": "Use an if statement: if nums[i] > nums[j], then do the swap."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if nums[i] > nums[j] {\n    nums[i], nums[j] = nums[j], nums[i]\n}</pre>"
              }
            ],
            "solution": "func swapIfGreater(nums []int, i, j int) {\n    if nums[i] > nums[j] {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v12",
            "title": "Move to Front",
            "description": "Write <code>func moveToFront(nums []int, idx int)</code> that moves the element at idx to the front, shifting other elements right. E.g., [1,2,3,4] with idx=2 ‚Üí [3,1,2,4].",
            "functionSignature": "func moveToFront(nums []int, idx int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}, 2",
                "output": "[3,1,2,4]"
              },
              {
                "input": "[]int{10,20,30,40}, 3",
                "output": "[40,10,20,30]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Save the element at idx. Shift elements from 0 to idx-1 one position right. Put saved element at front."
              },
              {
                "title": "üí° Hint",
                "content": "Save val := nums[idx]. Loop backwards from idx down to 1, copying nums[i-1] to nums[i]. Set nums[0] = val."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Save element: val := nums[idx]\n2. Shift right: for i := idx; i > 0; i-- ‚Üí nums[i] = nums[i-1]\n3. Place at front: nums[0] = val</pre>"
              }
            ],
            "solution": "func moveToFront(nums []int, idx int) {\n    val := nums[idx]\n    for i := idx; i > 0; i-- {\n        nums[i] = nums[i-1]\n    }\n    nums[0] = val\n}",
            "difficulty": 2
          },
          {
            "id": "v1",
            "title": "Reverse a String",
            "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
            "functionSignature": "func reverse(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"‰∏ñÁïå\"",
                "output": "\"√ß¬ï¬å√§¬∏¬ñ\""
              },
              {
                "input": "\"GoüöÄ\"",
                "output": "\"üöÄoG\""
              }
            ],
            "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Is Palindrome",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
            "functionSignature": "func isPalindrome(s string) bool",
            "testCases": [
              {
                "input": "\"A man, a plan, a canal: Panama\"",
                "output": "true"
              },
              {
                "input": "\"race a car\"",
                "output": "false"
              },
              {
                "input": "\"Was it a car or a cat I saw?\"",
                "output": "true"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Reverse Words in String",
            "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
            "functionSignature": "func reverseWords(s string) string",
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"world hello\""
              },
              {
                "input": "\"the sky is blue\"",
                "output": "\"blue is sky the\""
              },
              {
                "input": "\"Go\"",
                "output": "\"Go\""
              }
            ],
            "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
            "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Reverse Only Letters",
            "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
            "functionSignature": "func reverseOnlyLetters(s string) string",
            "testCases": [
              {
                "input": "\"a-bC-dEf-ghIj\"",
                "output": "\"j-Ih-gfE-dCba\""
              },
              {
                "input": "\"ab-cd\"",
                "output": "\"dc-ba\""
              },
              {
                "input": "\"Test1ng-Leet=code-Q!\"",
                "output": "\"Qedo1teleC-test=gnin-T!\"",
                "note": "wait that's wrong"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
            "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Valid Palindrome II",
            "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
            "functionSignature": "func validPalindromeII(s string) bool",
            "testCases": [
              {
                "input": "\"aba\"",
                "output": "true",
                "note": "already palindrome"
              },
              {
                "input": "\"abca\"",
                "output": "true",
                "note": "remove 'c' or 'b'"
              },
              {
                "input": "\"abc\"",
                "output": "false"
              }
            ],
            "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
            "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Rotate String Left",
            "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
            "functionSignature": "func rotateLeft(s string, k int) string",
            "testCases": [
              {
                "input": "\"abcdef\", 2",
                "output": "\"cdefab\""
              },
              {
                "input": "\"hello\", 1",
                "output": "\"elloh\""
              },
              {
                "input": "\"Go\", 4",
                "output": "\"Go\"",
                "note": "k=4 is same as k=0 for len=2"
              }
            ],
            "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)\n    \n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
            "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_9",
        "block": 3,
        "difficulty": 3,
        "concept": "Two-Pointer Comparison",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "two-variable initialization (i, j := ...)"
          },
          {
            "url": "https://go.dev/ref/spec#Comparison_operators",
            "title": "Go Spec: Comparison operators",
            "note": "!= for mismatch detection"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a reversed copy of the array, then compare element-by-element with the original.",
          "bestApproach": "Compare from both ends simultaneously, moving inward; stop as soon as mismatch found.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Palindrome Check",
            "description": "Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.",
            "functionSignature": "func isPalindrome(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1,2,3,2,1}",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?"
              },
              {
                "title": "üí° Hint",
                "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Compare elements at both pointers\n   - Mismatch? ‚Üí return false\n   - Move both pointers inward\n3. Return true (all pairs matched)</pre>"
              }
            ],
            "solution": "func isPalindrome(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}",
            "difficulty": 3
          },
          {
            "id": "v2",
            "title": "String Palindrome",
            "description": "Write <code>func isSymmetric(s string) bool</code>.",
            "functionSignature": "func isSymmetric(s string) bool",
            "testCases": [
              {
                "input": "\"racecar\"",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?"
              },
              {
                "title": "üí° Hint",
                "content": "Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Compare elements at both pointers\n   - Mismatch? ‚Üí return false\n   - Move both pointers inward\n3. Return true (all pairs matched)</pre>"
              }
            ],
            "solution": "func isSymmetric(s string) bool {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        if r[i] != r[j] { return false }\n    }\n    return true\n}",
            "difficulty": 3
          },
          {
            "id": "v3",
            "title": "Is Sorted Ascending",
            "description": "Write <code>func isSorted(nums []int) bool</code> - true if each element <= the next.",
            "functionSignature": "func isSorted(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1,2,3,4}",
                "output": "true"
              },
              {
                "input": "[]int{1,3,2,4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To verify sorted order, what pairs of elements do you need to compare? Do you need to compare every element to every other element?"
              },
              {
                "title": "üí° Hint",
                "content": "Check adjacent pairs: compare nums[i] with nums[i+1]. If any pair is out of order (nums[i] > nums[i+1]), return false immediately."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] > nums[i+1] ‚Üí return false\n4. Return true (all pairs in order)</pre>"
              }
            ],
            "solution": "func isSorted(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] > nums[i+1] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "Has Adjacent Duplicates",
            "description": "Write <code>func hasAdjacentDups(nums []int) bool</code> - true if any two adjacent elements are equal.",
            "functionSignature": "func hasAdjacentDups(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to compare each element with its neighbor. What pairs should you check?"
              },
              {
                "title": "üí° Hint",
                "content": "Loop through indices 0 to len-2. Compare nums[i] with nums[i+1]. If they're equal, you found adjacent duplicates."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] == nums[i+1] ‚Üí return true\n4. Return false (no adjacent duplicates)</pre>"
              }
            ],
            "solution": "func hasAdjacentDups(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] == nums[i+1] { return true }\n    }\n    return false\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "All Increasing",
            "description": "Write <code>func allIncreasing(nums []int) bool</code> - true if strictly increasing (each element < next).",
            "functionSignature": "func allIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Strictly increasing means each element must be LESS than (not equal to) the next."
              },
              {
                "title": "üí° Hint",
                "content": "Compare adjacent pairs. If nums[i] >= nums[i+1], it's not strictly increasing."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Loop through indices 0 to len-2\n2. Compare each element with the next\n3. If nums[i] >= nums[i+1] ‚Üí return false\n4. Return true (all strictly increasing)</pre>"
              }
            ],
            "solution": "func allIncreasing(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] >= nums[i+1] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Starts And Ends Same",
            "description": "Write <code>func startsEndsSame(nums []int, k int) bool</code> - true if first k elements match last k elements.",
            "functionSignature": "func startsEndsSame(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1, 2}, 2",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to compare the first k elements with the last k elements. What are the corresponding indices?"
              },
              {
                "title": "üí° Hint",
                "content": "Element at index i should match element at index len-k+i. Check all k pairs."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Loop i from 0 to k-1\n2. Compare nums[i] with nums[len-k+i]\n3. If mismatch ‚Üí return false\n4. Return true (all pairs match)</pre>"
              }
            ],
            "solution": "func startsEndsSame(nums []int, k int) bool {\n    n := len(nums)\n    for i := 0; i < k; i++ {\n        if nums[i] != nums[n-k+i] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Mirror Halves",
            "description": "Write <code>func mirrorHalves(nums []int) bool</code> - true if first half mirrors second half. Assume even length.",
            "functionSignature": "func mirrorHalves(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}",
                "output": "true"
              },
              {
                "input": "[]int{5, 3, 3, 5}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare first half with second half in reverse. Element at index i should match element at index n-1-i."
              },
              {
                "title": "üí° Hint",
                "content": "Use two pointers starting at both ends, moving inward. Compare only the first n/2 pairs."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left = 0, right = len-1\n2. While left < right:\n   - nums[left] != nums[right]? ‚Üí return false\n   - left++, right--\n3. Return true</pre>"
              }
            ],
            "solution": "func mirrorHalves(nums []int) bool {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        if nums[i] != nums[j] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Valid Score Sequence",
            "description": "Write <code>func validScoreSeq(scores []int) bool</code> - true if scores never decrease by more than 10 points between adjacent rounds.",
            "functionSignature": "func validScoreSeq(scores []int) bool",
            "testCases": [
              {
                "input": "[]int{100, 95, 98, 90}",
                "output": "true"
              },
              {
                "input": "[]int{100, 85, 90}",
                "output": "false",
                "note": "100 to 85 is -15"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare adjacent scores. If any drop is more than 10, return false."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through indices, compare scores[i] with scores[i+1]. Check if scores[i] - scores[i+1] > 10."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - scores[i] - scores[i+1] > 10?\n     ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func validScoreSeq(scores []int) bool {\n    for i := 0; i < len(scores)-1; i++ {\n        if scores[i] - scores[i+1] > 10 { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Balanced Brackets",
            "description": "Write <code>func balancedBrackets(s string) bool</code> - true if string has equal '[' and ']' counts AND they're balanced left-to-right.",
            "functionSignature": "func balancedBrackets(s string) bool",
            "testCases": [
              {
                "input": "\"[[][]]\"",
                "output": "true"
              },
              {
                "input": "\"[[]\"",
                "output": "false"
              },
              {
                "input": "\"][[\"",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track a running count: +1 for '[', -1 for ']'. Count should never go negative, and should be 0 at end."
              },
              {
                "title": "üí° Hint",
                "content": "Use a counter variable. If it ever goes negative, we have ']' before matching '['. Must end at 0."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each char:\n   - '[' ‚Üí count++\n   - ']' ‚Üí count--\n   - count < 0? ‚Üí return false\n3. Return count == 0</pre>"
              }
            ],
            "solution": "func balancedBrackets(s string) bool {\n    count := 0\n    for _, c := range s {\n        if c == '[' { count++ }\n        if c == ']' { count-- }\n        if count < 0 { return false }\n    }\n    return count == 0\n}",
            "difficulty": 3
          },
          {
            "id": "v10",
            "title": "First Last Equal",
            "description": "Write <code>func firstLastEqual(nums []int) bool</code> - true if first element equals last element.",
            "functionSignature": "func firstLastEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{5, 2, 3, 5}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to compare the first and last elements. What are their indices?"
              },
              {
                "title": "üí° Hint",
                "content": "First element is at index 0, last is at index len(nums)-1. Just compare them directly."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Get first element: nums[0]\n2. Get last element: nums[len(nums)-1]\n3. Return whether they're equal</pre>"
              }
            ],
            "solution": "func firstLastEqual(nums []int) bool {\n    if len(nums) == 0 { return true }\n    return nums[0] == nums[len(nums)-1]\n}",
            "difficulty": 1
          },
          {
            "id": "v11",
            "title": "No Decreases",
            "description": "Write <code>func noDecreases(nums []int) bool</code> - true if array never decreases (each element >= previous). Adjacent pair comparison.",
            "functionSignature": "func noDecreases(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 3, 2, 4}",
                "output": "false",
                "note": "3‚Üí2 is a decrease"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check adjacent pairs: each element should be >= the one before it."
              },
              {
                "title": "üí° Hint",
                "content": "Loop from index 1 onwards. Compare nums[i] with nums[i-1]. If nums[i] < nums[i-1], return false."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i from 1 to len:\n   - If nums[i] < nums[i-1] ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func noDecreases(nums []int) bool {\n    for i := 1; i < len(nums); i++ {\n        if nums[i] < nums[i-1] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v12",
            "title": "Sum Symmetry",
            "description": "Write <code>func sumSymmetry(nums []int) bool</code> - true if sum of first half equals sum of second half. Assume even length. Two-pointer to compare halves.",
            "functionSignature": "func sumSymmetry(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 3, 2, 1}",
                "output": "true",
                "note": "1+2+3 = 3+2+1"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false",
                "note": "1+2 √¢¬â¬† 3+4"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Calculate sum of first half, then sum of second half, then compare."
              },
              {
                "title": "üí° Hint",
                "content": "Loop from 0 to mid to get first sum. Loop from mid to end to get second sum. Compare them."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. mid := len/2\n2. sum1 := sum of nums[0:mid]\n3. sum2 := sum of nums[mid:]\n4. Return sum1 == sum2</pre>"
              }
            ],
            "solution": "func sumSymmetry(nums []int) bool {\n    mid := len(nums) / 2\n    sum1, sum2 := 0, 0\n    for i := 0; i < mid; i++ {\n        sum1 += nums[i]\n    }\n    for i := mid; i < len(nums); i++ {\n        sum2 += nums[i]\n    }\n    return sum1 == sum2\n}",
            "difficulty": 1
          },
          {
            "id": "v13",
            "title": "Distance Increasing",
            "description": "Write <code>func distanceIncreasing(nums []int) bool</code> - true if distance between adjacent elements is always increasing. Distance = abs(nums[i] - nums[i-1]).",
            "functionSignature": "func distanceIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 5, 10}",
                "output": "true",
                "note": "Distances: 1, 3, 5 (increasing)"
              },
              {
                "input": "[]int{1, 3, 4, 8}",
                "output": "false",
                "note": "Distances: 2, 1, 4 (not increasing)"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Calculate distance between each adjacent pair. Check if distances form an increasing sequence."
              },
              {
                "title": "üí° Hint",
                "content": "Track previous distance. For each pair, calculate current distance, compare with previous, update previous."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. prevDist := first pair distance\n2. For each subsequent pair:\n   - Calculate currDist\n   - If currDist <= prevDist ‚Üí return false\n   - prevDist = currDist\n3. Return true</pre>"
              }
            ],
            "solution": "func distanceIncreasing(nums []int) bool {\n    if len(nums) < 3 { return true }\n    abs := func(x int) int {\n        if x < 0 { return -x }\n        return x\n    }\n    prevDist := abs(nums[1] - nums[0])\n    for i := 2; i < len(nums); i++ {\n        currDist := abs(nums[i] - nums[i-1])\n        if currDist <= prevDist { return false }\n        prevDist = currDist\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v1",
            "title": "Maximum Sum Subarray of Size K",
            "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
            "functionSignature": "func maxSumSubarray(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 5, 1, 3, 2}, 3",
                "output": "9",
                "note": "subarray [5,1,3]"
              },
              {
                "input": "[]int{2, 3, 4, 1, 5}, 2",
                "output": "7",
                "note": "subarray [3,4]"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2"
              }
            ],
            "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space.",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Longest Substring Without Repeating",
            "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
            "functionSignature": "func lengthOfLongestSubstring(s string) int",
            "testCases": [
              {
                "input": "\"abcabcbb\"",
                "output": "3",
                "note": "\"abc\""
              },
              {
                "input": "\"bbbbb\"",
                "output": "1",
                "note": "\"b\""
              },
              {
                "input": "\"pwwkew\"",
                "output": "3",
                "note": "\"wke\""
              }
            ],
            "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Minimum Size Subarray Sum",
            "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
            "functionSignature": "func minSubarrayLen(target int, nums []int) int",
            "testCases": [
              {
                "input": "7, []int{2, 3, 1, 2, 4, 3}",
                "output": "2",
                "note": "[4,3] sums to 7"
              },
              {
                "input": "4, []int{1, 4, 4}",
                "output": "1",
                "note": "[4] alone >= 4"
              },
              {
                "input": "11, []int{1, 1, 1, 1}",
                "output": "0",
                "note": "can't reach 11"
              }
            ],
            "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
            "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern.",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Average of Subarrays of Size K",
            "description": "Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums []int, k int) []float64</code>",
            "functionSignature": "func averageOfSubarrays(nums []int, k int) []float64",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5",
                "output": "[2.2, 2.8, 2.4, 3.6, 2.8]"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 2",
                "output": "[1.5, 2.5, 3.5]"
              }
            ],
            "solution": "func averageOfSubarrays(nums []int, k int) []float64 {\n    result := []float64{}\n    windowSum := 0\n    \n    for i := 0; i < len(nums); i++ {\n        windowSum += nums[i]\n        \n        if i >= k-1 {\n            result = append(result, float64(windowSum)/float64(k))\n            windowSum -= nums[i-k+1]\n        }\n    }\n    return result\n}",
            "solutionNotes": "Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Contains Duplicate Within K Distance",
            "description": "Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k. <code>func containsNearbyDuplicate(nums []int, k int) bool</code>",
            "functionSignature": "func containsNearbyDuplicate(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 1, 1}, 1",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 1, 2, 3}, 2",
                "output": "false"
              }
            ],
            "solution": "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen := make(map[int]bool)\n    \n    for i, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n        \n        if i >= k {\n            delete(seen, nums[i-k])\n        }\n    }\n    return false\n}",
            "solutionNotes": "Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove elements that leave the window.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Max Consecutive Ones III",
            "description": "Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k 0's. <code>func longestOnes(nums []int, k int) int</code>",
            "functionSignature": "func longestOnes(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1,1,1,0,0,0,1,1,1,1,0}, 2",
                "output": "6",
                "note": "flip 0's at indices 5 and 10"
              },
              {
                "input": "[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3",
                "output": "10"
              }
            ],
            "solution": "func longestOnes(nums []int, k int) int {\n    left := 0\n    zeros := 0\n    maxLen := 0\n    \n    for right := 0; right < len(nums); right++ {\n        if nums[right] == 0 {\n            zeros++\n        }\n        \n        for zeros > k {\n            if nums[left] == 0 {\n                zeros--\n            }\n            left++\n        }\n        \n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window size.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_10",
        "block": 4,
        "difficulty": 4,
        "concept": "Two-Pointer Swap",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "simultaneous swap (a, b = b, a)"
          },
          {
            "url": "https://go.dev/blog/slices",
            "title": "Go Blog: Slices",
            "note": "in-place modifications"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Create a new array and build it by iterating backwards through the original.",
          "bestApproach": "Start pointers at both ends, swap elements in place, move pointers inward until they meet.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Reverse Slice",
            "description": "Write <code>func reverse(nums []int) []int</code> that reverses in place.",
            "functionSignature": "func reverse(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}",
                "output": "[5,4,3,2,1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "üí° Hint",
                "content": "Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Swap elements at left and right\n   - Move both pointers inward\n3. Done (reversed in place)</pre>"
              }
            ],
            "solution": "func reverse(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    return nums\n}",
            "difficulty": 3
          },
          {
            "id": "v2",
            "title": "Reverse String",
            "description": "Write <code>func reverseString(s string) string</code> that reverses a string.",
            "functionSignature": "func reverseString(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"Go\"",
                "output": "\"oG\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "üí° Hint",
                "content": "Convert to []rune first (strings are immutable). Then use the same two-pointer swap as with slices."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Convert string to []rune\n2. left pointer at start, right pointer at end\n3. While left < right:\n   - Swap runes at left and right\n   - Move both pointers inward\n4. Convert back to string</pre>"
              }
            ],
            "solution": "func reverseString(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}",
            "difficulty": 3
          },
          {
            "id": "v3",
            "title": "Reverse Segment",
            "description": "Write <code>func reverseSegment(nums []int, start, end int)</code> that reverses elements from index start to end (inclusive).",
            "functionSignature": "func reverseSegment(nums []int, start, end int)",
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}, 1, 3",
                "output": "[1,4,3,2,5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?"
              },
              {
                "title": "üí° Hint",
                "content": "Same two-pointer pattern, but start at 'start' instead of 0, and end at 'end' instead of len-1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left pointer at start, right pointer at end\n2. While left < right:\n   - Swap elements at left and right\n   - Move both pointers inward\n3. Done (segment reversed in place)</pre>"
              }
            ],
            "solution": "func reverseSegment(nums []int, start, end int) {\n    for i, j := start, end; i < j; i, j = i+1, j-1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}",
            "difficulty": 3
          },
          {
            "id": "v4",
            "title": "Swap First and Last",
            "description": "Write <code>func swapEnds(nums []int) []int</code> that swaps the first and last elements.",
            "functionSignature": "func swapEnds(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 2, 3, 4, 1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You only need to swap two specific elements. What are their indices?"
              },
              {
                "title": "üí° Hint",
                "content": "First element is at index 0, last is at index len-1. Use Go's simultaneous assignment to swap."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Identify indices: first = 0, last = len-1\n2. Swap: nums[0], nums[last] = nums[last], nums[0]\n3. Return the modified slice</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) []int {\n    n := len(nums)\n    nums[0], nums[n-1] = nums[n-1], nums[0]\n    return nums\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Rotate Right by One",
            "description": "Write <code>func rotateRight(nums []int) []int</code> that moves the last element to the front.",
            "functionSignature": "func rotateRight(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 1, 2, 3, 4]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "The last element goes to index 0, and all other elements shift right by one position."
              },
              {
                "title": "üí° Hint",
                "content": "Save the last element. Then loop backwards, shifting each element to the right. Finally place the saved element at index 0."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Save last element: temp = nums[len-1]\n2. Shift all elements right: nums[i] = nums[i-1]\n3. Place saved element at front: nums[0] = temp</pre>"
              }
            ],
            "solution": "func rotateRight(nums []int) []int {\n    n := len(nums)\n    last := nums[n-1]\n    for i := n-1; i > 0; i-- {\n        nums[i] = nums[i-1]\n    }\n    nums[0] = last\n    return nums\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Mirror Slice",
            "description": "Write <code>func mirror(nums []int) []int</code> that makes the second half mirror the first half. For [1,2,3,4] ‚Üí [1,2,2,1].",
            "functionSignature": "func mirror(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[1, 2, 2, 1]"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[1, 2, 3, 2, 1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to copy elements from the first half to matching positions in the second half."
              },
              {
                "title": "üí° Hint",
                "content": "Use two pointers: one from start, one from end. Copy nums[i] to nums[j] as long as i < j."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left pointer at 0, right pointer at len-1\n2. While left < right:\n   - Copy nums[left] to nums[right]\n   - Move both pointers inward\n3. Return modified slice</pre>"
              }
            ],
            "solution": "func mirror(nums []int) []int {\n    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {\n        nums[j] = nums[i]\n    }\n    return nums\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "Swap Ends Only",
            "difficulty": 1,
            "description": "Write <code>func swapEnds(nums []int)</code> that swaps ONLY the first and last elements. Modify the slice in place.",
            "functionSignature": "func swapEnds(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "[5, 2, 3, 4, 1]",
                "note": "Only first and last swapped"
              },
              {
                "input": "[]int{10, 20}",
                "output": "[20, 10]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is just a single swap operation - no loop needed!"
              },
              {
                "title": "üí° Hint",
                "content": "Swap nums[0] and nums[len(nums)-1] using Go's simultaneous assignment."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) {\n    if len(nums) > 1 {\n        nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n    }\n}"
          },
          {
            "id": "v8",
            "title": "Reverse First N",
            "difficulty": 1,
            "description": "Write <code>func reverseFirstN(nums []int, n int)</code> that reverses only the first n elements using two pointers.",
            "functionSignature": "func reverseFirstN(nums []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}, 3",
                "output": "[3, 2, 1, 4, 5]",
                "note": "Only first 3 elements reversed"
              },
              {
                "input": "[]int{10, 20, 30, 40}, 2",
                "output": "[20, 10, 30, 40]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is like reversing a slice, but you only go up to position n instead of the end."
              },
              {
                "title": "üí° Hint",
                "content": "Use two pointers: left starts at 0, right starts at n-1 (not len-1!). Swap and move inward until they meet."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left := 0, right := n-1\n2. While left < right:\n   - Swap nums[left] and nums[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseFirstN(nums []int, n int) {\n    if n > len(nums) {\n        n = len(nums)\n    }\n    left, right := 0, n-1\n    for left < right {\n        nums[left], nums[right] = nums[right], nums[left]\n        left++\n        right--\n    }\n}"
          },
          {
            "id": "v9",
            "title": "Move Zeros to End",
            "description": "Write <code>func moveZeros(nums []int) []int</code> that moves all zeros to the end, preserving order of non-zeros.",
            "functionSignature": "func moveZeros(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[]int{1, 3, 12, 0, 0}"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[]int{1, 0, 0}"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Collect all non-zero elements first, then append zeros to fill the rest."
              },
              {
                "title": "üí° Hint",
                "content": "Filter non-zeros into result, then append len(nums) - len(result) zeros."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []int{}\n2. For each num:\n   - num != 0? ‚Üí append to result\n3. While len(result) < len(nums):\n   - append 0\n4. Return result</pre>"
              }
            ],
            "solution": "func moveZeros(nums []int) []int {\n    result := []int{}\n    for _, num := range nums {\n        if num != 0 {\n            result = append(result, num)\n        }\n    }\n    for len(result) < len(nums) {\n        result = append(result, 0)\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Reverse Words in Place",
            "description": "Write <code>func reverseWords(words []string)</code> that reverses the order of words in the slice in-place.",
            "functionSignature": "func reverseWords(words []string)",
            "testCases": [
              {
                "input": "[]string{\"hello\", \"world\", \"go\"}",
                "output": "[\"go\", \"world\", \"hello\"]"
              },
              {
                "input": "[]string{\"a\", \"b\"}",
                "output": "[\"b\", \"a\"]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Two-pointer swap pattern: swap from both ends moving toward center."
              },
              {
                "title": "üí° Hint",
                "content": "left starts at 0, right at len-1. Swap and move inward until they meet."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left = 0, right = len-1\n2. While left < right:\n   - Swap words[left] √¢¬Ü¬î words[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseWords(words []string) {\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v11",
            "title": "Reverse Outer Pairs",
            "difficulty": 1,
            "description": "Write <code>func reverseOuterPairs(nums []int, k int)</code> that swaps k pairs from both ends: swap nums[0]√¢¬Ü¬înums[len-1], nums[1]√¢¬Ü¬înums[len-2], ..., k times. Two-pointer inward movement.",
            "functionSignature": "func reverseOuterPairs(nums []int, k int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}, 2",
                "output": "[6, 5, 3, 4, 2, 1]",
                "note": "Swap 2 pairs from ends"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 1",
                "output": "[4, 2, 3, 1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Start with pointers at both ends. Swap, move both inward, repeat k times."
              },
              {
                "title": "üí° Hint",
                "content": "left = 0, right = len-1. Loop k times: swap nums[left] with nums[right], then left++, right--."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. For i from 0 to k:\n   - Swap nums[left] √¢¬Ü¬î nums[right]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func reverseOuterPairs(nums []int, k int) {\n    left, right := 0, len(nums)-1\n    for i := 0; i < k && left < right; i++ {\n        nums[left], nums[right] = nums[right], nums[left]\n        left++\n        right--\n    }\n}"
          },
          {
            "id": "v12",
            "title": "Outer to Inner Copy",
            "difficulty": 1,
            "description": "Write <code>func outerToInner(nums []int)</code> that copies outer elements to inner positions moving inward: [1,2,3,4,5,6] ‚Üí [1,1,6,6,5,6]. Two pointers copy inward.",
            "functionSignature": "func outerToInner(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "[1, 1, 6, 6, 5, 6]",
                "note": "Outer values copy toward center"
              },
              {
                "input": "[]int{10, 20, 30, 40}",
                "output": "[10, 10, 40, 40]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Start pointers at ends. Copy the outer values to the next inner positions, move inward."
              },
              {
                "title": "üí° Hint",
                "content": "left = 0, right = len-1. While left < right-1: save outer values, move pointers inward, write saved values."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. While left < right-1:\n   - Copy nums[left] to nums[left+1]\n   - Copy nums[right] to nums[right-1]\n   - left++, right--</pre>"
              }
            ],
            "solution": "func outerToInner(nums []int) {\n    left, right := 0, len(nums)-1\n    for left < right-1 {\n        leftVal, rightVal := nums[left], nums[right]\n        left++\n        right--\n        nums[left] = leftVal\n        nums[right] = rightVal\n    }\n}"
          },
          {
            "id": "v13",
            "title": "Reverse Alternating Pairs",
            "difficulty": 1,
            "description": "Write <code>func reverseAlternating(nums []int)</code> that reverses every other pair from outside in: swap positions 0√¢¬Ü¬îlast, skip next pair, swap 2√¢¬Ü¬î(last-2), etc. Two pointers with conditional swapping.",
            "functionSignature": "func reverseAlternating(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6, 7, 8}",
                "output": "[8, 2, 7, 4, 5, 6, 3, 1]",
                "note": "Swap pairs at positions (0,7) and (2,5), skip (1,6) and (3,4)"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[4, 2, 3, 1]",
                "note": "Swap (0,3), skip (1,2)"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Start pointers at ends. Swap, move inward by 2 (skip next pair), swap again, repeat."
              },
              {
                "title": "üí° Hint",
                "content": "left = 0, right = len-1. While left < right: swap them, then left += 2, right -= 2 (to skip next pair)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. left := 0, right := len-1\n2. While left < right:\n   - Swap nums[left] √¢¬Ü¬î nums[right]\n   - left += 2, right -= 2</pre>"
              }
            ],
            "solution": "func reverseAlternating(nums []int) {\n    left, right := 0, len(nums)-1\n    for left < right {\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 2\n        right -= 2\n    }\n}"
          },
          {
            "id": "v1",
            "title": "Remove Duplicates from Sorted Array",
            "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
            "functionSignature": "func removeDuplicates(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2}",
                "output": "2",
                "note": "array becomes [1, 2, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 2, 2, 3}",
                "output": "4",
                "note": "array becomes [0, 1, 2, 3, _, _, _]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "3"
              }
            ],
            "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Remove Element",
            "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
            "functionSignature": "func removeElement(nums []int, val int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 2, 3}, 3",
                "output": "2",
                "note": "array becomes [2, 2, _, _]"
              },
              {
                "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2",
                "output": "5"
              },
              {
                "input": "[]int{1}, 1",
                "output": "0"
              }
            ],
            "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Move Zeroes",
            "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
            "functionSignature": "func moveZeroes(nums []int)",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[1, 3, 12, 0, 0]"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[1, 0, 0]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 2, 3]",
                "note": "no zeroes"
              }
            ],
            "solution": "func moveZeroes(nums []int) {\n    slow := 0\n    \n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
            "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Remove Duplicates II (Allow 2)",
            "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
            "functionSignature": "func removeDuplicatesII(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1, 2, 2, 3}",
                "output": "5",
                "note": "becomes [1, 1, 2, 2, 3, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}",
                "output": "7"
              },
              {
                "input": "[]int{1, 1}",
                "output": "2"
              }
            ],
            "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2\n    for fast := 2; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Sorted Squares",
            "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
            "functionSignature": "func sortedSquares(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-4, -1, 0, 3, 10}",
                "output": "[0, 1, 9, 16, 100]"
              },
              {
                "input": "[]int{-7, -3, 2, 3, 11}",
                "output": "[4, 9, 9, 49, 121]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 4, 9]"
              }
            ],
            "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
            "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Merge Sorted Array",
            "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
            "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3",
                "output": "[1, 2, 2, 3, 5, 6]"
              },
              {
                "input": "[]int{1}, 1, []int{}, 0",
                "output": "[1]"
              },
              {
                "input": "[]int{0}, 0, []int{1}, 1",
                "output": "[1]"
              }
            ],
            "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    p1 := m - 1\n    p2 := n - 1\n    pos := m + n - 1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
            "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_11",
        "block": 4,
        "difficulty": 4,
        "concept": "Map Lookup + Early Return",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "map as a set pattern"
          },
          {
            "url": "https://go.dev/ref/spec#Index_expressions",
            "title": "Go Spec: Index expressions",
            "note": "checking if key exists"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Nested loops: for each element, scan all previous elements to check if it appeared before.",
          "bestApproach": "Track seen elements in a map; check map in O(1) time, return immediately when found.",
          "typical": "Typically O(n) time, O(n) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "First Duplicate Index",
            "description": "Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.",
            "functionSignature": "func firstDupIdx(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1,2,3,2}",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already seen? ‚Üí return (found duplicate!)\n   - Not seen? ‚Üí add to tracker\n3. Loop finished? ‚Üí return not found</pre>"
              }
            ],
            "solution": "func firstDupIdx(nums []int) int {\n    seen := make(map[int]bool)\n    for i, n := range nums {\n        if seen[n] { return i }\n        seen[n] = true\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v2",
            "title": "First Repeat Char",
            "description": "Write <code>func firstRepeat(s string) rune</code> - first repeated char, or 0.",
            "functionSignature": "func firstRepeat(s string) rune",
            "testCases": [
              {
                "input": "\"abcab\"",
                "output": "'a'"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty \"seen\" tracker\n2. For each element:\n   - Already seen? ‚Üí return (found duplicate!)\n   - Not seen? ‚Üí add to tracker\n3. Loop finished? ‚Üí return not found</pre>"
              }
            ],
            "solution": "func firstRepeat(s string) rune {\n    seen := make(map[rune]bool)\n    for _, r := range s {\n        if seen[r] { return r }\n        seen[r] = true\n    }\n    return 0\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Find Missing in Sequence",
            "description": "Write <code>func findMissing(nums []int, n int) int</code> - given numbers 1 to n with one missing, find it.",
            "functionSignature": "func findMissing(nums []int, n int) int",
            "testCases": [
              {
                "input": "[]int{1,2,4,5}, 5",
                "output": "3",
                "note": "3 is missing from 1-5"
              },
              {
                "input": "[]int{2,3,4}, 4",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Put all the numbers you have into a set. Then check which number from 1 to n is not in the set."
              },
              {
                "title": "üí° Hint",
                "content": "First loop: add all nums to a map. Second loop: check 1 to n, return the one not in the map."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Add all nums to a 'have' map\n2. For i from 1 to n:\n   - If !have[i] ‚Üí return i (found missing!)\n3. Return 0 (shouldn't happen)</pre>"
              }
            ],
            "solution": "func findMissing(nums []int, n int) int {\n    have := make(map[int]bool)\n    for _, num := range nums { have[num] = true }\n    for i := 1; i <= n; i++ {\n        if !have[i] { return i }\n    }\n    return 0\n}",
            "difficulty": 3
          },
          {
            "id": "v4",
            "title": "Two Sum Exists",
            "description": "Write <code>func twoSumExists(nums []int, target int) bool</code> - true if any two numbers add to target.",
            "functionSignature": "func twoSumExists(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "true"
              },
              {
                "input": "[]int{2, 7, 11, 15}, 10",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For each number, what complement would you need to see to make the target sum? How can you check if you've seen that complement?"
              },
              {
                "title": "üí° Hint",
                "content": "For each num, check if (target - num) is in your 'seen' set. If yes, you found a pair! If no, add num to seen and continue."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty \"seen\" map\n2. For each num:\n   - complement = target - num\n   - seen[complement]? ‚Üí return true\n   - Add num to seen\n3. Return false</pre>"
              }
            ],
            "solution": "func twoSumExists(nums []int, target int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        if seen[target-n] { return true }\n        seen[n] = true\n    }\n    return false\n}",
            "difficulty": 3
          },
          {
            "id": "v5",
            "title": "All Unique Words",
            "description": "Write <code>func allUnique(words []string) bool</code> - true if no word appears twice.",
            "functionSignature": "func allUnique(words []string) bool",
            "testCases": [
              {
                "input": "[]string{\"go\", \"rust\", \"python\"}",
                "output": "true"
              },
              {
                "input": "[]string{\"go\", \"rust\", \"go\"}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is the inverse of 'has duplicate'. When should you return false?"
              },
              {
                "title": "üí° Hint",
                "content": "Use a map to track seen words. If you ever encounter a word you've already seen, return false. If you finish the loop, return true."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create empty \"seen\" map\n2. For each word:\n   - Already seen? ‚Üí return false\n   - Add to seen\n3. Return true (all unique)</pre>"
              }
            ],
            "solution": "func allUnique(words []string) bool {\n    seen := make(map[string]bool)\n    for _, w := range words {\n        if seen[w] { return false }\n        seen[w] = true\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "First Non-Repeating",
            "description": "Write <code>func firstNonRepeating(s string) rune</code> - first character that appears exactly once, or 0 if all repeat.",
            "functionSignature": "func firstNonRepeating(s string) rune",
            "testCases": [
              {
                "input": "\"aabbccd\"",
                "output": "'d'"
              },
              {
                "input": "\"aabbcc\"",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need TWO passes: first count all characters, then find the first one with count == 1."
              },
              {
                "title": "üí° Hint",
                "content": "First pass: build a frequency map. Second pass: iterate through string again and return the first char with count == 1."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. First pass: count each character\n2. Second pass: for each character\n   - Count == 1? ‚Üí return it\n3. Return 0 (none found)</pre>"
              }
            ],
            "solution": "func firstNonRepeating(s string) rune {\n    counts := make(map[rune]int)\n    for _, r := range s { counts[r]++ }\n    for _, r := range s {\n        if counts[r] == 1 { return r }\n    }\n    return 0\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "Contains Value",
            "difficulty": 1,
            "description": "Write <code>func containsValue(nums []int, target int) bool</code> that returns true if target exists in the slice. Use a map for O(n) solution.",
            "functionSignature": "func containsValue(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 6",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You could use linear search, but this pattern is about using maps. How can a map help you check membership quickly?"
              },
              {
                "title": "üí° Hint",
                "content": "Build a map[int]bool to track which numbers exist. Then check if target is in the map using the comma-ok pattern."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create set map[int]bool\n2. For each num: set[num] = true\n3. Return set[target] exists</pre>"
              }
            ],
            "solution": "func containsValue(nums []int, target int) bool {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        seen[n] = true\n    }\n    return seen[target]\n}"
          },
          {
            "id": "v8",
            "title": "Count Unique",
            "difficulty": 1,
            "description": "Write <code>func countUnique(nums []int) int</code> that returns how many unique/distinct numbers exist in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "Three unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Maps automatically deduplicate! What property of a map tells you how many unique keys it has?"
              },
              {
                "title": "üí° Hint",
                "content": "Add all numbers to a map[int]bool as keys. The map will only keep unique keys. Return len(map)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create set map[int]bool\n2. For each num: set[num] = true\n3. Return len(set)</pre>"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, n := range nums {\n        seen[n] = true\n    }\n    return len(seen)\n}"
          },
          {
            "id": "v9",
            "title": "Employee ID Lookup",
            "description": "Write <code>func employeeName(ids map[int]string, id int) string</code> that returns employee name or \"Unknown\".",
            "functionSignature": "func employeeName(ids map[int]string, id int) string",
            "testCases": [
              {
                "input": "map[int]string{101: \"Alice\", 102: \"Bob\"}, 101",
                "output": "\"Alice\""
              },
              {
                "input": "map[int]string{101: \"Alice\"}, 999",
                "output": "\"Unknown\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Use comma-ok idiom to check if ID exists in map."
              },
              {
                "title": "üí° Hint",
                "content": "name, exists := ids[id]; if exists return name, else return \"Unknown\""
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. name, exists := ids[id]\n2. If exists ‚Üí return name\n3. Return \"Unknown\"</pre>"
              }
            ],
            "solution": "func employeeName(ids map[int]string, id int) string {\n    if name, exists := ids[id]; exists {\n        return name\n    }\n    return \"Unknown\"\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Country Capital",
            "description": "Write <code>func getCapital(capitals map[string]string, country string) (string, bool)</code> that returns capital and whether found.",
            "functionSignature": "func getCapital(capitals map[string]string, country string) (string, bool)",
            "testCases": [
              {
                "input": "map[string]string{\"USA\": \"Washington DC\", \"France\": \"Paris\"}, \"France\"",
                "output": "\"Paris\", true"
              },
              {
                "input": "map[string]string{\"USA\": \"Washington DC\"}, \"Spain\"",
                "output": "\"\", false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is a direct map lookup with comma-ok pattern - return both value and existence."
              },
              {
                "title": "üí° Hint",
                "content": "capital, exists := capitals[country]; return capital, exists"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>capital, exists := capitals[country]\nreturn capital, exists</pre>"
              }
            ],
            "solution": "func getCapital(capitals map[string]string, country string) (string, bool) {\n    capital, exists := capitals[country]\n    return capital, exists\n}",
            "difficulty": 1
          },
          {
            "id": "v1",
            "title": "Two Sum",
            "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
            "functionSignature": "func twoSum(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[0, 1]"
              },
              {
                "input": "[]int{3, 2, 4}, 6",
                "output": "[1, 2]"
              },
              {
                "input": "[]int{3, 3}, 6",
                "output": "[0, 1]"
              }
            ],
            "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "difficulty": 4
          },
          {
            "id": "v2",
            "title": "Two Sum II (Sorted Input)",
            "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
            "functionSignature": "func twoSumSorted(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[1, 2]",
                "note": "1-indexed!"
              },
              {
                "input": "[]int{2, 3, 4}, 6",
                "output": "[1, 3]"
              },
              {
                "input": "[]int{-1, 0}, -1",
                "output": "[1, 2]"
              }
            ],
            "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}\n        } else if sum < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return nil\n}",
            "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum.",
            "difficulty": 4
          },
          {
            "id": "v3",
            "title": "Pair with Difference",
            "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
            "functionSignature": "func pairWithDiff(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{5, 20, 3, 2, 50, 80}, 78",
                "output": "[1, 5]",
                "note": "80 - 2 = 78... wait"
              },
              {
                "input": "[]int{1, 5, 3}, 2",
                "output": "[0, 2]",
                "note": "3 - 1 = 2"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "nil"
              }
            ],
            "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)\n    \n    for i, num := range nums {\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k).",
            "difficulty": 4
          },
          {
            "id": "v4",
            "title": "Count Pairs with Sum",
            "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
            "functionSignature": "func countPairs(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 7, 1}, 6",
                "output": "2",
                "note": "(1,5) and (1,5)"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2",
                "note": "two pairs of 1+1"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "0"
              }
            ],
            "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
            "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting.",
            "difficulty": 4
          },
          {
            "id": "v5",
            "title": "Three Sum Exists",
            "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
            "functionSignature": "func threeSumExists(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{-1, 0, 1, 2}",
                "output": "true",
                "note": "-1 + 0 + 1 = 0"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              },
              {
                "input": "[]int{0, 0, 0}",
                "output": "true"
              }
            ],
            "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
            "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n¬≤) total.",
            "difficulty": 4
          },
          {
            "id": "v6",
            "title": "Subarray Sum Equals K",
            "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
            "functionSignature": "func subarraySum(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1}, 2",
                "output": "2",
                "note": "[1,1] at positions 0-1 and 1-2"
              },
              {
                "input": "[]int{1, 2, 3}, 3",
                "output": "2",
                "note": "[1,2] and [3]"
              },
              {
                "input": "[]int{1, -1, 0}, 0",
                "output": "3"
              }
            ],
            "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1\n    \n    for _, num := range nums {\n        prefixSum += num\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
            "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred.",
            "difficulty": 4
          }
        ]
      },
      {
        "id": "challenge_12",
        "block": 1,
        "difficulty": 1,
        "concept": "Simple Tallying",
        "docLinks": [
          {
            "url": "https://go.dev/blog/maps",
            "title": "Go Blog: Go maps in action",
            "note": "intro to maps"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Loop through and increment a counter when condition matches.",
          "bestApproach": "Same approach - single pass counting is already optimal.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Specific Value",
            "description": "Write <code>func countValue(nums []int, target int) int</code> that counts how many times target appears.",
            "functionSignature": "func countValue(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 2}, 2",
                "output": "3"
              },
              {
                "input": "[]int{5, 5, 5}, 5",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Start with count = 0. Each time you see the target, increment count."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through the slice. If element == target, do count++."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each element:\n   - element == target? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countValue(nums []int, target int) int {\n    count := 0\n    for _, n := range nums {\n        if n == target { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Track Seen Values",
            "description": "Write <code>func trackSeen(nums []int) map[int]bool</code> that returns a map marking which values were seen.",
            "functionSignature": "func trackSeen(nums []int) map[int]bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "map[1:true 2:true 3:true]"
              },
              {
                "input": "[]int{5, 5}",
                "output": "map[5:true]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Create a map, then mark each number as seen (true)."
              },
              {
                "title": "üí° Hint",
                "content": "For each number, set seen[num] = true. Maps automatically handle duplicates."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create map[int]bool\n2. For each num:\n   - seen[num] = true\n3. Return map</pre>"
              }
            ],
            "solution": "func trackSeen(nums []int) map[int]bool {\n    seen := make(map[int]bool)\n    for _, n := range nums { seen[n] = true }\n    return seen\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Count True Values",
            "description": "Write <code>func countTrue(flags []bool) int</code> that counts how many true values are in the slice.",
            "functionSignature": "func countTrue(flags []bool) int",
            "testCases": [
              {
                "input": "[]bool{true, false, true, true}",
                "output": "3"
              },
              {
                "input": "[]bool{false, false}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Same as counting any specific value - count when you see true."
              },
              {
                "title": "üí° Hint",
                "content": "if flag { count++ }"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each flag:\n   - flag == true? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countTrue(flags []bool) int {\n    count := 0\n    for _, f := range flags {\n        if f { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Tally by Type",
            "description": "Write <code>func tallyTypes(words []string) map[string]int</code> that counts how many of each word type. Simple tallying intro!",
            "functionSignature": "func tallyTypes(words []string) map[string]int",
            "testCases": [
              {
                "input": "[]string{\"cat\", \"dog\", \"cat\", \"bird\"}",
                "output": "map[cat:2 dog:1 bird:1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For each word, increment its count in the map. Maps default to 0 when accessing non-existent keys."
              },
              {
                "title": "üí° Hint",
                "content": "counts[word]++ works even if word isn't in the map yet (starts at 0)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create map[string]int\n2. For each word:\n   - counts[word]++\n3. Return map</pre>"
              }
            ],
            "solution": "func tallyTypes(words []string) map[string]int {\n    counts := make(map[string]int)\n    for _, w := range words { counts[w]++ }\n    return counts\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Count Vowels and Consonants",
            "description": "Write <code>func countVowelsConsonants(s string) (int, int)</code> that returns vowel count and consonant count.",
            "functionSignature": "func countVowelsConsonants(s string) (int, int)",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "2, 3",
                "note": "e,o are vowels; h,l,l are consonants"
              },
              {
                "input": "\"aaa\"",
                "output": "3, 0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check if each character is a vowel (a,e,i,o,u). Count separately."
              },
              {
                "title": "üí° Hint",
                "content": "Create a helper check: isVowel := char == 'a' || char == 'e' || ..."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. vowels, consonants := 0, 0\n2. For each char:\n   - Is vowel? ‚Üí vowels++\n   - Else ‚Üí consonants++\n3. Return both</pre>"
              }
            ],
            "solution": "func countVowelsConsonants(s string) (int, int) {\n    vowels, consonants := 0, 0\n    for _, r := range s {\n        lower := strings.ToLower(string(r))\n        if lower == \"a\" || lower == \"e\" || lower == \"i\" || lower == \"o\" || lower == \"u\" {\n            vowels++\n        } else {\n            consonants++\n        }\n    }\n    return vowels, consonants\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Has Value",
            "description": "Write <code>func hasValue(nums []int, target int) bool</code> that returns true if target is in the slice.",
            "functionSignature": "func hasValue(nums []int, target int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, 2",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3}, 5",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "As soon as you find target, return true. If loop finishes, return false."
              },
              {
                "title": "üí° Hint",
                "content": "This is early return pattern - return as soon as found."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each num:\n   - num == target? ‚Üí return true\n2. Return false (not found)</pre>"
              }
            ],
            "solution": "func hasValue(nums []int, target int) bool {\n    for _, n := range nums {\n        if n == target { return true }\n    }\n    return false\n}",
            "difficulty": 1
          },
          {
            "id": "v7",
            "title": "Count Even Numbers",
            "description": "Write <code>func countEvens(nums []int) int</code> that counts how many even numbers are in the slice.",
            "functionSignature": "func countEvens(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4, 5, 6}",
                "output": "3"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "A number is even if num % 2 == 0. Count how many satisfy this condition."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through, increment counter when num % 2 == 0."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each num:\n   - num % 2 == 0? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func countEvens(nums []int) int {\n    count := 0\n    for _, n := range nums {\n        if n % 2 == 0 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Passing Grades",
            "description": "Write <code>func passingGrades(grades []int) int</code> that counts how many grades are 60 or above.",
            "functionSignature": "func passingGrades(grades []int) int",
            "testCases": [
              {
                "input": "[]int{85, 55, 90, 45, 70}",
                "output": "3"
              },
              {
                "input": "[]int{30, 40, 50}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Count grades that are >= 60."
              },
              {
                "title": "üí° Hint",
                "content": "Simple counter: if grade >= 60, increment count."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For each grade:\n   - grade >= 60? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func passingGrades(grades []int) int {\n    count := 0\n    for _, g := range grades {\n        if g >= 60 { count++ }\n    }\n    return count\n}",
            "difficulty": 1
          },
          {
            "id": "v9",
            "title": "Inventory Below Threshold",
            "description": "Write <code>func lowStock(inventory map[string]int, threshold int) []string</code> that returns item names with stock below threshold.",
            "functionSignature": "func lowStock(inventory map[string]int, threshold int) []string",
            "testCases": [
              {
                "input": "map[string]int{\"apples\": 5, \"oranges\": 15, \"bananas\": 3}, 10",
                "output": "[\"apples\", \"bananas\"]"
              },
              {
                "input": "map[string]int{\"pens\": 100, \"paper\": 200}, 50",
                "output": "[]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through the map, collect items where count < threshold."
              },
              {
                "title": "üí° Hint",
                "content": "For each key-value pair, if value < threshold, append key to result slice."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []string{}\n2. For item, count in inventory:\n   - count < threshold?\n     ‚Üí append item to result\n3. Return result</pre>"
              }
            ],
            "solution": "func lowStock(inventory map[string]int, threshold int) []string {\n    result := []string{}\n    for item, count := range inventory {\n        if count < threshold {\n            result = append(result, item)\n        }\n    }\n    return result\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Group By First Letter",
            "description": "Write <code>func groupByFirstLetter(words []string) map[rune][]string</code> that groups words by their first letter. Returns a map where keys are first letters and values are slices of all words starting with that letter.",
            "functionSignature": "func groupByFirstLetter(words []string) map[rune][]string",
            "testCases": [
              {
                "input": "[\"go\", \"rust\", \"ruby\", \"python\", \"perl\"]",
                "output": "map['g':[\"go\"] 'r':[\"rust\", \"ruby\"] 'p':[\"python\", \"perl\"]]"
              },
              {
                "input": "[\"apple\", \"ant\", \"bat\", \"bear\"]",
                "output": "map['a':[\"apple\", \"ant\"] 'b':[\"bat\", \"bear\"]]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "You need to build a map where each key points to a slice. For each word, get its first letter and append the word to that letter's slice."
              },
              {
                "title": "üí° Hint",
                "content": "Create map[rune][]string. For each word, get first letter with rune(word[0]). Append word to groups[firstLetter]. If the slice doesn't exist yet, append creates it."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create map[rune][]string\n2. For each word:\n   - Get first letter: rune(word[0])\n   - Append word to map[firstLetter]\n3. Return map</pre>"
              }
            ],
            "solution": "func groupByFirstLetter(words []string) map[rune][]string {\n    groups := make(map[rune][]string)\n    for _, word := range words {\n        if len(word) > 0 {\n            firstLetter := rune(word[0])\n            groups[firstLetter] = append(groups[firstLetter], word)\n        }\n    }\n    return groups\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Frequency Sorted Keys",
            "description": "Write <code>func frequencySortedKeys(items []string) []string</code> that returns unique items sorted by frequency (most common first). If frequencies are tied, maintain the order items were first seen.",
            "functionSignature": "func frequencySortedKeys(items []string) []string",
            "testCases": [
              {
                "input": "[\"cat\", \"dog\", \"cat\", \"bird\", \"cat\", \"dog\"]",
                "output": "[\"cat\", \"dog\", \"bird\"]",
                "note": "cat appears 3x, dog 2x, bird 1x"
              },
              {
                "input": "[\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"]",
                "output": "[\"a\", \"b\", \"c\"]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "First build a frequency map to count occurrences. Then you need to create a result by iterating through unique items and sorting by their frequency. Track the order items first appeared."
              },
              {
                "title": "üí° Hint",
                "content": "Build two things: a frequency map and a list of unique items in order seen. Then sort the unique list by looking up frequencies. Use a simple comparison to sort."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Build frequency map\n2. Track unique items in order\n3. Sort unique items by frequency\n   (most frequent first)\n4. Return sorted list</pre>"
              }
            ],
            "solution": "func frequencySortedKeys(items []string) []string {\n    freq := make(map[string]int)\n    var order []string\n    seen := make(map[string]bool)\n    \n    for _, item := range items {\n        freq[item]++\n        if !seen[item] {\n            order = append(order, item)\n            seen[item] = true\n        }\n    }\n    \n    // Simple bubble sort by frequency\n    for i := 0; i < len(order); i++ {\n        for j := i + 1; j < len(order); j++ {\n            if freq[order[j]] > freq[order[i]] {\n                order[i], order[j] = order[j], order[i]\n            }\n        }\n    }\n    \n    return order\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Multi-Condition",
            "description": "Write <code>func countMultiCondition(nums []int, min, max, divisor int) map[string]int</code> that categorizes numbers into four groups: \"in_range\" (min <= n <= max), \"divisible\" (n % divisor == 0), \"both\" (satisfies both conditions), and \"neither\".",
            "functionSignature": "func countMultiCondition(nums []int, min, max, divisor int) map[string]int",
            "testCases": [
              {
                "input": "[]int{5, 10, 15, 20}, 10, 20, 5",
                "output": "map[\"in_range\":3 \"divisible\":4 \"both\":3 \"neither\":0]",
                "note": "10,15,20 in range; all divisible by 5; 10,15,20 satisfy both; 5 satisfies neither"
              },
              {
                "input": "[]int{1, 2, 3}, 5, 10, 2",
                "output": "map[\"in_range\":0 \"divisible\":1 \"both\":0 \"neither\":2]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For each number, check both conditions independently. Count how many satisfy: just range, just divisible, both, or neither. All four counts are independent."
              },
              {
                "title": "üí° Hint",
                "content": "Create a map with 4 keys initialized to 0. For each number, check inRange := (n >= min && n <= max) and isDivisible := (n % divisor == 0). Then increment the appropriate counters."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create map with 4 categories = 0\n2. For each num:\n   - Check if in range\n   - Check if divisible\n   - Increment all matching categories\n3. Return map</pre>"
              }
            ],
            "solution": "func countMultiCondition(nums []int, min, max, divisor int) map[string]int {\n    counts := map[string]int{\"in_range\": 0, \"divisible\": 0, \"both\": 0, \"neither\": 0}\n    \n    for _, n := range nums {\n        inRange := n >= min && n <= max\n        isDivisible := n % divisor == 0\n        \n        if inRange {\n            counts[\"in_range\"]++\n        }\n        if isDivisible {\n            counts[\"divisible\"]++\n        }\n        if inRange && isDivisible {\n            counts[\"both\"]++\n        }\n        if !inRange && !isDivisible {\n            counts[\"neither\"]++\n        }\n    }\n    \n    return counts\n}",
            "difficulty": 3
          },
          {
            "id": "v13",
            "title": "Tally By Category",
            "description": "Write <code>func tallyByCategory(items []string, categories map[string]string) map[string]int</code> that counts items per category. Given items and a map of item‚Üícategory, return count of items per category.",
            "functionSignature": "func tallyByCategory(items []string, categories map[string]string) map[string]int",
            "testCases": [
              {
                "input": "[\"apple\", \"banana\", \"carrot\", \"broccoli\"], map[\"apple\":\"fruit\", \"banana\":\"fruit\", \"carrot\":\"veggie\", \"broccoli\":\"veggie\"]",
                "output": "map[\"fruit\":2 \"veggie\":2]"
              },
              {
                "input": "[\"a\", \"b\", \"c\"], map[\"a\":\"x\", \"b\":\"x\", \"c\":\"y\"]",
                "output": "map[\"x\":2 \"y\":1]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For each item, look up its category in the categories map, then increment that category's count in your result map."
              },
              {
                "title": "üí° Hint",
                "content": "Create a result map for counting. For each item, get category := categories[item], then do counts[category]++. The map lookup gives you the indirect key to increment."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create counts map[string]int\n2. For each item:\n   - Look up category from categories map\n   - Increment counts[category]\n3. Return counts</pre>"
              }
            ],
            "solution": "func tallyByCategory(items []string, categories map[string]string) map[string]int {\n    counts := make(map[string]int)\n    for _, item := range items {\n        category := categories[item]\n        counts[category]++\n    }\n    return counts\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_13",
        "block": 1,
        "difficulty": 1,
        "concept": "Basic Swap Operations",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Assignments",
            "title": "Go Spec: Assignments",
            "note": "simultaneous assignment"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Use a temp variable: temp = a, a = b, b = temp (works but verbose).",
          "bestApproach": "Go's simultaneous assignment: a, b = b, a (cleaner, evaluates right side first).",
          "typical": "Typically O(1) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Swap Two Variables",
            "description": "Write <code>func swapVars(a, b int) (int, int)</code> that returns the values swapped.",
            "functionSignature": "func swapVars(a, b int) (int, int)",
            "testCases": [
              {
                "input": "3, 7",
                "output": "7, 3"
              },
              {
                "input": "10, 20",
                "output": "20, 10"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Go's simultaneous assignment makes this trivial."
              },
              {
                "title": "üí° Hint",
                "content": "return b, a - just return them in opposite order!"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>return b, a</pre>"
              }
            ],
            "solution": "func swapVars(a, b int) (int, int) {\n    return b, a\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Swap First Two Elements",
            "description": "Write <code>func swapFirstTwo(nums []int)</code> that swaps the first two elements in place. Assume at least 2 elements.",
            "functionSignature": "func swapFirstTwo(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}",
                "output": "[2, 1, 3]"
              },
              {
                "input": "[]int{5, 10}",
                "output": "[10, 5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Use simultaneous assignment on slice indices."
              },
              {
                "title": "üí° Hint",
                "content": "nums[0], nums[1] = nums[1], nums[0]"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[0], nums[1] = nums[1], nums[0]</pre>"
              }
            ],
            "solution": "func swapFirstTwo(nums []int) {\n    nums[0], nums[1] = nums[1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v3",
            "title": "Swap Ends",
            "description": "Write <code>func swapEnds(nums []int)</code> that swaps first and last elements.",
            "functionSignature": "func swapEnds(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[4, 2, 3, 1]"
              },
              {
                "input": "[]int{5, 10}",
                "output": "[10, 5]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Last element is at index len(nums)-1."
              },
              {
                "title": "üí° Hint",
                "content": "Swap nums[0] with nums[len(nums)-1]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>"
              }
            ],
            "solution": "func swapEnds(nums []int) {\n    nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]\n}",
            "difficulty": 1
          },
          {
            "id": "v4",
            "title": "Swap at Indices",
            "description": "Write <code>func swapAt(nums []int, i, j int)</code> that swaps elements at positions i and j.",
            "functionSignature": "func swapAt(nums []int, i, j int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}, 0, 2",
                "output": "[3, 2, 1, 4]"
              },
              {
                "input": "[]int{5, 10, 15}, 1, 2",
                "output": "[5, 15, 10]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Just swap the elements at the given indices."
              },
              {
                "title": "üí° Hint",
                "content": "nums[i], nums[j] = nums[j], nums[i]"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>nums[i], nums[j] = nums[j], nums[i]</pre>"
              }
            ],
            "solution": "func swapAt(nums []int, i, j int) {\n    nums[i], nums[j] = nums[j], nums[i]\n}",
            "difficulty": 1
          },
          {
            "id": "v5",
            "title": "Swap String Parts",
            "description": "Write <code>func swapStrings(a, b string) (string, string)</code> that swaps two strings.",
            "functionSignature": "func swapStrings(a, b string) (string, string)",
            "testCases": [
              {
                "input": "\"hello\", \"world\"",
                "output": "\"world\", \"hello\""
              },
              {
                "input": "\"go\", \"rust\"",
                "output": "\"rust\", \"go\""
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Same as swapping ints - just return in opposite order."
              },
              {
                "title": "üí° Hint",
                "content": "return b, a"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>return b, a</pre>"
              }
            ],
            "solution": "func swapStrings(a, b string) (string, string) {\n    return b, a\n}",
            "difficulty": 2
          },
          {
            "id": "v6",
            "title": "Conditional Swap",
            "description": "Write <code>func swapIfGreater(a, b int) (int, int)</code> that swaps only if a > b, ensuring smaller comes first.",
            "functionSignature": "func swapIfGreater(a, b int) (int, int)",
            "testCases": [
              {
                "input": "5, 2",
                "output": "2, 5",
                "note": "5 > 2, so swap"
              },
              {
                "input": "3, 7",
                "output": "3, 7",
                "note": "3 < 7, no swap"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check if a > b. If so, swap. Else, leave as-is."
              },
              {
                "title": "üí° Hint",
                "content": "if a > b { return b, a } else { return a, b }"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>if a > b {\n    return b, a\n}\nreturn a, b</pre>"
              }
            ],
            "solution": "func swapIfGreater(a, b int) (int, int) {\n    if a > b {\n        return b, a\n    }\n    return a, b\n}",
            "difficulty": 2
          },
          {
            "id": "v7",
            "title": "Swap Pairs",
            "description": "Write <code>func swapPairs(nums []int)</code> that swaps adjacent pairs (0√¢¬Ü¬î1, 2√¢¬Ü¬î3, etc). Assume even length.",
            "functionSignature": "func swapPairs(nums []int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[2, 1, 4, 3]"
              },
              {
                "input": "[]int{5, 10, 15, 20}",
                "output": "[10, 5, 20, 15]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop with step size 2, swapping nums[i] with nums[i+1]."
              },
              {
                "title": "üí° Hint",
                "content": "for i := 0; i < len(nums); i += 2 { swap nums[i] and nums[i+1] }"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i = 0, 2, 4, ... (step 2):\n   - Swap nums[i] √¢¬Ü¬î nums[i+1]\n2. Done</pre>"
              }
            ],
            "solution": "func swapPairs(nums []int) {\n    for i := 0; i < len(nums); i += 2 {\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    }\n}",
            "difficulty": 2
          },
          {
            "id": "v8",
            "title": "Rotate Three",
            "description": "Write <code>func rotateThree(a, b, c int) (int, int, int)</code> that rotates values: a‚Üíb, b‚Üíc, c‚Üía.",
            "functionSignature": "func rotateThree(a, b, c int) (int, int, int)",
            "testCases": [
              {
                "input": "1, 2, 3",
                "output": "3, 1, 2"
              },
              {
                "input": "10, 20, 30",
                "output": "30, 10, 20"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "This is a circular rotation. Use simultaneous assignment."
              },
              {
                "title": "üí° Hint",
                "content": "The pattern is: return c, a, b"
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>return c, a, b</pre>"
              }
            ],
            "solution": "func rotateThree(a, b, c int) (int, int, int) {\n    return c, a, b\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Swap Min and Max",
            "description": "Write <code>func swapMinMax(nums []int)</code> that swaps the positions of minimum and maximum values.",
            "functionSignature": "func swapMinMax(nums []int)",
            "testCases": [
              {
                "input": "[]int{3, 1, 4, 9, 2}",
                "output": "[3, 9, 4, 1, 2]",
                "note": "min=1 at idx 1, max=9 at idx 3"
              },
              {
                "input": "[]int{5, 2, 8, 2}",
                "output": "[5, 8, 2, 2]",
                "note": "first occurrence of min"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "First find indices of min and max values, then swap elements at those indices."
              },
              {
                "title": "üí° Hint",
                "content": "Loop twice: once to find minIdx and maxIdx, then swap nums[minIdx] with nums[maxIdx]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Find minIdx and maxIdx\n2. Swap nums[minIdx] √¢¬Ü¬î nums[maxIdx]\n3. Done</pre>"
              }
            ],
            "solution": "func swapMinMax(nums []int) {\n    minIdx, maxIdx := 0, 0\n    for i := range nums {\n        if nums[i] < nums[minIdx] { minIdx = i }\n        if nums[i] > nums[maxIdx] { maxIdx = i }\n    }\n    nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]\n}",
            "difficulty": 3
          },
          {
            "id": "v10",
            "title": "Rotate Slice Left",
            "description": "Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k positions. For example, [1,2,3,4,5] rotated left by 2 becomes [3,4,5,1,2].",
            "functionSignature": "func rotateLeft(nums []int, k int) []int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30, 40}, 1",
                "output": "[20, 30, 40, 10]"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}, 2",
                "output": "[3, 4, 5, 1, 2]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Rotating left by k means taking the first k elements and moving them to the end. You can use slice operations to split and recombine."
              },
              {
                "title": "üí° Hint",
                "content": "Split the slice at position k: first part is nums[:k], second part is nums[k:]. Concatenate them in reverse order: append(nums[k:], nums[:k]...)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Split at k: left = nums[:k], right = nums[k:]\n2. Concatenate: result = append(right, left...)\n3. Return result</pre>"
              }
            ],
            "solution": "func rotateLeft(nums []int, k int) []int {\n    k = k % len(nums)\n    return append(nums[k:], nums[:k]...)\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Swap All Pairs",
            "description": "Write <code>func swapAllPairs(nums []int) []int</code> that swaps every pair of adjacent elements. If the slice has odd length, the last element stays in place. For example, [1,2,3,4,5] becomes [2,1,4,3,5].",
            "functionSignature": "func swapAllPairs(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{10, 20, 30, 40}",
                "output": "[20, 10, 40, 30]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[2, 1, 3]",
                "note": "last element stays"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through pairs (i=0, 2, 4...) and swap each pair. Make sure to stop before going out of bounds on odd-length slices."
              },
              {
                "title": "üí° Hint",
                "content": "Create a copy of nums. Loop with i += 2, and swap result[i] with result[i+1] if i+1 < len(result)."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create copy of nums\n2. For i = 0, 2, 4, ... (step by 2):\n   - If i+1 exists:\n     ‚Üí swap result[i] with result[i+1]\n3. Return result</pre>"
              }
            ],
            "solution": "func swapAllPairs(nums []int) []int {\n    result := make([]int, len(nums))\n    copy(result, nums)\n    \n    for i := 0; i < len(result)-1; i += 2 {\n        result[i], result[i+1] = result[i+1], result[i]\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Bubble Sort One Pass",
            "description": "Write <code>func bubbleSortOnePass(nums []int) []int</code> that performs one pass of bubble sort. Compare each pair of adjacent elements and swap if they're in wrong order. This makes the largest element \"bubble\" to the end.",
            "functionSignature": "func bubbleSortOnePass(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{3, 1, 4, 2}",
                "output": "[1, 3, 2, 4]",
                "note": "after one pass, 4 bubbles to end"
              },
              {
                "input": "[]int{5, 3, 8, 1}",
                "output": "[3, 5, 1, 8]"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare each adjacent pair. If left > right, swap them. After one full pass, the largest element will be at the end."
              },
              {
                "title": "üí° Hint",
                "content": "Create a copy. Loop through i from 0 to len-2. For each i, if result[i] > result[i+1], swap them."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Create copy of nums\n2. For i from 0 to len-2:\n   - result[i] > result[i+1]?\n     ‚Üí swap them\n3. Return result</pre>"
              }
            ],
            "solution": "func bubbleSortOnePass(nums []int) []int {\n    result := make([]int, len(nums))\n    copy(result, nums)\n    \n    for i := 0; i < len(result)-1; i++ {\n        if result[i] > result[i+1] {\n            result[i], result[i+1] = result[i+1], result[i]\n        }\n    }\n    \n    return result\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_14",
        "block": 2,
        "difficulty": 2,
        "concept": "Element Comparison",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "iteration patterns"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Compare adjacent elements or compare all to first element; early return on mismatch.",
          "bestApproach": "Same approach - single pass with comparisons is already optimal.",
          "typical": "Typically O(n) time, O(1) extra space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Are Equal",
            "description": "Write <code>func areEqual(nums []int) bool</code> that returns true if all elements are the same.",
            "functionSignature": "func areEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{5, 5, 5}",
                "output": "true"
              },
              {
                "input": "[]int{5, 5, 6}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "If all are equal, they all equal the first element."
              },
              {
                "title": "üí° Hint",
                "content": "Compare each element to nums[0]. If any differs, return false."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each num:\n   - num != nums[0]? ‚Üí return false\n2. Return true (all equal)</pre>"
              }
            ],
            "solution": "func areEqual(nums []int) bool {\n    for _, n := range nums {\n        if n != nums[0] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v2",
            "title": "Has Adjacent Equal",
            "description": "Write <code>func hasAdjacentEqual(nums []int) bool</code> - true if any two adjacent elements are equal.",
            "functionSignature": "func hasAdjacentEqual(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through, comparing each element to the next one."
              },
              {
                "title": "üí° Hint",
                "content": "for i := 0; i < len(nums)-1; i++ - compare nums[i] to nums[i+1]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - nums[i] == nums[i+1]? ‚Üí return true\n2. Return false</pre>"
              }
            ],
            "solution": "func hasAdjacentEqual(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i] == nums[i+1] { return true }\n    }\n    return false\n}",
            "difficulty": 2
          },
          {
            "id": "v3",
            "title": "Is Increasing",
            "description": "Write <code>func isIncreasing(nums []int) bool</code> - true if each element is greater than the previous.",
            "functionSignature": "func isIncreasing(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "true"
              },
              {
                "input": "[]int{1, 3, 2, 4}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare adjacent elements - each should be > previous."
              },
              {
                "title": "üí° Hint",
                "content": "If nums[i+1] <= nums[i], it's not strictly increasing."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i from 0 to len-2:\n   - nums[i+1] <= nums[i]? ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func isIncreasing(nums []int) bool {\n    for i := 0; i < len(nums)-1; i++ {\n        if nums[i+1] <= nums[i] { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v4",
            "title": "First Greater Index",
            "description": "Write <code>func firstGreater(nums []int, threshold int) int</code> - index of first element > threshold, or -1.",
            "functionSignature": "func firstGreater(nums []int, threshold int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 5, 7}, 4",
                "output": "2",
                "note": "5 is first > 4"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "-1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Loop through with index, return index when you find one > threshold."
              },
              {
                "title": "üí° Hint",
                "content": "for i, n := range nums - if n > threshold return i."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i, num:\n   - num > threshold? ‚Üí return i\n2. Return -1</pre>"
              }
            ],
            "solution": "func firstGreater(nums []int, threshold int) int {\n    for i, n := range nums {\n        if n > threshold { return i }\n    }\n    return -1\n}",
            "difficulty": 2
          },
          {
            "id": "v5",
            "title": "Starts With Same",
            "description": "Write <code>func startsWithSame(nums []int, k int) bool</code> - true if first k elements are all equal.",
            "functionSignature": "func startsWithSame(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{5, 5, 5, 7}, 3",
                "output": "true"
              },
              {
                "input": "[]int{5, 5, 6, 7}, 3",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check if first k elements all equal nums[0]."
              },
              {
                "title": "üí° Hint",
                "content": "Loop i from 0 to k-1, compare nums[i] to nums[0]."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i from 0 to k-1:\n   - nums[i] != nums[0]? ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func startsWithSame(nums []int, k int) bool {\n    for i := 0; i < k; i++ {\n        if nums[i] != nums[0] { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v6",
            "title": "Longest Streak of Value",
            "description": "Write <code>func longestStreak(nums []int, target int) int</code> - length of longest consecutive run of target.",
            "functionSignature": "func longestStreak(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 2, 1, 2, 2}, 2",
                "output": "3",
                "note": "three 2's in a row"
              },
              {
                "input": "[]int{1, 1, 3, 1}, 1",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track current streak and max streak. When you see target, increment current. When you don't, reset current."
              },
              {
                "title": "üí° Hint",
                "content": "Keep current and max variables. Update max whenever current > max."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. current, max := 0, 0\n2. For each num:\n   - num == target? ‚Üí current++, update max\n   - else ‚Üí current = 0\n3. Return max</pre>"
              }
            ],
            "solution": "func longestStreak(nums []int, target int) int {\n    current, max := 0, 0\n    for _, n := range nums {\n        if n == target {\n            current++\n            if current > max { max = current }\n        } else {\n            current = 0\n        }\n    }\n    return max\n}",
            "difficulty": 3
          },
          {
            "id": "v7",
            "title": "All Positive",
            "description": "Write <code>func allPositive(nums []int) bool</code> that returns true if all numbers are greater than 0.",
            "functionSignature": "func allPositive(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 5, 10, 3}",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 5}",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Check each number. If any is <= 0, return false immediately."
              },
              {
                "title": "üí° Hint",
                "content": "Early return pattern: as soon as you find non-positive, return false."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For each num:\n   - num <= 0? ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func allPositive(nums []int) bool {\n    for _, n := range nums {\n        if n <= 0 { return false }\n    }\n    return true\n}",
            "difficulty": 1
          },
          {
            "id": "v8",
            "title": "Price Drop Count",
            "description": "Write <code>func priceDrops(prices []float64) int</code> that counts how many times price decreased from one day to next.",
            "functionSignature": "func priceDrops(prices []float64) int",
            "testCases": [
              {
                "input": "[]float64{100.0, 95.0, 97.0, 90.0}",
                "output": "2",
                "note": "100‚Üí95 and 97‚Üí90"
              },
              {
                "input": "[]float64{50.0, 55.0, 60.0}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Compare adjacent prices. Count when prices[i+1] < prices[i]."
              },
              {
                "title": "üí° Hint",
                "content": "Loop through indices, increment counter when next price is lower than current."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. count := 0\n2. For i from 0 to len-2:\n   - prices[i+1] < prices[i]? ‚Üí count++\n3. Return count</pre>"
              }
            ],
            "solution": "func priceDrops(prices []float64) int {\n    count := 0\n    for i := 0; i < len(prices)-1; i++ {\n        if prices[i+1] < prices[i] { count++ }\n    }\n    return count\n}",
            "difficulty": 2
          },
          {
            "id": "v9",
            "title": "Length Matches Position",
            "description": "Write <code>func lengthMatchesPos(words []string) bool</code> - true if each word's length equals its position+1.",
            "functionSignature": "func lengthMatchesPos(words []string) bool",
            "testCases": [
              {
                "input": "[]string{\"a\", \"hi\", \"cat\", \"dogs\"}",
                "output": "true",
                "note": "lengths: 1,2,3,4"
              },
              {
                "input": "[]string{\"a\", \"ab\", \"abc\"}",
                "output": "false",
                "note": "position 1: \"ab\" has length 2, needs 2 ‚úì; position 2: \"abc\" has length 3, needs 3 ‚úì... wait this should be true!"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "For each word at index i, check if len(word) == i+1."
              },
              {
                "title": "üí° Hint",
                "content": "Loop with index: if len(words[i]) != i+1, return false."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. For i, word:\n   - len(word) != i+1? ‚Üí return false\n2. Return true</pre>"
              }
            ],
            "solution": "func lengthMatchesPos(words []string) bool {\n    for i, word := range words {\n        if len(word) != i+1 { return false }\n    }\n    return true\n}",
            "difficulty": 2
          },
          {
            "id": "v10",
            "title": "Find All Peaks",
            "description": "Write <code>func findAllPeaks(nums []int) []int</code> that returns the indices where an element is greater than both its neighbors. First and last elements cannot be peaks.",
            "functionSignature": "func findAllPeaks(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 4, 1}",
                "output": "[1, 3]",
                "note": "nums[1]=3 > neighbors (1,2); nums[3]=4 > neighbors (2,1)"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "[]",
                "note": "monotonic increasing, no peaks"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "A peak is at index i where nums[i] > nums[i-1] AND nums[i] > nums[i+1]. Loop from index 1 to len-2 (excluding first and last)."
              },
              {
                "title": "üí° Hint",
                "content": "Create empty result slice. Loop i from 1 to len(nums)-2. If nums[i] > nums[i-1] && nums[i] > nums[i+1], append i to result."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. result := []int{}\n2. For i from 1 to len-2:\n   - nums[i] > both neighbors?\n     ‚Üí append i to result\n3. Return result</pre>"
              }
            ],
            "solution": "func findAllPeaks(nums []int) []int {\n    result := []int{}\n    \n    for i := 1; i < len(nums)-1; i++ {\n        if nums[i] > nums[i-1] && nums[i] > nums[i+1] {\n            result = append(result, i)\n        }\n    }\n    \n    return result\n}",
            "difficulty": 3
          },
          {
            "id": "v11",
            "title": "Longest Increasing Sequence",
            "description": "Write <code>func longestIncreasingLength(nums []int) int</code> that finds the length of the longest consecutive increasing subsequence.",
            "functionSignature": "func longestIncreasingLength(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1, 2, 3, 4, 5}",
                "output": "5",
                "note": "sequence 1,2,3,4,5 at end"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "1",
                "note": "all decreasing, max streak is 1"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track the current streak length and the maximum streak seen so far. When nums[i] > nums[i-1], increment streak. Otherwise, reset streak to 1."
              },
              {
                "title": "üí° Hint",
                "content": "currentStreak := 1, maxStreak := 1. For each i from 1 to end: if nums[i] > nums[i-1], currentStreak++, else currentStreak = 1. Update maxStreak if currentStreak is larger."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. currentStreak = 1, maxStreak = 1\n2. For i from 1 to len:\n   - Increasing? ‚Üí currentStreak++\n   - Not? ‚Üí currentStreak = 1\n   - Update maxStreak\n3. Return maxStreak</pre>"
              }
            ],
            "solution": "func longestIncreasingLength(nums []int) int {\n    if len(nums) == 0 { return 0 }\n    \n    currentStreak := 1\n    maxStreak := 1\n    \n    for i := 1; i < len(nums); i++ {\n        if nums[i] > nums[i-1] {\n            currentStreak++\n            if currentStreak > maxStreak {\n                maxStreak = currentStreak\n            }\n        } else {\n            currentStreak = 1\n        }\n    }\n    \n    return maxStreak\n}",
            "difficulty": 3
          },
          {
            "id": "v12",
            "title": "Count Direction Changes",
            "description": "Write <code>func countDirectionChanges(nums []int) int</code> that counts how many times the sequence changes from increasing to decreasing or vice versa.",
            "functionSignature": "func countDirectionChanges(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 4, 3}",
                "output": "3",
                "note": "up(1‚Üí3), down(3‚Üí2), up(2‚Üí4), down(4‚Üí3) = 3 changes"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "monotonic increasing, no direction changes"
              }
            ],
            "hints": [
              {
                "title": "ü§î Think about it",
                "content": "Track whether you're currently going up or down. When the direction switches, increment the change counter."
              },
              {
                "title": "üí° Hint",
                "content": "Start with direction based on first two elements. For each next element, determine new direction. If it differs from previous direction, count a change."
              },
              {
                "title": "üîß Pattern",
                "content": "<pre>1. Determine initial direction\n2. changes := 0\n3. For each next pair:\n   - Determine new direction\n   - Different from previous? ‚Üí changes++\n   - Update previous direction\n4. Return changes</pre>"
              }
            ],
            "solution": "func countDirectionChanges(nums []int) int {\n    if len(nums) < 2 { return 0 }\n    \n    changes := 0\n    var prevDirection string\n    \n    for i := 1; i < len(nums); i++ {\n        var currentDirection string\n        if nums[i] > nums[i-1] {\n            currentDirection = \"up\"\n        } else if nums[i] < nums[i-1] {\n            currentDirection = \"down\"\n        } else {\n            continue\n        }\n        \n        if prevDirection != \"\" && currentDirection != prevDirection {\n            changes++\n        }\n        prevDirection = currentDirection\n    }\n    \n    return changes\n}",
            "difficulty": 3
          }
        ]
      },
      {
        "id": "challenge_15",
        "block": 2,
        "difficulty": 1,
        "concept": "Recursion",
        "sharedContentRef": "advanced_recursion",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Function_declarations",
            "title": "Go Spec: Function declarations",
            "note": "recursive functions"
          },
          {
            "url": "https://go.dev/ref/spec#If_statements",
            "title": "Go Spec: If statements",
            "note": "base case conditions"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Use loops to solve iteratively.",
          "bestApproach": "Identify the base case and recursive case. Each recursive call should reduce the problem size toward the base case.",
          "typical": "Time varies; space O(n) due to call stack"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Recursive Sum to N",
            "description": "Write <code>func sumToN(n int) int</code> that returns the sum 1+2+...+n using recursion. sumToN(0) should return 0.",
            "functionSignature": "func sumToN(n int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "5",
                "output": "15"
              },
              {
                "input": "0",
                "output": "0"
              },
              {
                "input": "1",
                "output": "1"
              },
              {
                "input": "10",
                "output": "55"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "What is the simplest case? When n is 0, the sum is 0. For any other n, the sum is n plus the sum of everything before it."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: if n <= 0, return 0. Recursive case: return n + sumToN(n-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>func sumToN(n int) int {\n    if n <= 0 { return 0 }  // base case\n    return n + sumToN(n-1)  // recursive case\n}</pre>"
              }
            ],
            "solution": "func sumToN(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    return n + sumToN(n-1)\n}"
          },
          {
            "id": "v2",
            "title": "Recursive Factorial",
            "description": "Write <code>func factorial(n int) int</code> that returns n! using recursion. 0! = 1.",
            "functionSignature": "func factorial(n int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "5",
                "output": "120"
              },
              {
                "input": "0",
                "output": "1"
              },
              {
                "input": "1",
                "output": "1"
              },
              {
                "input": "7",
                "output": "5040"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Factorial means n * (n-1) * (n-2) * ... * 1. What's the simplest factorial? 0! = 1."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: n <= 0 returns 1. Recursive case: n * factorial(n-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if n <= 0 { return 1 }\nreturn n * factorial(n-1)</pre>"
              }
            ],
            "solution": "func factorial(n int) int {\n    if n <= 0 {\n        return 1\n    }\n    return n * factorial(n-1)\n}"
          },
          {
            "id": "v3",
            "title": "Recursive Power",
            "description": "Write <code>func power(base, exp int) int</code> that returns base^exp using recursion. Assume exp >= 0.",
            "functionSignature": "func power(base, exp int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "2, 3",
                "output": "8"
              },
              {
                "input": "5, 0",
                "output": "1"
              },
              {
                "input": "3, 4",
                "output": "81"
              },
              {
                "input": "10, 2",
                "output": "100"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "base^0 = 1 for any base. base^exp = base * base^(exp-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: exp == 0 returns 1. Recursive case: base * power(base, exp-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if exp == 0 { return 1 }\nreturn base * power(base, exp-1)</pre>"
              }
            ],
            "solution": "func power(base, exp int) int {\n    if exp == 0 {\n        return 1\n    }\n    return base * power(base, exp-1)\n}"
          },
          {
            "id": "v4",
            "title": "Recursive Count Digits",
            "description": "Write <code>func countDigits(n int) int</code> that returns the number of digits in n using recursion. Treat negative numbers as positive. countDigits(0) = 1.",
            "functionSignature": "func countDigits(n int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "12345",
                "output": "5"
              },
              {
                "input": "0",
                "output": "1"
              },
              {
                "input": "9",
                "output": "1"
              },
              {
                "input": "-42",
                "output": "2"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "A single digit number (0-9) has 1 digit. For larger numbers, remove the last digit (n/10) and add 1."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Handle negatives first (make positive). Base case: n < 10 returns 1. Recursive: 1 + countDigits(n/10)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if n < 0 { n = -n }\nif n < 10 { return 1 }\nreturn 1 + countDigits(n/10)</pre>"
              }
            ],
            "solution": "func countDigits(n int) int {\n    if n < 0 {\n        n = -n\n    }\n    if n < 10 {\n        return 1\n    }\n    return 1 + countDigits(n/10)\n}"
          },
          {
            "id": "v5",
            "title": "Recursive Sum of Digits",
            "description": "Write <code>func digitSum(n int) int</code> that returns the sum of digits of n using recursion. Treat negative numbers as positive.",
            "functionSignature": "func digitSum(n int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "123",
                "output": "6"
              },
              {
                "input": "0",
                "output": "0"
              },
              {
                "input": "999",
                "output": "27"
              },
              {
                "input": "-45",
                "output": "9"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "The last digit is n%10. The remaining digits are n/10. Sum them up recursively."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: n == 0 returns 0. Recursive: (n%10) + digitSum(n/10). Handle negatives first."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if n < 0 { n = -n }\nif n == 0 { return 0 }\nreturn n%10 + digitSum(n/10)</pre>"
              }
            ],
            "solution": "func digitSum(n int) int {\n    if n < 0 {\n        n = -n\n    }\n    if n == 0 {\n        return 0\n    }\n    return n%10 + digitSum(n/10)\n}"
          },
          {
            "id": "v6",
            "title": "Recursive Fibonacci",
            "description": "Write <code>func fib(n int) int</code> that returns the nth Fibonacci number. fib(0)=0, fib(1)=1, fib(n)=fib(n-1)+fib(n-2).",
            "functionSignature": "func fib(n int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "0",
                "output": "0"
              },
              {
                "input": "1",
                "output": "1"
              },
              {
                "input": "6",
                "output": "8"
              },
              {
                "input": "10",
                "output": "55"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Fibonacci has TWO base cases: fib(0)=0 and fib(1)=1. Every other value needs two recursive calls."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base cases: n==0 returns 0, n==1 returns 1. Recursive: fib(n-1) + fib(n-2)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if n <= 0 { return 0 }\nif n == 1 { return 1 }\nreturn fib(n-1) + fib(n-2)</pre>"
              }
            ],
            "solution": "func fib(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fib(n-1) + fib(n-2)\n}"
          },
          {
            "id": "v7",
            "title": "Recursive String Length",
            "description": "Write <code>func strLen(s string) int</code> that returns the length of a string using recursion (no len() allowed in recursive logic).",
            "functionSignature": "func strLen(s string) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "5"
              },
              {
                "input": "\"\"",
                "output": "0"
              },
              {
                "input": "\"a\"",
                "output": "1"
              },
              {
                "input": "\"Go lang\"",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "An empty string has length 0. Otherwise, it's 1 + the length of the string without its first character."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: s == \"\" returns 0. Recursive: 1 + strLen(s[1:])."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if s == \"\" { return 0 }\nreturn 1 + strLen(s[1:])</pre>"
              }
            ],
            "solution": "func strLen(s string) int {\n    if s == \"\" {\n        return 0\n    }\n    return 1 + strLen(s[1:])\n}"
          },
          {
            "id": "v8",
            "title": "Recursive Reverse String",
            "description": "Write <code>func reverseStr(s string) string</code> that reverses a string using recursion.",
            "functionSignature": "func reverseStr(s string) string",
            "difficulty": 2,
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"\"",
                "output": "\"\""
              },
              {
                "input": "\"a\"",
                "output": "\"a\""
              },
              {
                "input": "\"abcd\"",
                "output": "\"dcba\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "To reverse \"hello\": reverse \"ello\" to get \"olle\", then add \"h\" at the end."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: len(s) <= 1 returns s. Recursive: reverseStr(s[1:]) + string(s[0])."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if len(s) <= 1 { return s }\nreturn reverseStr(s[1:]) + string(s[0])</pre>"
              }
            ],
            "solution": "func reverseStr(s string) string {\n    if len(s) <= 1 {\n        return s\n    }\n    return reverseStr(s[1:]) + string(s[0])\n}"
          },
          {
            "id": "v9",
            "title": "Recursive GCD",
            "description": "Write <code>func gcd(a, b int) int</code> that returns the greatest common divisor using Euclid's algorithm recursively. gcd(a, 0) = a.",
            "functionSignature": "func gcd(a, b int) int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "12, 8",
                "output": "4"
              },
              {
                "input": "7, 0",
                "output": "7"
              },
              {
                "input": "100, 75",
                "output": "25"
              },
              {
                "input": "17, 13",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Euclid's insight: gcd(a, b) = gcd(b, a%b). The base case is when b is 0."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: b == 0 returns a. Recursive: gcd(b, a%b)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if b == 0 { return a }\nreturn gcd(b, a%b)</pre>"
              }
            ],
            "solution": "func gcd(a, b int) int {\n    if b == 0 {\n        return a\n    }\n    return gcd(b, a%b)\n}"
          },
          {
            "id": "v10",
            "title": "Recursive Palindrome Check",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string is a palindrome using recursion.",
            "functionSignature": "func isPalindrome(s string) bool",
            "difficulty": 2,
            "testCases": [
              {
                "input": "\"racecar\"",
                "output": "true"
              },
              {
                "input": "\"hello\"",
                "output": "false"
              },
              {
                "input": "\"a\"",
                "output": "true"
              },
              {
                "input": "\"abba\"",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "A palindrome reads the same forwards and backwards. Check if the first and last characters match, then check the middle."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: len(s) <= 1 returns true. If first != last, return false. Otherwise recurse on s[1:len(s)-1]."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if len(s) <= 1 { return true }\nif s[0] != s[len(s)-1] { return false }\nreturn isPalindrome(s[1:len(s)-1])</pre>"
              }
            ],
            "solution": "func isPalindrome(s string) bool {\n    if len(s) <= 1 {\n        return true\n    }\n    if s[0] != s[len(s)-1] {\n        return false\n    }\n    return isPalindrome(s[1 : len(s)-1])\n}"
          },
          {
            "id": "v11",
            "title": "Recursive Flatten",
            "description": "Write <code>func flatten(nested [][]int) []int</code> that flattens a 2D slice into a 1D slice using recursion.",
            "functionSignature": "func flatten(nested [][]int) []int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[][]int{{1,2},{3,4},{5}}",
                "output": "[]int{1,2,3,4,5}"
              },
              {
                "input": "[][]int{}",
                "output": "[]int{}"
              },
              {
                "input": "[][]int{{1}}",
                "output": "[]int{1}"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Process the first sub-slice, then recursively flatten the rest and combine."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: empty outer slice returns empty. Recursive: append first sub-slice elements with flatten(nested[1:])..."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if len(nested) == 0 { return []int{} }\nreturn append(nested[0], flatten(nested[1:])...)</pre>"
              }
            ],
            "solution": "func flatten(nested [][]int) []int {\n    if len(nested) == 0 {\n        return []int{}\n    }\n    return append(nested[0], flatten(nested[1:])...)\n}"
          },
          {
            "id": "v12",
            "title": "Recursive Binary Representation",
            "description": "Write <code>func toBinary(n int) string</code> that returns the binary representation of a non-negative integer as a string using recursion. toBinary(0) = \"0\".",
            "functionSignature": "func toBinary(n int) string",
            "difficulty": 3,
            "testCases": [
              {
                "input": "0",
                "output": "\"0\""
              },
              {
                "input": "5",
                "output": "\"101\""
              },
              {
                "input": "10",
                "output": "\"1010\""
              },
              {
                "input": "1",
                "output": "\"1\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Binary works by repeatedly dividing by 2. The remainder gives you the last digit, and the quotient gives you the remaining digits."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: n <= 0 returns \"0\", n == 1 returns \"1\". Recursive: toBinary(n/2) + last digit (n%2 as string)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>import \"strconv\"\nif n <= 0 { return \"0\" }\nif n == 1 { return \"1\" }\nreturn toBinary(n/2) + strconv.Itoa(n%2)</pre>"
              }
            ],
            "solution": "func toBinary(n int) string {\n    if n <= 0 {\n        return \"0\"\n    }\n    if n == 1 {\n        return \"1\"\n    }\n    return toBinary(n/2) + strconv.Itoa(n%2)\n}"
          },
          {
            "id": "v13",
            "title": "Recursive Permutation Count",
            "description": "Write <code>func permutations(n, r int) int</code> that calculates P(n,r) = n!/(n-r)! using recursion. Use the identity P(n,r) = n * P(n-1, r-1) with base case P(n,0) = 1.",
            "functionSignature": "func permutations(n, r int) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "5, 2",
                "output": "20"
              },
              {
                "input": "4, 0",
                "output": "1"
              },
              {
                "input": "6, 3",
                "output": "120"
              },
              {
                "input": "3, 3",
                "output": "6"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "P(n,r) picks r items from n in order. P(n,0) = 1 (one way to pick nothing). Otherwise, pick one of n, then pick r-1 from remaining n-1."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base case: r == 0 returns 1. Recursive: n * permutations(n-1, r-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if r == 0 { return 1 }\nreturn n * permutations(n-1, r-1)</pre>"
              }
            ],
            "solution": "func permutations(n, r int) int {\n    if r == 0 {\n        return 1\n    }\n    return n * permutations(n-1, r-1)\n}"
          },
          {
            "id": "v14",
            "title": "Recursive Merge Sorted",
            "description": "Write <code>func mergeSorted(a, b []int) []int</code> that merges two sorted slices into one sorted slice using recursion.",
            "functionSignature": "func mergeSorted(a, b []int) []int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "[]int{1,3,5}, []int{2,4,6}",
                "output": "[]int{1,2,3,4,5,6}"
              },
              {
                "input": "[]int{}, []int{1,2}",
                "output": "[]int{1,2}"
              },
              {
                "input": "[]int{1}, []int{}",
                "output": "[]int{1}"
              },
              {
                "input": "[]int{1,1}, []int{1,1}",
                "output": "[]int{1,1,1,1}"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "If either slice is empty, return the other. Otherwise, compare the first elements: take the smaller one and recurse with the rest."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base cases: a empty returns b, b empty returns a. Compare a[0] vs b[0]: take smaller, prepend to recursive merge of the rest."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if len(a) == 0 { return b }\nif len(b) == 0 { return a }\nif a[0] <= b[0] {\n    return append([]int{a[0]}, mergeSorted(a[1:], b)...)\n}\nreturn append([]int{b[0]}, mergeSorted(a, b[1:])...)</pre>"
              }
            ],
            "solution": "func mergeSorted(a, b []int) []int {\n    if len(a) == 0 {\n        return b\n    }\n    if len(b) == 0 {\n        return a\n    }\n    if a[0] <= b[0] {\n        return append([]int{a[0]}, mergeSorted(a[1:], b)...)\n    }\n    return append([]int{b[0]}, mergeSorted(a, b[1:])...)\n}"
          },
          {
            "id": "v15",
            "title": "Recursive Subsets",
            "description": "Write <code>func countSubsets(n, k int) int</code> that returns the number of ways to choose k items from n (combinations C(n,k)) using recursion. C(n,0)=1, C(n,n)=1, C(n,k)=C(n-1,k-1)+C(n-1,k).",
            "functionSignature": "func countSubsets(n, k int) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "5, 2",
                "output": "10"
              },
              {
                "input": "4, 0",
                "output": "1"
              },
              {
                "input": "4, 4",
                "output": "1"
              },
              {
                "input": "6, 3",
                "output": "20"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Pascal's triangle! C(n,k) = C(n-1,k-1) + C(n-1,k). Base cases: choosing 0 items or all items gives 1 way."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Base cases: k==0 or k==n returns 1. Recursive: countSubsets(n-1, k-1) + countSubsets(n-1, k)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if k == 0 || k == n { return 1 }\nreturn countSubsets(n-1, k-1) + countSubsets(n-1, k)</pre>"
              }
            ],
            "solution": "func countSubsets(n, k int) int {\n    if k == 0 || k == n {\n        return 1\n    }\n    return countSubsets(n-1, k-1) + countSubsets(n-1, k)\n}"
          }
        ]
      },
      {
        "id": "challenge_16",
        "block": 3,
        "difficulty": 1,
        "concept": "Binary Search",
        "sharedContentRef": "advanced_binary_search",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#For_statements",
            "title": "Go Spec: For statements",
            "note": "while-style loops"
          },
          {
            "url": "https://pkg.go.dev/sort",
            "title": "Package sort",
            "note": "Go's sort utilities"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Linear scan through the entire array O(n).",
          "bestApproach": "Binary search halves the search space each step O(log n). Requires sorted input.",
          "typical": "O(log n) time, O(1) space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Basic Binary Search",
            "description": "Write <code>func binarySearch(nums []int, target int) int</code> that returns the index of target in a sorted slice, or -1 if not found.",
            "functionSignature": "func binarySearch(nums []int, target int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "[]int{1,3,5,7,9}, 5",
                "output": "2"
              },
              {
                "input": "[]int{1,3,5,7,9}, 4",
                "output": "-1"
              },
              {
                "input": "[]int{2,4,6,8}, 2",
                "output": "0"
              },
              {
                "input": "[]int{2,4,6,8}, 8",
                "output": "3"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "The array is sorted. If you check the middle element, you know which half the target must be in."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Set low=0, high=len-1. Loop while low <= high. Calculate mid=(low+high)/2. Compare nums[mid] to target and adjust low or high."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target { return mid }\n    else if nums[mid] < target { low = mid+1 }\n    else { high = mid-1 }\n}\nreturn -1</pre>"
              }
            ],
            "solution": "func binarySearch(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return -1\n}"
          },
          {
            "id": "v2",
            "title": "Search Insert Position",
            "description": "Write <code>func searchInsert(nums []int, target int) int</code> that returns the index where target is found, or where it would be inserted to keep the slice sorted.",
            "functionSignature": "func searchInsert(nums []int, target int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "[]int{1,3,5,6}, 5",
                "output": "2"
              },
              {
                "input": "[]int{1,3,5,6}, 2",
                "output": "1"
              },
              {
                "input": "[]int{1,3,5,6}, 7",
                "output": "4"
              },
              {
                "input": "[]int{1,3,5,6}, 0",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "This is like binary search, but instead of returning -1 when not found, return where it would go."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Standard binary search, but when the loop ends (low > high), the insertion point is low."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target { return mid }\n    else if nums[mid] < target { low = mid+1 }\n    else { high = mid-1 }\n}\nreturn low  // insertion point</pre>"
              }
            ],
            "solution": "func searchInsert(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return low\n}"
          },
          {
            "id": "v3",
            "title": "Binary Search Boolean",
            "description": "Write <code>func exists(nums []int, target int) bool</code> that returns true if target exists in the sorted slice.",
            "functionSignature": "func exists(nums []int, target int) bool",
            "difficulty": 1,
            "testCases": [
              {
                "input": "[]int{1,2,3,4,5}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1,2,3,4,5}, 6",
                "output": "false"
              },
              {
                "input": "[]int{10,20,30}, 10",
                "output": "true"
              },
              {
                "input": "[]int{}, 1",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Same as basic binary search but return bool instead of index."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Run binary search. If you find target, return true. If loop ends, return false."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target { return true }\n    ...\n}\nreturn false</pre>"
              }
            ],
            "solution": "func exists(nums []int, target int) bool {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return true\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return false\n}"
          },
          {
            "id": "v4",
            "title": "Count Target Occurrences",
            "description": "Write <code>func countTarget(nums []int, target int) int</code> that counts how many times target appears in a sorted slice. Use binary search to find it, then expand left and right.",
            "functionSignature": "func countTarget(nums []int, target int) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "[]int{1,2,2,2,3,4}, 2",
                "output": "3"
              },
              {
                "input": "[]int{1,1,1,1}, 1",
                "output": "4"
              },
              {
                "input": "[]int{1,2,3}, 5",
                "output": "0"
              },
              {
                "input": "[]int{}, 1",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Find any occurrence with binary search, then count outward in both directions since the array is sorted."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Binary search to find one occurrence. Then use two loops: expand left while equal, expand right while equal. Count total."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>1. Binary search to find target at index mid\n2. If not found, return 0\n3. count = 1, expand left (mid-1, mid-2...) while equal\n4. Expand right (mid+1, mid+2...) while equal\n5. Return count</pre>"
              }
            ],
            "solution": "func countTarget(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    idx := -1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            idx = mid\n            break\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    if idx == -1 {\n        return 0\n    }\n    count := 1\n    for i := idx - 1; i >= 0 && nums[i] == target; i-- {\n        count++\n    }\n    for i := idx + 1; i < len(nums) && nums[i] == target; i++ {\n        count++\n    }\n    return count\n}"
          },
          {
            "id": "v5",
            "title": "First Occurrence",
            "description": "Write <code>func firstOccurrence(nums []int, target int) int</code> that returns the index of the first occurrence of target in a sorted slice, or -1 if not found.",
            "functionSignature": "func firstOccurrence(nums []int, target int) int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]int{1,2,2,2,3}, 2",
                "output": "1"
              },
              {
                "input": "[]int{1,1,1}, 1",
                "output": "0"
              },
              {
                "input": "[]int{1,2,3}, 4",
                "output": "-1"
              },
              {
                "input": "[]int{5,5,5,5}, 5",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Standard binary search finds ANY occurrence. To find the FIRST, when you find target, don't stop - keep searching left."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "When nums[mid] == target, save result and set high = mid-1 to keep searching left for an earlier occurrence."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>result := -1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target {\n        result = mid\n        high = mid - 1  // keep looking left\n    } else if nums[mid] < target {\n        low = mid + 1\n    } else {\n        high = mid - 1\n    }\n}\nreturn result</pre>"
              }
            ],
            "solution": "func firstOccurrence(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    result := -1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            result = mid\n            high = mid - 1\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v6",
            "title": "Last Occurrence",
            "description": "Write <code>func lastOccurrence(nums []int, target int) int</code> that returns the index of the last occurrence of target in a sorted slice, or -1 if not found.",
            "functionSignature": "func lastOccurrence(nums []int, target int) int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]int{1,2,2,2,3}, 2",
                "output": "3"
              },
              {
                "input": "[]int{1,1,1}, 1",
                "output": "2"
              },
              {
                "input": "[]int{1,2,3}, 4",
                "output": "-1"
              },
              {
                "input": "[]int{5}, 5",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Mirror of first occurrence: when you find target, keep searching right instead of left."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "When nums[mid] == target, save result and set low = mid+1 to keep searching right."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>result := -1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target {\n        result = mid\n        low = mid + 1  // keep looking right\n    } ...\n}\nreturn result</pre>"
              }
            ],
            "solution": "func lastOccurrence(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    result := -1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            result = mid\n            low = mid + 1\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v7",
            "title": "Square Root (Integer)",
            "description": "Write <code>func intSqrt(n int) int</code> that returns the integer square root of n (largest integer whose square is <= n). Assume n >= 0.",
            "functionSignature": "func intSqrt(n int) int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "16",
                "output": "4"
              },
              {
                "input": "8",
                "output": "2"
              },
              {
                "input": "0",
                "output": "0"
              },
              {
                "input": "1",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Binary search isn't just for arrays! Search the range [0, n] for the largest value whose square <= n."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "low=0, high=n. If mid*mid <= n, save mid as answer and search right (low=mid+1). If mid*mid > n, search left (high=mid-1)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high, result := 0, n, 0\nfor low <= high {\n    mid := (low+high)/2\n    if mid*mid <= n {\n        result = mid\n        low = mid + 1\n    } else {\n        high = mid - 1\n    }\n}\nreturn result</pre>"
              }
            ],
            "solution": "func intSqrt(n int) int {\n    low, high, result := 0, n, 0\n    for low <= high {\n        mid := (low + high) / 2\n        if mid*mid <= n {\n            result = mid\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v8",
            "title": "Find Peak Element",
            "description": "Write <code>func findPeak(nums []int) int</code> that returns the index of any peak element (an element greater than its neighbors). Assume nums has at least one element and nums[-1] = nums[n] = negative infinity.",
            "functionSignature": "func findPeak(nums []int) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "[]int{1,3,2}",
                "output": "1"
              },
              {
                "input": "[]int{1,2,3,1}",
                "output": "2"
              },
              {
                "input": "[]int{5,4,3,2,1}",
                "output": "0"
              },
              {
                "input": "[]int{1}",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "If the middle element is less than its right neighbor, a peak must exist on the right side. Why? Because values go up, and they must come down eventually (boundary is -infinity)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Binary search: if nums[mid] < nums[mid+1], search right (low=mid+1). Otherwise search left (high=mid). When low==high, that's a peak."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low < high {\n    mid := (low+high)/2\n    if nums[mid] < nums[mid+1] {\n        low = mid + 1\n    } else {\n        high = mid\n    }\n}\nreturn low</pre>"
              }
            ],
            "solution": "func findPeak(nums []int) int {\n    low, high := 0, len(nums)-1\n    for low < high {\n        mid := (low + high) / 2\n        if nums[mid] < nums[mid+1] {\n            low = mid + 1\n        } else {\n            high = mid\n        }\n    }\n    return low\n}"
          },
          {
            "id": "v9",
            "title": "Minimum in Rotated Sorted Array",
            "description": "Write <code>func findMin(nums []int) int</code> that finds the minimum element in a sorted array that has been rotated. Example: [4,5,6,1,2,3] was [1,2,3,4,5,6] rotated. All elements are unique.",
            "functionSignature": "func findMin(nums []int) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "[]int{4,5,6,1,2,3}",
                "output": "1"
              },
              {
                "input": "[]int{3,1,2}",
                "output": "1"
              },
              {
                "input": "[]int{1,2,3,4}",
                "output": "1"
              },
              {
                "input": "[]int{2,1}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "In a rotated sorted array, the minimum is the 'rotation point'. Compare the middle element to the last element to determine which half the minimum is in."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "If nums[mid] > nums[high], the min is in the right half (low=mid+1). Otherwise it's in the left half including mid (high=mid)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low < high {\n    mid := (low+high)/2\n    if nums[mid] > nums[high] {\n        low = mid + 1\n    } else {\n        high = mid\n    }\n}\nreturn nums[low]</pre>"
              }
            ],
            "solution": "func findMin(nums []int) int {\n    low, high := 0, len(nums)-1\n    for low < high {\n        mid := (low + high) / 2\n        if nums[mid] > nums[high] {\n            low = mid + 1\n        } else {\n            high = mid\n        }\n    }\n    return nums[low]\n}"
          },
          {
            "id": "v10",
            "title": "Search in Rotated Array",
            "description": "Write <code>func searchRotated(nums []int, target int) int</code> that searches for target in a rotated sorted array. Return index or -1. All elements are unique.",
            "functionSignature": "func searchRotated(nums []int, target int) int",
            "difficulty": 4,
            "testCases": [
              {
                "input": "[]int{4,5,6,7,0,1,2}, 0",
                "output": "4"
              },
              {
                "input": "[]int{4,5,6,7,0,1,2}, 3",
                "output": "-1"
              },
              {
                "input": "[]int{1}, 1",
                "output": "0"
              },
              {
                "input": "[]int{3,1}, 1",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "One half of the array is always sorted. Determine which half is sorted, then check if target is in that sorted half."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "If left half is sorted (nums[low] <= nums[mid]): check if target is in [low, mid]. If right half is sorted: check if target is in [mid, high]. Narrow accordingly."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 0, len(nums)-1\nfor low <= high {\n    mid := (low+high)/2\n    if nums[mid] == target { return mid }\n    if nums[low] <= nums[mid] {  // left sorted\n        if nums[low] <= target && target < nums[mid] {\n            high = mid-1\n        } else { low = mid+1 }\n    } else {  // right sorted\n        if nums[mid] < target && target <= nums[high] {\n            low = mid+1\n        } else { high = mid-1 }\n    }\n}\nreturn -1</pre>"
              }
            ],
            "solution": "func searchRotated(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return mid\n        }\n        if nums[low] <= nums[mid] {\n            if nums[low] <= target && target < nums[mid] {\n                high = mid - 1\n            } else {\n                low = mid + 1\n            }\n        } else {\n            if nums[mid] < target && target <= nums[high] {\n                low = mid + 1\n            } else {\n                high = mid - 1\n            }\n        }\n    }\n    return -1\n}"
          },
          {
            "id": "v11",
            "title": "Find Closest Value",
            "description": "Write <code>func findClosest(nums []int, target int) int</code> that returns the value in the sorted slice closest to target. If tie, return the smaller value.",
            "functionSignature": "func findClosest(nums []int, target int) int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]int{1,3,5,7,9}, 6",
                "output": "5"
              },
              {
                "input": "[]int{1,3,5,7,9}, 5",
                "output": "5"
              },
              {
                "input": "[]int{1,10}, 4",
                "output": "1"
              },
              {
                "input": "[]int{1,10}, 6",
                "output": "10"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Binary search narrows down to adjacent elements. Compare the target's distance to both."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "After binary search, low points to the insertion position. Compare nums[low] and nums[low-1] (if they exist) to find which is closer."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>1. Binary search for insert position\n2. Compare neighbors at pos and pos-1\n3. Return the closer one (smaller on tie)</pre>"
              }
            ],
            "solution": "func findClosest(nums []int, target int) int {\n    low, high := 0, len(nums)-1\n    for low <= high {\n        mid := (low + high) / 2\n        if nums[mid] == target {\n            return nums[mid]\n        } else if nums[mid] < target {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    if low >= len(nums) {\n        return nums[len(nums)-1]\n    }\n    if low == 0 {\n        return nums[0]\n    }\n    if target-nums[low-1] <= nums[low]-target {\n        return nums[low-1]\n    }\n    return nums[low]\n}"
          },
          {
            "id": "v12",
            "title": "First Bad Version",
            "description": "Write <code>func firstBad(n int, isBad func(int) bool) int</code> that finds the first bad version in range [1, n]. The function isBad(v) returns true if version v is bad. Once a version is bad, all subsequent versions are bad.",
            "functionSignature": "func firstBad(n int, isBad func(int) bool) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "5, isBad (bad=4)",
                "output": "4"
              },
              {
                "input": "1, isBad (bad=1)",
                "output": "1"
              },
              {
                "input": "10, isBad (bad=7)",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "This is binary search on a boolean condition. The transition from false to true happens at exactly one point."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "low=1, high=n. If isBad(mid), the first bad is at mid or before: high=mid. If !isBad(mid), first bad is after: low=mid+1."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>low, high := 1, n\nfor low < high {\n    mid := (low+high)/2\n    if isBad(mid) {\n        high = mid\n    } else {\n        low = mid + 1\n    }\n}\nreturn low</pre>"
              }
            ],
            "solution": "func firstBad(n int, isBad func(int) bool) int {\n    low, high := 1, n\n    for low < high {\n        mid := (low + high) / 2\n        if isBad(mid) {\n            high = mid\n        } else {\n            low = mid + 1\n        }\n    }\n    return low\n}"
          }
        ]
      },
      {
        "id": "challenge_17",
        "block": 3,
        "difficulty": 1,
        "concept": "Stack Pattern",
        "sharedContentRef": "advanced_stack",
        "docLinks": [
          {
            "url": "https://go.dev/ref/spec#Appending_and_copying_slices",
            "title": "Go Spec: Appending slices",
            "note": "push with append"
          },
          {
            "url": "https://go.dev/ref/spec#Slice_expressions",
            "title": "Go Spec: Slice expressions",
            "note": "pop with re-slicing"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Nested loops or repeated scanning.",
          "bestApproach": "Use a slice as a stack (LIFO): push with append, pop by re-slicing. Process elements in last-in-first-out order.",
          "typical": "O(n) time, O(n) space"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Valid Parentheses",
            "description": "Write <code>func isValid(s string) bool</code> that checks if a string of parentheses '(' and ')' is valid (every open has a matching close in correct order).",
            "functionSignature": "func isValid(s string) bool",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"(())\"",
                "output": "true"
              },
              {
                "input": "\"()()\"",
                "output": "true"
              },
              {
                "input": "\"(()\"",
                "output": "false"
              },
              {
                "input": "\")\"",
                "output": "false"
              },
              {
                "input": "\"\"",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "When you see '(', you expect a ')' later. When you see ')', you need to match the most recent unmatched '('. What data structure handles 'most recent first'?"
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use a counter or stack. For '(' increment/push, for ')' decrement/pop. If counter goes negative, invalid. At end, must be zero."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>count := 0\nfor _, ch := range s {\n    if ch == '(' { count++ }\n    else { count-- }\n    if count < 0 { return false }\n}\nreturn count == 0</pre>"
              }
            ],
            "solution": "func isValid(s string) bool {\n    count := 0\n    for _, ch := range s {\n        if ch == '(' {\n            count++\n        } else {\n            count--\n        }\n        if count < 0 {\n            return false\n        }\n    }\n    return count == 0\n}"
          },
          {
            "id": "v2",
            "title": "Valid Brackets",
            "description": "Write <code>func validBrackets(s string) bool</code> that checks if a string containing '(', ')', '[', ']', '{', '}' has valid matching brackets.",
            "functionSignature": "func validBrackets(s string) bool",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"()[]{}\"",
                "output": "true"
              },
              {
                "input": "\"{[()]}\"",
                "output": "true"
              },
              {
                "input": "\"(]\"",
                "output": "false"
              },
              {
                "input": "\"([)]\"",
                "output": "false"
              },
              {
                "input": "\"\"",
                "output": "true"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "A simple counter won't work now because you have different bracket types. You need to remember WHICH bracket was opened."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Push opening brackets onto a stack. When you see a closer, pop the stack and check it matches. Use a map to pair closers with their openers."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>1. Create stack ([]rune)\n2. For each char:\n   - Opener? Push to stack\n   - Closer? Pop from stack, check match\n   - Empty stack when closing? Invalid\n3. Stack empty at end? Valid</pre>"
              }
            ],
            "solution": "func validBrackets(s string) bool {\n    stack := []rune{}\n    pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}\n    for _, ch := range s {\n        switch ch {\n        case '(', '[', '{':\n            stack = append(stack, ch)\n        case ')', ']', '}':\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[ch] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}"
          },
          {
            "id": "v3",
            "title": "Reverse String with Stack",
            "description": "Write <code>func reverseWithStack(s string) string</code> that reverses a string using a stack pattern (push all chars, then pop them all).",
            "functionSignature": "func reverseWithStack(s string) string",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"\"",
                "output": "\"\""
              },
              {
                "input": "\"a\"",
                "output": "\"a\""
              },
              {
                "input": "\"abcd\"",
                "output": "\"dcba\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Push every character onto the stack. Then pop them all off. Since stacks are LIFO, you'll get them in reverse order!"
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Push each byte/rune onto a slice. Then pop from the end and build the result string."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>stack := []byte{}\nfor i := 0; i < len(s); i++ {\n    stack = append(stack, s[i])  // push\n}\nresult := \"\"\nfor len(stack) > 0 {\n    top := stack[len(stack)-1]   // pop\n    stack = stack[:len(stack)-1]\n    result += string(top)\n}\nreturn result</pre>"
              }
            ],
            "solution": "func reverseWithStack(s string) string {\n    stack := []byte{}\n    for i := 0; i < len(s); i++ {\n        stack = append(stack, s[i])\n    }\n    result := \"\"\n    for len(stack) > 0 {\n        top := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        result += string(top)\n    }\n    return result\n}"
          },
          {
            "id": "v4",
            "title": "Remove Adjacent Duplicates",
            "description": "Write <code>func removeAdjacentDups(s string) string</code> that repeatedly removes pairs of adjacent duplicate characters. E.g., \"abbaca\" ‚Üí remove \"bb\" ‚Üí \"aaca\" ‚Üí remove \"aa\" ‚Üí \"ca\".",
            "functionSignature": "func removeAdjacentDups(s string) string",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"abbaca\"",
                "output": "\"ca\""
              },
              {
                "input": "\"azxxzy\"",
                "output": "\"ay\""
              },
              {
                "input": "\"abc\"",
                "output": "\"abc\""
              },
              {
                "input": "\"aaa\"",
                "output": "\"a\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "If you push characters onto a stack, you can check if the next character matches the top. If it does, pop (removing the pair) instead of pushing."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "For each character: if stack is non-empty and top == current char, pop. Otherwise push. The stack contains the result."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>stack := []byte{}\nfor i := 0; i < len(s); i++ {\n    if len(stack) > 0 && stack[len(stack)-1] == s[i] {\n        stack = stack[:len(stack)-1]  // pop pair\n    } else {\n        stack = append(stack, s[i])   // push\n    }\n}\nreturn string(stack)</pre>"
              }
            ],
            "solution": "func removeAdjacentDups(s string) string {\n    stack := []byte{}\n    for i := 0; i < len(s); i++ {\n        if len(stack) > 0 && stack[len(stack)-1] == s[i] {\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return string(stack)\n}"
          },
          {
            "id": "v5",
            "title": "Baseball Game",
            "description": "Write <code>func calPoints(ops []string) int</code>. Process operations: number=push score, \"+\"=push sum of last two, \"D\"=push double of last, \"C\"=pop last. Return total of all remaining scores.",
            "functionSignature": "func calPoints(ops []string) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "[]string{\"5\",\"2\",\"C\",\"D\",\"+\"}",
                "output": "30"
              },
              {
                "input": "[]string{\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"}",
                "output": "27"
              },
              {
                "input": "[]string{\"1\"}",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "A stack perfectly models this: push scores, pop for 'C', peek at top elements for 'D' and '+'."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use strconv.Atoi for number strings. For '+': peek at last two. For 'D': peek at last one. For 'C': pop. Finally sum the stack."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>stack := []int{}\nfor each op:\n  number? push Atoi(op)\n  \"+\"? push stack[-1] + stack[-2]\n  \"D\"? push stack[-1] * 2\n  \"C\"? pop\nreturn sum of stack</pre>"
              }
            ],
            "solution": "func calPoints(ops []string) int {\n    stack := []int{}\n    for _, op := range ops {\n        switch op {\n        case \"+\":\n            stack = append(stack, stack[len(stack)-1]+stack[len(stack)-2])\n        case \"D\":\n            stack = append(stack, stack[len(stack)-1]*2)\n        case \"C\":\n            stack = stack[:len(stack)-1]\n        default:\n            n, _ := strconv.Atoi(op)\n            stack = append(stack, n)\n        }\n    }\n    total := 0\n    for _, v := range stack {\n        total += v\n    }\n    return total\n}"
          },
          {
            "id": "v6",
            "title": "Next Greater Element",
            "description": "Write <code>func nextGreater(nums []int) []int</code> that for each element returns the next element that is greater. If none exists, use -1. E.g., [2,1,3] ‚Üí [3,3,-1].",
            "functionSignature": "func nextGreater(nums []int) []int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]int{2,1,3}",
                "output": "[]int{3,3,-1}"
              },
              {
                "input": "[]int{4,3,2,1}",
                "output": "[]int{-1,-1,-1,-1}"
              },
              {
                "input": "[]int{1,2,3,4}",
                "output": "[]int{2,3,4,-1}"
              },
              {
                "input": "[]int{1,3,2,4}",
                "output": "[]int{3,4,4,-1}"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "For each element, you need to find the next larger one to its right. A stack of indices can track elements waiting for their 'next greater'."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Traverse left to right. Stack holds indices of elements that haven't found their next greater. When current element is greater than top of stack, pop and assign current as the answer."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>result := make([]int, len(nums)) // fill with -1\nstack := []int{} // indices\nfor i, num := range nums {\n    for len(stack) > 0 && nums[stack[top]] < num {\n        result[stack[top]] = num\n        pop\n    }\n    push i\n}</pre>"
              }
            ],
            "solution": "func nextGreater(nums []int) []int {\n    result := make([]int, len(nums))\n    for i := range result {\n        result[i] = -1\n    }\n    stack := []int{}\n    for i, num := range nums {\n        for len(stack) > 0 && nums[stack[len(stack)-1]] < num {\n            idx := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            result[idx] = num\n        }\n        stack = append(stack, i)\n    }\n    return result\n}"
          },
          {
            "id": "v7",
            "title": "Daily Temperatures",
            "description": "Write <code>func dailyTemps(temps []int) []int</code> that returns how many days you have to wait for a warmer temperature. If no warmer day, 0.",
            "functionSignature": "func dailyTemps(temps []int) []int",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]int{73,74,75,71,69,72,76,73}",
                "output": "[]int{1,1,4,2,1,1,0,0}"
              },
              {
                "input": "[]int{30,40,50,60}",
                "output": "[]int{1,1,1,0}"
              },
              {
                "input": "[]int{60,50,40,30}",
                "output": "[]int{0,0,0,0}"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Similar to next greater element, but instead of the value, you want the distance (difference in indices)."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Stack of indices. When current temp > temp at stack top, pop and compute distance: i - popped_index."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>result := make([]int, len(temps))\nstack := []int{}\nfor i, t := range temps {\n    for len(stack) > 0 && temps[stack[top]] < t {\n        idx := pop\n        result[idx] = i - idx\n    }\n    push i\n}</pre>"
              }
            ],
            "solution": "func dailyTemps(temps []int) []int {\n    result := make([]int, len(temps))\n    stack := []int{}\n    for i, t := range temps {\n        for len(stack) > 0 && temps[stack[len(stack)-1]] < t {\n            idx := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            result[idx] = i - idx\n        }\n        stack = append(stack, i)\n    }\n    return result\n}"
          },
          {
            "id": "v8",
            "title": "Min Stack",
            "description": "Write a MinStack with <code>Push(x int)</code>, <code>Pop()</code>, <code>Top() int</code>, and <code>GetMin() int</code>. All operations must be O(1). Use two slices: one for values, one for tracking minimums.",
            "functionSignature": "type MinStack struct { ... }",
            "difficulty": 3,
            "testCases": [
              {
                "input": "Push(-2), Push(0), Push(-3), GetMin(), Pop(), Top(), GetMin()",
                "output": "-3, 0, -2"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "A regular stack can push/pop/top in O(1). But GetMin? You need to track the minimum at every level of the stack."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use a second stack that tracks the minimum at each depth. When pushing, also push the new min (min of x and current min) onto the min stack. When popping, pop from both."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>type MinStack struct {\n    vals []int\n    mins []int\n}\nPush: append to both (min of x and current min)\nPop: pop from both\nTop: vals[last]\nGetMin: mins[last]</pre>"
              }
            ],
            "solution": "type MinStack struct {\n    vals []int\n    mins []int\n}\n\nfunc (s *MinStack) Push(x int) {\n    s.vals = append(s.vals, x)\n    if len(s.mins) == 0 || x <= s.mins[len(s.mins)-1] {\n        s.mins = append(s.mins, x)\n    } else {\n        s.mins = append(s.mins, s.mins[len(s.mins)-1])\n    }\n}\n\nfunc (s *MinStack) Pop() {\n    s.vals = s.vals[:len(s.vals)-1]\n    s.mins = s.mins[:len(s.mins)-1]\n}\n\nfunc (s *MinStack) Top() int {\n    return s.vals[len(s.vals)-1]\n}\n\nfunc (s *MinStack) GetMin() int {\n    return s.mins[len(s.mins)-1]\n}"
          },
          {
            "id": "v9",
            "title": "Evaluate RPN",
            "description": "Write <code>func evalRPN(tokens []string) int</code> that evaluates a Reverse Polish Notation expression. Operators: +, -, *, /. Division truncates toward zero.",
            "functionSignature": "func evalRPN(tokens []string) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "[]string{\"2\",\"1\",\"+\",\"3\",\"*\"}",
                "output": "9"
              },
              {
                "input": "[]string{\"4\",\"13\",\"5\",\"/\",\"+\"}",
                "output": "6"
              },
              {
                "input": "[]string{\"3\",\"4\",\"+\"}",
                "output": "7"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "RPN is naturally stack-based. Numbers get pushed. Operators pop two numbers, compute, and push the result."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "For each token: if it's a number, push. If it's an operator, pop two values (b first, then a), compute a op b, push result."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>stack := []int{}\nfor each token:\n    if operator:\n        b, a := pop, pop\n        push a op b\n    else:\n        push Atoi(token)\nreturn stack[0]</pre>"
              }
            ],
            "solution": "func evalRPN(tokens []string) int {\n    stack := []int{}\n    for _, token := range tokens {\n        switch token {\n        case \"+\", \"-\", \"*\", \"/\":\n            b := stack[len(stack)-1]\n            a := stack[len(stack)-2]\n            stack = stack[:len(stack)-2]\n            switch token {\n            case \"+\":\n                stack = append(stack, a+b)\n            case \"-\":\n                stack = append(stack, a-b)\n            case \"*\":\n                stack = append(stack, a*b)\n            case \"/\":\n                stack = append(stack, a/b)\n            }\n        default:\n            n, _ := strconv.Atoi(token)\n            stack = append(stack, n)\n        }\n    }\n    return stack[0]\n}"
          },
          {
            "id": "v10",
            "title": "Decode String",
            "description": "Write <code>func decodeString(s string) string</code> that decodes encoded strings like \"3[a2[c]]\" ‚Üí \"accaccacc\". Format: k[encoded] means repeat encoded k times.",
            "functionSignature": "func decodeString(s string) string",
            "difficulty": 4,
            "testCases": [
              {
                "input": "\"3[a]2[bc]\"",
                "output": "\"aaabcbc\""
              },
              {
                "input": "\"3[a2[c]]\"",
                "output": "\"accaccacc\""
              },
              {
                "input": "\"2[abc]3[cd]ef\"",
                "output": "\"abcabccdcdcdef\""
              },
              {
                "input": "\"abc\"",
                "output": "\"abc\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Brackets nest, so you need to handle inner brackets before outer ones. That's LIFO order ‚Äî a stack!"
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use two stacks: one for repeat counts, one for strings being built. When you hit '[', push current string and count. When you hit ']', pop and repeat."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>countStack, strStack := []int{}, []string{}\ncurrent, num := \"\", 0\nfor each char:\n    digit? build num\n    '['? push num and current, reset both\n    ']'? pop count and prev, current = prev + repeat(current, count)\n    letter? current += char\nreturn current</pre>"
              }
            ],
            "solution": "func decodeString(s string) string {\n    countStack := []int{}\n    strStack := []string{}\n    current := \"\"\n    num := 0\n    for _, ch := range s {\n        if ch >= '0' && ch <= '9' {\n            num = num*10 + int(ch-'0')\n        } else if ch == '[' {\n            countStack = append(countStack, num)\n            strStack = append(strStack, current)\n            current = \"\"\n            num = 0\n        } else if ch == ']' {\n            count := countStack[len(countStack)-1]\n            countStack = countStack[:len(countStack)-1]\n            prev := strStack[len(strStack)-1]\n            strStack = strStack[:len(strStack)-1]\n            repeated := \"\"\n            for i := 0; i < count; i++ {\n                repeated += current\n            }\n            current = prev + repeated\n        } else {\n            current += string(ch)\n        }\n    }\n    return current\n}"
          },
          {
            "id": "v11",
            "title": "Simplify Path",
            "description": "Write <code>func simplifyPath(path string) string</code> that simplifies a Unix-style file path. Handle \".\", \"..\", multiple slashes, trailing slashes.",
            "functionSignature": "func simplifyPath(path string) string",
            "difficulty": 3,
            "testCases": [
              {
                "input": "\"/home/\"",
                "output": "\"/home\""
              },
              {
                "input": "\"/../\"",
                "output": "\"/\""
              },
              {
                "input": "\"/home//foo/\"",
                "output": "\"/home/foo\""
              },
              {
                "input": "\"/a/./b/../../c/\"",
                "output": "\"/c\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Split the path by '/'. Process each part: skip empty and '.', pop for '..', push otherwise. The stack represents the canonical path."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use strings.Split(path, \"/\"). Use a stack for directory names. Skip empty strings and \".\". For \"..\", pop if stack non-empty. Join with \"/\" at the end."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>parts := strings.Split(path, \"/\")\nstack := []string{}\nfor each part:\n    \"..\" and stack not empty? pop\n    \".\" or \"\"? skip\n    else? push\nreturn \"/\" + strings.Join(stack, \"/\")</pre>"
              }
            ],
            "solution": "func simplifyPath(path string) string {\n    parts := strings.Split(path, \"/\")\n    stack := []string{}\n    for _, part := range parts {\n        switch part {\n        case \"\", \".\":\n            continue\n        case \"..\":\n            if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n            }\n        default:\n            stack = append(stack, part)\n        }\n    }\n    return \"/\" + strings.Join(stack, \"/\")\n}"
          },
          {
            "id": "v12",
            "title": "Asteroid Collision",
            "description": "Write <code>func asteroidCollision(asteroids []int) []int</code>. Positive = moving right, negative = moving left. When two collide, smaller explodes. Equal = both explode. Same direction = no collision.",
            "functionSignature": "func asteroidCollision(asteroids []int) []int",
            "difficulty": 4,
            "testCases": [
              {
                "input": "[]int{5,10,-5}",
                "output": "[]int{5,10}"
              },
              {
                "input": "[]int{8,-8}",
                "output": "[]int{}"
              },
              {
                "input": "[]int{10,2,-5}",
                "output": "[]int{10}"
              },
              {
                "input": "[]int{-2,-1,1,2}",
                "output": "[]int{-2,-1,1,2}"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Only right-moving (positive) followed by left-moving (negative) causes collision. Use a stack and check for collisions when pushing negative asteroids."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Push positive asteroids. For negative: while stack top is positive and smaller, pop it (it explodes). If equal, pop both. If stack top is negative or empty, push."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>stack := []int{}\nfor each asteroid:\n    alive := true\n    for alive && asteroid < 0 && stack not empty && stack[top] > 0:\n        if stack[top] < -asteroid: pop (right explodes)\n        else if stack[top] == -asteroid: pop, alive=false (both explode)\n        else: alive = false (left explodes)\n    if alive: push\nreturn stack</pre>"
              }
            ],
            "solution": "func asteroidCollision(asteroids []int) []int {\n    stack := []int{}\n    for _, a := range asteroids {\n        alive := true\n        for alive && a < 0 && len(stack) > 0 && stack[len(stack)-1] > 0 {\n            top := stack[len(stack)-1]\n            if top < -a {\n                stack = stack[:len(stack)-1]\n            } else if top == -a {\n                stack = stack[:len(stack)-1]\n                alive = false\n            } else {\n                alive = false\n            }\n        }\n        if alive {\n            stack = append(stack, a)\n        }\n    }\n    return stack\n}"
          }
        ]
      },
      {
        "id": "challenge_18",
        "block": 2,
        "difficulty": 1,
        "concept": "String Manipulation",
        "sharedContentRef": "advanced_string_manipulation",
        "docLinks": [
          {
            "url": "https://pkg.go.dev/strings",
            "title": "Package strings",
            "note": "string functions"
          },
          {
            "url": "https://go.dev/blog/strings",
            "title": "Go Blog: Strings, bytes, runes",
            "note": "essential reading"
          }
        ],
        "patternPrimer": {
          "bruteForce": "Character-by-character processing with string concatenation.",
          "bestApproach": "Use the strings package for common operations. For character-level work, iterate with range for rune support or index for bytes.",
          "typical": "O(n) time, O(n) space for most string operations"
        },
        "variants": [
          {
            "id": "v1",
            "title": "Count Vowels",
            "description": "Write <code>func countVowels(s string) int</code> that counts the number of vowels (a, e, i, o, u, case-insensitive) in the string.",
            "functionSignature": "func countVowels(s string) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "2"
              },
              {
                "input": "\"AEIOU\"",
                "output": "5"
              },
              {
                "input": "\"xyz\"",
                "output": "0"
              },
              {
                "input": "\"\"",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Loop through each character. Check if it's a vowel. How can you handle both uppercase and lowercase?"
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Convert to lowercase first with strings.ToLower, then check each character against 'a','e','i','o','u'. Or use strings.ContainsRune."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>count := 0\nfor _, ch := range strings.ToLower(s) {\n    if ch == 'a' || ch == 'e' || ... { count++ }\n}\nreturn count</pre>"
              }
            ],
            "solution": "func countVowels(s string) int {\n    count := 0\n    for _, ch := range strings.ToLower(s) {\n        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n            count++\n        }\n    }\n    return count\n}"
          },
          {
            "id": "v2",
            "title": "Reverse Words",
            "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words in a string. Words are separated by spaces. Remove extra spaces.",
            "functionSignature": "func reverseWords(s string) string",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"world hello\""
              },
              {
                "input": "\"the sky is blue\"",
                "output": "\"blue is sky the\""
              },
              {
                "input": "\"  hello  world  \"",
                "output": "\"world hello\""
              },
              {
                "input": "\"a\"",
                "output": "\"a\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Split into words, reverse the word array, join back together."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use strings.Fields(s) to split by whitespace (handles multiple spaces). Reverse the resulting slice. Join with strings.Join."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>words := strings.Fields(s)\n// reverse words slice\nfor i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n    words[i], words[j] = words[j], words[i]\n}\nreturn strings.Join(words, \" \")</pre>"
              }
            ],
            "solution": "func reverseWords(s string) string {\n    words := strings.Fields(s)\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    return strings.Join(words, \" \")\n}"
          },
          {
            "id": "v3",
            "title": "Is Anagram",
            "description": "Write <code>func isAnagram(s, t string) bool</code> that checks if t is an anagram of s (same characters, different order). Assume lowercase letters only.",
            "functionSignature": "func isAnagram(s, t string) bool",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"anagram\", \"nagaram\"",
                "output": "true"
              },
              {
                "input": "\"rat\", \"car\"",
                "output": "false"
              },
              {
                "input": "\"\", \"\"",
                "output": "true"
              },
              {
                "input": "\"ab\", \"a\"",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Two strings are anagrams if they have exactly the same character frequencies."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Count character frequencies for both strings using maps (or [26]int arrays). Compare the counts."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>if len(s) != len(t) { return false }\ncounts := [26]int{}\nfor each char in s: counts[ch-'a']++\nfor each char in t: counts[ch-'a']--\ncheck all counts are 0</pre>"
              }
            ],
            "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    counts := [26]int{}\n    for _, ch := range s {\n        counts[ch-'a']++\n    }\n    for _, ch := range t {\n        counts[ch-'a']--\n    }\n    for _, c := range counts {\n        if c != 0 {\n            return false\n        }\n    }\n    return true\n}"
          },
          {
            "id": "v4",
            "title": "Capitalize Words",
            "description": "Write <code>func capitalizeWords(s string) string</code> that capitalizes the first letter of each word.",
            "functionSignature": "func capitalizeWords(s string) string",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"Hello World\""
              },
              {
                "input": "\"go is fun\"",
                "output": "\"Go Is Fun\""
              },
              {
                "input": "\"a\"",
                "output": "\"A\""
              },
              {
                "input": "\"\"",
                "output": "\"\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Split into words, capitalize first letter of each, join back."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "For each word, uppercase the first character and concatenate with the rest: strings.ToUpper(string(word[0])) + word[1:]."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>words := strings.Fields(s)\nfor i, word := range words {\n    words[i] = strings.ToUpper(string(word[0])) + word[1:]\n}\nreturn strings.Join(words, \" \")</pre>"
              }
            ],
            "solution": "func capitalizeWords(s string) string {\n    if s == \"\" {\n        return \"\"\n    }\n    words := strings.Fields(s)\n    for i, word := range words {\n        if len(word) > 0 {\n            words[i] = strings.ToUpper(string(word[0])) + word[1:]\n        }\n    }\n    return strings.Join(words, \" \")\n}"
          },
          {
            "id": "v5",
            "title": "Remove Duplicates from String",
            "description": "Write <code>func removeDuplicates(s string) string</code> that returns a string with duplicate characters removed, keeping only the first occurrence of each.",
            "functionSignature": "func removeDuplicates(s string) string",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"aabbcc\"",
                "output": "\"abc\""
              },
              {
                "input": "\"hello\"",
                "output": "\"helo\""
              },
              {
                "input": "\"abcabc\"",
                "output": "\"abc\""
              },
              {
                "input": "\"\"",
                "output": "\"\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Use a set (map) to track which characters you've already seen."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Create a map[rune]bool. For each character, if not seen, add to result and mark as seen."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>seen := map[rune]bool{}\nresult := \"\"\nfor _, ch := range s {\n    if !seen[ch] {\n        seen[ch] = true\n        result += string(ch)\n    }\n}\nreturn result</pre>"
              }
            ],
            "solution": "func removeDuplicates(s string) string {\n    seen := map[rune]bool{}\n    result := \"\"\n    for _, ch := range s {\n        if !seen[ch] {\n            seen[ch] = true\n            result += string(ch)\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v6",
            "title": "Caesar Cipher",
            "description": "Write <code>func caesarCipher(s string, shift int) string</code> that shifts each letter by shift positions (wrapping around). Only shift letters; leave other characters as-is. Handle both cases.",
            "functionSignature": "func caesarCipher(s string, shift int) string",
            "difficulty": 2,
            "testCases": [
              {
                "input": "\"abc\", 1",
                "output": "\"bcd\""
              },
              {
                "input": "\"xyz\", 3",
                "output": "\"abc\""
              },
              {
                "input": "\"Hello, World!\", 13",
                "output": "\"Uryyb, Jbeyq!\""
              },
              {
                "input": "\"abc\", 0",
                "output": "\"abc\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "For each letter, shift it by the given amount, wrapping around z‚Üía (or Z‚ÜíA). Non-letters stay the same."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "For lowercase: shifted = (ch - 'a' + shift) % 26 + 'a'. Same idea for uppercase with 'A'. Use shift%26 to handle large shifts."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>shift = ((shift % 26) + 26) % 26  // normalize\nfor each rune:\n    if 'a'-'z': result += ('a' + (ch-'a'+shift)%26)\n    if 'A'-'Z': result += ('A' + (ch-'A'+shift)%26)\n    else: result += ch</pre>"
              }
            ],
            "solution": "func caesarCipher(s string, shift int) string {\n    shift = ((shift % 26) + 26) % 26\n    result := \"\"\n    for _, ch := range s {\n        if ch >= 'a' && ch <= 'z' {\n            result += string(rune('a' + (ch-'a'+rune(shift))%26))\n        } else if ch >= 'A' && ch <= 'Z' {\n            result += string(rune('A' + (ch-'A'+rune(shift))%26))\n        } else {\n            result += string(ch)\n        }\n    }\n    return result\n}"
          },
          {
            "id": "v7",
            "title": "Longest Common Prefix",
            "description": "Write <code>func longestCommonPrefix(strs []string) string</code> that finds the longest common prefix string among an array of strings.",
            "functionSignature": "func longestCommonPrefix(strs []string) string",
            "difficulty": 2,
            "testCases": [
              {
                "input": "[]string{\"flower\",\"flow\",\"flight\"}",
                "output": "\"fl\""
              },
              {
                "input": "[]string{\"dog\",\"racecar\",\"car\"}",
                "output": "\"\""
              },
              {
                "input": "[]string{\"abc\"}",
                "output": "\"abc\""
              },
              {
                "input": "[]string{\"a\",\"a\"}",
                "output": "\"a\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Start with the first string as the prefix. Compare with each subsequent string and shorten the prefix as needed."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Take first string as prefix. For each other string, trim the prefix from the right until it matches the start of that string."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>prefix := strs[0]\nfor _, s := range strs[1:] {\n    for !strings.HasPrefix(s, prefix) {\n        prefix = prefix[:len(prefix)-1]\n        if prefix == \"\" { return \"\" }\n    }\n}\nreturn prefix</pre>"
              }
            ],
            "solution": "func longestCommonPrefix(strs []string) string {\n    if len(strs) == 0 {\n        return \"\"\n    }\n    prefix := strs[0]\n    for _, s := range strs[1:] {\n        for !strings.HasPrefix(s, prefix) {\n            prefix = prefix[:len(prefix)-1]\n            if prefix == \"\" {\n                return \"\"\n            }\n        }\n    }\n    return prefix\n}"
          },
          {
            "id": "v8",
            "title": "String Compression",
            "description": "Write <code>func compress(s string) string</code> that compresses consecutive duplicate characters: \"aabcccccaaa\" ‚Üí \"a2b1c5a3\". If compressed is not shorter, return original.",
            "functionSignature": "func compress(s string) string",
            "difficulty": 2,
            "testCases": [
              {
                "input": "\"aabcccccaaa\"",
                "output": "\"a2b1c5a3\""
              },
              {
                "input": "\"abc\"",
                "output": "\"abc\""
              },
              {
                "input": "\"aaa\"",
                "output": "\"a3\""
              },
              {
                "input": "\"\"",
                "output": "\"\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Walk through the string counting consecutive characters. When the character changes, write the character and its count."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Track current char and count. When char changes (or end of string), append char + count to result. Use strconv.Itoa for int to string."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>result := \"\"\ncount := 1\nfor i := 1; i <= len(s); i++ {\n    if i < len(s) && s[i] == s[i-1] { count++ }\n    else { result += string(s[i-1]) + Itoa(count); count = 1 }\n}\nif len(result) >= len(s) { return s }\nreturn result</pre>"
              }
            ],
            "solution": "func compress(s string) string {\n    if len(s) == 0 {\n        return s\n    }\n    result := \"\"\n    count := 1\n    for i := 1; i <= len(s); i++ {\n        if i < len(s) && s[i] == s[i-1] {\n            count++\n        } else {\n            result += string(s[i-1]) + strconv.Itoa(count)\n            count = 1\n        }\n    }\n    if len(result) >= len(s) {\n        return s\n    }\n    return result\n}"
          },
          {
            "id": "v9",
            "title": "Valid Palindrome (Alphanumeric)",
            "description": "Write <code>func isValidPalindrome(s string) bool</code> that checks if a string is a palindrome considering only alphanumeric characters and ignoring case.",
            "functionSignature": "func isValidPalindrome(s string) bool",
            "difficulty": 2,
            "testCases": [
              {
                "input": "\"A man, a plan, a canal: Panama\"",
                "output": "true"
              },
              {
                "input": "\"race a car\"",
                "output": "false"
              },
              {
                "input": "\" \"",
                "output": "true"
              },
              {
                "input": "\"0P\"",
                "output": "false"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Use two pointers from both ends. Skip non-alphanumeric characters. Compare lowercase versions."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Two pointers (left, right). Skip non-alphanumeric with unicode.IsLetter/IsDigit. Compare with unicode.ToLower. Move inward."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>left, right := 0, len(s)-1\nfor left < right {\n    skip non-alnum from left\n    skip non-alnum from right\n    if toLower(s[left]) != toLower(s[right]) { return false }\n    left++; right--\n}\nreturn true</pre>"
              }
            ],
            "solution": "func isValidPalindrome(s string) bool {\n    left, right := 0, len(s)-1\n    for left < right {\n        for left < right && !isAlnum(s[left]) {\n            left++\n        }\n        for left < right && !isAlnum(s[right]) {\n            right--\n        }\n        if toLower(s[left]) != toLower(s[right]) {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc isAlnum(b byte) bool {\n    return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9')\n}\n\nfunc toLower(b byte) byte {\n    if b >= 'A' && b <= 'Z' {\n        return b + 32\n    }\n    return b\n}"
          },
          {
            "id": "v10",
            "title": "Count Words",
            "description": "Write <code>func countWords(s string) int</code> that counts the number of words in a string. Words are separated by whitespace. Handle multiple spaces and leading/trailing spaces.",
            "functionSignature": "func countWords(s string) int",
            "difficulty": 1,
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "2"
              },
              {
                "input": "\"  hello   world  \"",
                "output": "2"
              },
              {
                "input": "\"\"",
                "output": "0"
              },
              {
                "input": "\"one\"",
                "output": "1"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "strings.Fields splits on any whitespace and handles multiple spaces. Count the resulting slice."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use len(strings.Fields(s)). The Fields function handles all edge cases with whitespace."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>return len(strings.Fields(s))</pre>"
              }
            ],
            "solution": "func countWords(s string) int {\n    return len(strings.Fields(s))\n}"
          },
          {
            "id": "v11",
            "title": "Zigzag Conversion",
            "description": "Write <code>func zigzag(s string, numRows int) string</code> that arranges text in a zigzag pattern with numRows rows, then reads line by line. E.g., \"PAYPALISHIRING\" with 3 rows: row0=\"PAHN\", row1=\"APLSIIG\", row2=\"YIR\" ‚Üí \"PAHNAPLSIIGYIR\".",
            "functionSignature": "func zigzag(s string, numRows int) string",
            "difficulty": 3,
            "testCases": [
              {
                "input": "\"PAYPALISHIRING\", 3",
                "output": "\"PAHNAPLSIIGYIR\""
              },
              {
                "input": "\"PAYPALISHIRING\", 4",
                "output": "\"PINALSIGYAHRPI\""
              },
              {
                "input": "\"A\", 1",
                "output": "\"A\""
              },
              {
                "input": "\"AB\", 1",
                "output": "\"AB\""
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Simulate the zigzag: move down through rows, then up, then down again. Assign each character to its row."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Create numRows string builders. Track current row and direction. For each char, add to current row, change direction at top/bottom."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>rows := make([]string, numRows)\ncurRow, goingDown := 0, false\nfor each char:\n    rows[curRow] += char\n    if curRow == 0 || curRow == numRows-1: flip direction\n    move curRow by direction\nreturn join all rows</pre>"
              }
            ],
            "solution": "func zigzag(s string, numRows int) string {\n    if numRows == 1 || numRows >= len(s) {\n        return s\n    }\n    rows := make([]string, numRows)\n    curRow := 0\n    goingDown := false\n    for _, ch := range s {\n        rows[curRow] += string(ch)\n        if curRow == 0 || curRow == numRows-1 {\n            goingDown = !goingDown\n        }\n        if goingDown {\n            curRow++\n        } else {\n            curRow--\n        }\n    }\n    result := \"\"\n    for _, row := range rows {\n        result += row\n    }\n    return result\n}"
          },
          {
            "id": "v12",
            "title": "Group Anagrams",
            "description": "Write <code>func groupAnagrams(strs []string) [][]string</code> that groups words that are anagrams of each other.",
            "functionSignature": "func groupAnagrams(strs []string) [][]string",
            "difficulty": 3,
            "testCases": [
              {
                "input": "[]string{\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"}",
                "output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]"
              },
              {
                "input": "[]string{\"\"}",
                "output": "[[\"\"]]"
              },
              {
                "input": "[]string{\"a\"}",
                "output": "[[\"a\"]]"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Anagrams have the same characters. If you sort the characters in each word, anagrams produce the same sorted string. Use that as a map key."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "For each string, sort its characters to create a key. Use a map[string][]string to group words with the same key. Return the map values."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>groups := map[string][]string{}\nfor each word:\n    key := sort characters of word\n    groups[key] = append(groups[key], word)\nreturn all values from groups</pre>"
              }
            ],
            "solution": "func groupAnagrams(strs []string) [][]string {\n    groups := map[string][]string{}\n    for _, s := range strs {\n        runes := []rune(s)\n        sort.Slice(runes, func(i, j int) bool { return runes[i] < runes[j] })\n        key := string(runes)\n        groups[key] = append(groups[key], s)\n    }\n    result := [][]string{}\n    for _, group := range groups {\n        result = append(result, group)\n    }\n    return result\n}"
          },
          {
            "id": "v13",
            "title": "Longest Substring Without Repeating",
            "description": "Write <code>func lengthOfLongestSubstring(s string) int</code> that returns the length of the longest substring without repeating characters.",
            "functionSignature": "func lengthOfLongestSubstring(s string) int",
            "difficulty": 3,
            "testCases": [
              {
                "input": "\"abcabcbb\"",
                "output": "3"
              },
              {
                "input": "\"bbbbb\"",
                "output": "1"
              },
              {
                "input": "\"pwwkew\"",
                "output": "3"
              },
              {
                "input": "\"\"",
                "output": "0"
              }
            ],
            "hints": [
              {
                "title": "√≠¬†¬æ√≠¬¥¬î Think about it",
                "content": "Use a sliding window. Expand right to include new characters. When you hit a repeat, shrink from the left until no duplicates."
              },
              {
                "title": "√≠¬†¬Ω√≠¬≤¬° Hint",
                "content": "Use a map to track the last index of each character. When a repeat is found, move the left pointer past the previous occurrence. Track max length."
              },
              {
                "title": "√≠¬†¬Ω√≠¬¥¬ß Pattern",
                "content": "<pre>lastSeen := map[byte]int{}\nleft, maxLen := 0, 0\nfor right := 0; right < len(s); right++ {\n    if idx, ok := lastSeen[s[right]]; ok && idx >= left {\n        left = idx + 1\n    }\n    lastSeen[s[right]] = right\n    if right-left+1 > maxLen { maxLen = right-left+1 }\n}\nreturn maxLen</pre>"
              }
            ],
            "solution": "func lengthOfLongestSubstring(s string) int {\n    lastSeen := map[byte]int{}\n    left, maxLen := 0, 0\n    for right := 0; right < len(s); right++ {\n        if idx, ok := lastSeen[s[right]]; ok && idx >= left {\n            left = idx + 1\n        }\n        lastSeen[s[right]] = right\n        if right-left+1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}"
          }
        ]
      }
    ],
    "advanced": [
      {
        "id": "advanced_1",
        "difficulty": 5,
        "baseTitle": "Map as Set",
        "concept": "Map as Set - Have I Seen This?",
        "variants": [
          {
            "id": "v1",
            "title": "Contains Duplicate",
            "description": "Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.",
            "functionSignature": "func containsDuplicate(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "true"
              }
            ],
            "solution": "func containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}"
          },
          {
            "id": "v2",
            "title": "First Duplicate Value",
            "description": "Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.",
            "functionSignature": "func firstDuplicate(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 3, 5, 3, 2}",
                "output": "3",
                "note": "3 is seen again before 2 is"
              },
              {
                "input": "[]int{1, 2, 3, 4}",
                "output": "-1"
              },
              {
                "input": "[]int{1, 1, 2, 2}",
                "output": "1"
              }
            ],
            "solution": "func firstDuplicate(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return num\n        }\n        seen[num] = true\n    }\n    return -1\n}",
            "solutionNotes": "Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!"
          },
          {
            "id": "v3",
            "title": "Count Unique Elements",
            "description": "Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.",
            "functionSignature": "func countUnique(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 3, 3, 3}",
                "output": "3",
                "note": "unique values: 1, 2, 3"
              },
              {
                "input": "[]int{5, 5, 5, 5}",
                "output": "1"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "5"
              }
            ],
            "solution": "func countUnique(nums []int) int {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        seen[num] = true\n    }\n    return len(seen)\n}",
            "solutionNotes": "Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!"
          },
          {
            "id": "v4",
            "title": "Find All Duplicates",
            "description": "Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.",
            "functionSignature": "func findDuplicates(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{4, 3, 2, 7, 8, 2, 3, 1}",
                "output": "[2, 3]"
              },
              {
                "input": "[]int{1, 1, 2, 2, 3, 3}",
                "output": "[1, 2, 3]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[]"
              }
            ],
            "solution": "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    added := make(map[int]bool)\n    result := []int{}\n    \n    for _, num := range nums {\n        if seen[num] && !added[num] {\n            result = append(result, num)\n            added[num] = true\n        }\n        seen[num] = true\n    }\n    return result\n}",
            "solutionNotes": "We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result."
          },
          {
            "id": "v5",
            "title": "Common Elements",
            "description": "Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.",
            "functionSignature": "func hasCommon(a, b []int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3}, []int{3, 4, 5}",
                "output": "true",
                "note": "3 is common"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "false"
              },
              {
                "input": "[]int{1}, []int{1}",
                "output": "true"
              }
            ],
            "solution": "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for _, num := range b {\n        if setA[num] {\n            return true\n        }\n    }\n    return false\n}",
            "solutionNotes": "Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!"
          },
          {
            "id": "v6",
            "title": "Find Intersection",
            "description": "Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.",
            "functionSignature": "func intersection(a, b []int) []int",
            "testCases": [
              {
                "input": "[]int{1, 2, 2, 1}, []int{2, 2}",
                "output": "[2]"
              },
              {
                "input": "[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}",
                "output": "[9, 4]",
                "note": "or [4, 9] - order doesn't matter"
              },
              {
                "input": "[]int{1, 2}, []int{3, 4}",
                "output": "[]"
              }
            ],
            "solution": "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result := []int{}\n    seen := make(map[int]bool)\n    for _, num := range b {\n        if setA[num] && !seen[num] {\n            result = append(result, num)\n            seen[num] = true\n        }\n    }\n    return result\n}",
            "solutionNotes": "Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result."
          }
        ]
      },
      {
        "id": "advanced_2",
        "difficulty": 5,
        "baseTitle": "Two-Pointer In-Place",
        "concept": "Slow/Fast Pointer Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Remove Duplicates from Sorted Array",
            "description": "Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.",
            "functionSignature": "func removeDuplicates(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 2}",
                "output": "2",
                "note": "array becomes [1, 2, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 2, 2, 3}",
                "output": "4",
                "note": "array becomes [0, 1, 2, 3, _, _, _]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "3"
              }
            ],
            "solution": "func removeDuplicates(nums []int) int {\n    if len(nums) == 0 {\n        return 0\n    }\n    slow := 0\n    for fast := 1; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow] {\n            slow++\n            nums[slow] = nums[fast]\n        }\n    }\n    return slow + 1\n}"
          },
          {
            "id": "v2",
            "title": "Remove Element",
            "description": "Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.",
            "functionSignature": "func removeElement(nums []int, val int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 2, 3}, 3",
                "output": "2",
                "note": "array becomes [2, 2, _, _]"
              },
              {
                "input": "[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2",
                "output": "5"
              },
              {
                "input": "[]int{1}, 1",
                "output": "0"
              }
            ],
            "solution": "func removeElement(nums []int, val int) int {\n    slow := 0\n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != val {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0."
          },
          {
            "id": "v3",
            "title": "Move Zeroes",
            "description": "Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.",
            "functionSignature": "func moveZeroes(nums []int)",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 3, 12}",
                "output": "[1, 3, 12, 0, 0]"
              },
              {
                "input": "[]int{0, 0, 1}",
                "output": "[1, 0, 0]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 2, 3]",
                "note": "no zeroes"
              }
            ],
            "solution": "func moveZeroes(nums []int) {\n    slow := 0\n    \n    for fast := 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    \n    for i := slow; i < len(nums); i++ {\n        nums[i] = 0\n    }\n}",
            "solutionNotes": "This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!"
          },
          {
            "id": "v4",
            "title": "Remove Duplicates II (Allow 2)",
            "description": "Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.",
            "functionSignature": "func removeDuplicatesII(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1, 2, 2, 3}",
                "output": "5",
                "note": "becomes [1, 1, 2, 2, 3, _]"
              },
              {
                "input": "[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}",
                "output": "7"
              },
              {
                "input": "[]int{1, 1}",
                "output": "2"
              }
            ],
            "solution": "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n        return len(nums)\n    }\n    \n    slow := 2\n    for fast := 2; fast < len(nums); fast++ {\n        if nums[fast] != nums[slow-2] {\n            nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return slow\n}",
            "solutionNotes": "The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2."
          },
          {
            "id": "v5",
            "title": "Sorted Squares",
            "description": "Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.",
            "functionSignature": "func sortedSquares(nums []int) []int",
            "testCases": [
              {
                "input": "[]int{-4, -1, 0, 3, 10}",
                "output": "[0, 1, 9, 16, 100]"
              },
              {
                "input": "[]int{-7, -3, 2, 3, 11}",
                "output": "[4, 9, 9, 49, 121]"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "[1, 4, 9]"
              }
            ],
            "solution": "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1\n    \n    for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n            result[pos] = leftSq\n            left++\n        } else {\n            result[pos] = rightSq\n            right--\n        }\n        pos--\n    }\n    return result\n}",
            "solutionNotes": "This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back."
          },
          {
            "id": "v6",
            "title": "Merge Sorted Array",
            "description": "Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).",
            "functionSignature": "func merge(nums1 []int, m int, nums2 []int, n int)",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3",
                "output": "[1, 2, 2, 3, 5, 6]"
              },
              {
                "input": "[]int{1}, 1, []int{}, 0",
                "output": "[1]"
              },
              {
                "input": "[]int{0}, 0, []int{1}, 1",
                "output": "[1]"
              }
            ],
            "solution": "func merge(nums1 []int, m int, nums2 []int, n int) {\n    p1 := m - 1\n    p2 := n - 1\n    pos := m + n - 1\n    \n    for p2 >= 0 {\n        if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n            p2--\n        }\n        pos--\n    }\n}",
            "solutionNotes": "Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place."
          }
        ]
      },
      {
        "id": "advanced_3",
        "difficulty": 5,
        "baseTitle": "String Manipulation",
        "concept": "Runes + Two-Pointer Swap",
        "variants": [
          {
            "id": "v1",
            "title": "Reverse a String",
            "description": "Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.",
            "functionSignature": "func reverse(s string) string",
            "testCases": [
              {
                "input": "\"hello\"",
                "output": "\"olleh\""
              },
              {
                "input": "\"‰∏ñÁïå\"",
                "output": "\"√ß¬ï¬å√§¬∏¬ñ\""
              },
              {
                "input": "\"GoüöÄ\"",
                "output": "\"üöÄoG\""
              }
            ],
            "solution": "func reverse(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}"
          },
          {
            "id": "v2",
            "title": "Is Palindrome",
            "description": "Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.",
            "functionSignature": "func isPalindrome(s string) bool",
            "testCases": [
              {
                "input": "\"A man, a plan, a canal: Panama\"",
                "output": "true"
              },
              {
                "input": "\"race a car\"",
                "output": "false"
              },
              {
                "input": "\"Was it a car or a cat I saw?\"",
                "output": "true"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) || unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        if runes[i] != runes[j] {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification."
          },
          {
            "id": "v3",
            "title": "Reverse Words in String",
            "description": "Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.",
            "functionSignature": "func reverseWords(s string) string",
            "testCases": [
              {
                "input": "\"hello world\"",
                "output": "\"world hello\""
              },
              {
                "input": "\"the sky is blue\"",
                "output": "\"blue is sky the\""
              },
              {
                "input": "\"Go\"",
                "output": "\"Go\""
              }
            ],
            "solution": "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    \n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n    return strings.Join(words, \" \")\n}",
            "solutionNotes": "Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together."
          },
          {
            "id": "v4",
            "title": "Reverse Only Letters",
            "description": "Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.",
            "functionSignature": "func reverseOnlyLetters(s string) string",
            "testCases": [
              {
                "input": "\"a-bC-dEf-ghIj\"",
                "output": "\"j-Ih-gfE-dCba\""
              },
              {
                "input": "\"ab-cd\"",
                "output": "\"dc-ba\""
              },
              {
                "input": "\"Test1ng-Leet=code-Q!\"",
                "output": "\"Qedo1teleC-test=gnin-T!\"",
                "note": "wait that's wrong"
              }
            ],
            "solution": "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n        }\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n        }\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n            i++\n            j--\n        }\n    }\n    return string(runes)\n}",
            "solutionNotes": "Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic."
          },
          {
            "id": "v5",
            "title": "Valid Palindrome II",
            "description": "Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.",
            "functionSignature": "func validPalindromeII(s string) bool",
            "testCases": [
              {
                "input": "\"aba\"",
                "output": "true",
                "note": "already palindrome"
              },
              {
                "input": "\"abca\"",
                "output": "true",
                "note": "remove 'c' or 'b'"
              },
              {
                "input": "\"abc\"",
                "output": "false"
              }
            ],
            "solution": "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n    \n    isPalin := func(i, j int) bool {\n        for i < j {\n            if runes[i] != runes[j] {\n                return false\n            }\n            i++\n            j--\n        }\n        return true\n    }\n    \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j] {\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n        i++\n        j--\n    }\n    return true\n}",
            "solutionNotes": "When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true."
          },
          {
            "id": "v6",
            "title": "Rotate String Left",
            "description": "Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.",
            "functionSignature": "func rotateLeft(s string, k int) string",
            "testCases": [
              {
                "input": "\"abcdef\", 2",
                "output": "\"cdefab\""
              },
              {
                "input": "\"hello\", 1",
                "output": "\"elloh\""
              },
              {
                "input": "\"Go\", 4",
                "output": "\"Go\"",
                "note": "k=4 is same as k=0 for len=2"
              }
            ],
            "solution": "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n        return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)\n    \n    reverse := func(start, end int) {\n        for start < end {\n            runes[start], runes[end] = runes[end], runes[start]\n            start++\n            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k, len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n}",
            "solutionNotes": "The \"reversal algorithm\" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!"
          }
        ]
      },
      {
        "id": "advanced_4",
        "difficulty": 5,
        "baseTitle": "Map Counting",
        "concept": "Map Counting Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Word Counter",
            "description": "Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.",
            "functionSignature": "func wordCount(s string) map[string]int",
            "testCases": [
              {
                "input": "\"the quick brown fox jumps over the lazy dog\"",
                "output": "map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]"
              }
            ],
            "solution": "import \"strings\"\n\nfunc wordCount(s string) map[string]int {\n    counts := make(map[string]int)\n    for _, word := range strings.Fields(s) {\n        counts[word]++\n    }\n    return counts\n}"
          },
          {
            "id": "v2",
            "title": "Most Frequent Element",
            "description": "Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.",
            "functionSignature": "func mostFrequent(nums []int) int",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 1, 4, 1}",
                "output": "1",
                "note": "1 appears 3 times"
              },
              {
                "input": "[]int{5, 5, 4, 4, 4}",
                "output": "4"
              },
              {
                "input": "[]int{7}",
                "output": "7"
              }
            ],
            "solution": "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount := 0\n    result := nums[0]\n    for num, count := range counts {\n        if count > maxCount {\n            maxCount = count\n            result = num\n        }\n    }\n    return result\n}",
            "solutionNotes": "First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures."
          },
          {
            "id": "v3",
            "title": "First Unique Character",
            "description": "Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.",
            "functionSignature": "func firstUniqChar(s string) int",
            "testCases": [
              {
                "input": "\"leetcode\"",
                "output": "0",
                "note": "'l' is first unique"
              },
              {
                "input": "\"loveleetcode\"",
                "output": "2",
                "note": "'v' is first unique"
              },
              {
                "input": "\"aabb\"",
                "output": "-1"
              }
            ],
            "solution": "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n    runes := []rune(s)\n    \n    for _, r := range runes {\n        counts[r]++\n    }\n    \n    for i, r := range runes {\n        if counts[r] == 1 {\n            return i\n        }\n    }\n    return -1\n}",
            "solutionNotes": "Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order."
          },
          {
            "id": "v4",
            "title": "Is Anagram",
            "description": "Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).",
            "functionSignature": "func isAnagram(s, t string) bool",
            "testCases": [
              {
                "input": "\"anagram\", \"nagaram\"",
                "output": "true"
              },
              {
                "input": "\"rat\", \"car\"",
                "output": "false"
              },
              {
                "input": "\"listen\", \"silent\"",
                "output": "true"
              }
            ],
            "solution": "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n        return false\n    }\n    \n    counts := make(map[rune]int)\n    for _, r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n        counts[r]--\n        if counts[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have."
          },
          {
            "id": "v5",
            "title": "Can Construct",
            "description": "Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).",
            "functionSignature": "func canConstruct(ransomNote, magazine string) bool",
            "testCases": [
              {
                "input": "\"a\", \"b\"",
                "output": "false"
              },
              {
                "input": "\"aa\", \"aab\"",
                "output": "true"
              },
              {
                "input": "\"aa\", \"ab\"",
                "output": "false",
                "note": "need 2 a's but only 1"
              }
            ],
            "solution": "func canConstruct(ransomNote, magazine string) bool {\n    available := make(map[rune]int)\n    \n    for _, r := range magazine {\n        available[r]++\n    }\n    \n    for _, r := range ransomNote {\n        available[r]--\n        if available[r] < 0 {\n            return false\n        }\n    }\n    return true\n}",
            "solutionNotes": "Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa."
          },
          {
            "id": "v6",
            "title": "Majority Element",
            "description": "Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.",
            "functionSignature": "func majorityElement(nums []int) int",
            "testCases": [
              {
                "input": "[]int{3, 2, 3}",
                "output": "3"
              },
              {
                "input": "[]int{2, 2, 1, 1, 1, 2, 2}",
                "output": "2"
              },
              {
                "input": "[]int{1, 1, 1, 1}",
                "output": "1"
              }
            ],
            "solution": "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n        counts[num]++\n        if counts[num] > threshold {\n            return num\n        }\n    }\n    return -1\n}",
            "solutionNotes": "We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!"
          }
        ]
      },
      {
        "id": "advanced_5",
        "difficulty": 5,
        "baseTitle": "Hash Map Lookup",
        "concept": "Hash Map Complement Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Two Sum",
            "description": "Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>",
            "functionSignature": "func twoSum(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[0, 1]"
              },
              {
                "input": "[]int{3, 2, 4}, 6",
                "output": "[1, 2]"
              },
              {
                "input": "[]int{3, 3}, 6",
                "output": "[0, 1]"
              }
            ],
            "solution": "func twoSum(nums []int, target int) []int {\n    seen := make(map[int]int)\n    for i, num := range nums {\n        complement := target - num\n        if j, ok := seen[complement]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}"
          },
          {
            "id": "v2",
            "title": "Two Sum II (Sorted Input)",
            "description": "Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>",
            "functionSignature": "func twoSumSorted(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{2, 7, 11, 15}, 9",
                "output": "[1, 2]",
                "note": "1-indexed!"
              },
              {
                "input": "[]int{2, 3, 4}, 6",
                "output": "[1, 3]"
              },
              {
                "input": "[]int{-1, 0}, -1",
                "output": "[1, 2]"
              }
            ],
            "solution": "func twoSumSorted(nums []int, target int) []int {\n    left, right := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left] + nums[right]\n        if sum == target {\n            return []int{left + 1, right + 1}\n        } else if sum < target {\n            left++\n        } else {\n            right--\n        }\n    }\n    return nil\n}",
            "solutionNotes": "When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum."
          },
          {
            "id": "v3",
            "title": "Pair with Difference",
            "description": "Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>",
            "functionSignature": "func pairWithDiff(nums []int, target int) []int",
            "testCases": [
              {
                "input": "[]int{5, 20, 3, 2, 50, 80}, 78",
                "output": "[1, 5]",
                "note": "80 - 2 = 78... wait"
              },
              {
                "input": "[]int{1, 5, 3}, 2",
                "output": "[0, 2]",
                "note": "3 - 1 = 2"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "nil"
              }
            ],
            "solution": "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)\n    \n    for i, num := range nums {\n        if j, ok := seen[num-target]; ok {\n            return []int{j, i}\n        }\n        if j, ok := seen[num+target]; ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n    }\n    return nil\n}",
            "solutionNotes": "Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k)."
          },
          {
            "id": "v4",
            "title": "Count Pairs with Sum",
            "description": "Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>",
            "functionSignature": "func countPairs(nums []int, target int) int",
            "testCases": [
              {
                "input": "[]int{1, 5, 7, 1}, 6",
                "output": "2",
                "note": "(1,5) and (1,5)"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2",
                "note": "two pairs of 1+1"
              },
              {
                "input": "[]int{1, 2, 3}, 10",
                "output": "0"
              }
            ],
            "solution": "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs := 0\n    for num, count := range counts {\n        complement := target - num\n        if complement == num {\n            pairs += count * (count - 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement > num {\n            pairs += count * compCount\n        }\n    }\n    return pairs\n}",
            "solutionNotes": "This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting."
          },
          {
            "id": "v5",
            "title": "Three Sum Exists",
            "description": "Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>",
            "functionSignature": "func threeSumExists(nums []int) bool",
            "testCases": [
              {
                "input": "[]int{-1, 0, 1, 2}",
                "output": "true",
                "note": "-1 + 0 + 1 = 0"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "false"
              },
              {
                "input": "[]int{0, 0, 0}",
                "output": "true"
              }
            ],
            "solution": "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        if i > 0 && nums[i] == nums[i-1] {\n            continue\n        }\n        \n        left, right := i+1, n-1\n        target := -nums[i]\n        \n        for left < right {\n            sum := nums[left] + nums[right]\n            if sum == target {\n                return true\n            } else if sum < target {\n                left++\n            } else {\n                right--\n            }\n        }\n    }\n    return false\n}",
            "solutionNotes": "Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n¬≤) total."
          },
          {
            "id": "v6",
            "title": "Subarray Sum Equals K",
            "description": "Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>",
            "functionSignature": "func subarraySum(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1, 1, 1}, 2",
                "output": "2",
                "note": "[1,1] at positions 0-1 and 1-2"
              },
              {
                "input": "[]int{1, 2, 3}, 3",
                "output": "2",
                "note": "[1,2] and [3]"
              },
              {
                "input": "[]int{1, -1, 0}, 0",
                "output": "3"
              }
            ],
            "solution": "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum := 0\n    seen := make(map[int]int)\n    seen[0] = 1\n    \n    for _, num := range nums {\n        prefixSum += num\n        if c, ok := seen[prefixSum-k]; ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n    return count\n}",
            "solutionNotes": "This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred."
          }
        ]
      },
      {
        "id": "advanced_6",
        "difficulty": 5,
        "baseTitle": "Sliding Window",
        "concept": "Sliding Window Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Maximum Sum Subarray of Size K",
            "description": "Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>",
            "functionSignature": "func maxSumSubarray(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{2, 1, 5, 1, 3, 2}, 3",
                "output": "9",
                "note": "subarray [5,1,3]"
              },
              {
                "input": "[]int{2, 3, 4, 1, 5}, 2",
                "output": "7",
                "note": "subarray [3,4]"
              },
              {
                "input": "[]int{1, 1, 1, 1}, 2",
                "output": "2"
              }
            ],
            "solution": "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k {\n        return 0\n    }\n    windowSum := 0\n    for i := 0; i < k; i++ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n    for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]\n        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space."
          },
          {
            "id": "v2",
            "title": "Longest Substring Without Repeating",
            "description": "Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>",
            "functionSignature": "func lengthOfLongestSubstring(s string) int",
            "testCases": [
              {
                "input": "\"abcabcbb\"",
                "output": "3",
                "note": "\"abc\""
              },
              {
                "input": "\"bbbbb\"",
                "output": "1",
                "note": "\"b\""
              },
              {
                "input": "\"pwwkew\"",
                "output": "3",
                "note": "\"wke\""
              }
            ],
            "solution": "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)\n    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx >= left {\n            left = lastIdx + 1\n        }\n        seen[char] = right\n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to."
          },
          {
            "id": "v3",
            "title": "Minimum Size Subarray Sum",
            "description": "Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>",
            "functionSignature": "func minSubarrayLen(target int, nums []int) int",
            "testCases": [
              {
                "input": "7, []int{2, 3, 1, 2, 4, 3}",
                "output": "2",
                "note": "[4,3] sums to 7"
              },
              {
                "input": "4, []int{1, 4, 4}",
                "output": "1",
                "note": "[4] alone >= 4"
              },
              {
                "input": "11, []int{1, 1, 1, 1}",
                "output": "0",
                "note": "can't reach 11"
              }
            ],
            "solution": "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums) + 1\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums); right++ {\n        sum += nums[right]\n        \n        for sum >= target {\n            if right - left + 1 < minLen {\n                minLen = right - left + 1\n            }\n            sum -= nums[left]\n            left++\n        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n    }\n    return minLen\n}",
            "solutionNotes": "Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern."
          },
          {
            "id": "v4",
            "title": "Average of Subarrays of Size K",
            "description": "Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums []int, k int) []float64</code>",
            "functionSignature": "func averageOfSubarrays(nums []int, k int) []float64",
            "testCases": [
              {
                "input": "[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5",
                "output": "[2.2, 2.8, 2.4, 3.6, 2.8]"
              },
              {
                "input": "[]int{1, 2, 3, 4}, 2",
                "output": "[1.5, 2.5, 3.5]"
              }
            ],
            "solution": "func averageOfSubarrays(nums []int, k int) []float64 {\n    result := []float64{}\n    windowSum := 0\n    \n    for i := 0; i < len(nums); i++ {\n        windowSum += nums[i]\n        \n        if i >= k-1 {\n            result = append(result, float64(windowSum)/float64(k))\n            windowSum -= nums[i-k+1]\n        }\n    }\n    return result\n}",
            "solutionNotes": "Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages."
          },
          {
            "id": "v5",
            "title": "Contains Duplicate Within K Distance",
            "description": "Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k. <code>func containsNearbyDuplicate(nums []int, k int) bool</code>",
            "functionSignature": "func containsNearbyDuplicate(nums []int, k int) bool",
            "testCases": [
              {
                "input": "[]int{1, 2, 3, 1}, 3",
                "output": "true"
              },
              {
                "input": "[]int{1, 0, 1, 1}, 1",
                "output": "true"
              },
              {
                "input": "[]int{1, 2, 3, 1, 2, 3}, 2",
                "output": "false"
              }
            ],
            "solution": "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen := make(map[int]bool)\n    \n    for i, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n        \n        if i >= k {\n            delete(seen, nums[i-k])\n        }\n    }\n    return false\n}",
            "solutionNotes": "Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove elements that leave the window."
          },
          {
            "id": "v6",
            "title": "Max Consecutive Ones III",
            "description": "Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k 0's. <code>func longestOnes(nums []int, k int) int</code>",
            "functionSignature": "func longestOnes(nums []int, k int) int",
            "testCases": [
              {
                "input": "[]int{1,1,1,0,0,0,1,1,1,1,0}, 2",
                "output": "6",
                "note": "flip 0's at indices 5 and 10"
              },
              {
                "input": "[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3",
                "output": "10"
              }
            ],
            "solution": "func longestOnes(nums []int, k int) int {\n    left := 0\n    zeros := 0\n    maxLen := 0\n    \n    for right := 0; right < len(nums); right++ {\n        if nums[right] == 0 {\n            zeros++\n        }\n        \n        for zeros > k {\n            if nums[left] == 0 {\n                zeros--\n            }\n            left++\n        }\n        \n        if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n        }\n    }\n    return maxLen\n}",
            "solutionNotes": "Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window size."
          }
        ]
      },
      {
        "id": "advanced_7",
        "difficulty": 5,
        "baseTitle": "Track Min/Max While Scanning",
        "concept": "Best So Far Pattern",
        "variants": [
          {
            "id": "v1",
            "title": "Best Time to Buy and Sell Stock",
            "description": "Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>",
            "functionSignature": "func maxProfit(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "5",
                "note": "buy at 1, sell at 6"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "prices only go down, no profit possible"
              },
              {
                "input": "[]int{2, 4, 1}",
                "output": "2",
                "note": "buy at 2, sell at 4"
              }
            ],
            "solution": "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n        return 0\n    }\n    \n    minPrice := prices[0]\n    maxProfit := 0\n    \n    for _, price := range prices {\n        if price < minPrice {\n            minPrice = price\n        } else if price - minPrice > maxProfit {\n            maxProfit = price - minPrice\n        }\n    }\n    return maxProfit\n}"
          },
          {
            "id": "v2",
            "title": "Maximum Difference",
            "description": "Find the maximum difference between any two elements where the larger element comes after the smaller one. Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>",
            "functionSignature": "func maxDiff(nums []int) int",
            "testCases": [
              {
                "input": "[]int{2, 3, 10, 6, 4, 8, 1}",
                "output": "8",
                "note": "10 - 2 = 8"
              },
              {
                "input": "[]int{7, 9, 5, 6, 3, 2}",
                "output": "2",
                "note": "9 - 7 = 2"
              },
              {
                "input": "[]int{5, 4, 3, 2, 1}",
                "output": "0",
                "note": "decreasing, no valid pair"
              }
            ],
            "solution": "func maxDiff(nums []int) int {\n    if len(nums) < 2 {\n        return 0\n    }\n    \n    minSoFar := nums[0]\n    maxDiff := 0\n    \n    for i := 1; i < len(nums); i++ {\n        diff := nums[i] - minSoFar\n        if diff > maxDiff {\n            maxDiff = diff\n        }\n        if nums[i] < minSoFar {\n            minSoFar = nums[i]\n        }\n    }\n    return maxDiff\n}",
            "solutionNotes": "This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position calculate the potential profit/difference."
          },
          {
            "id": "v3",
            "title": "Best Sightseeing Pair",
            "description": "Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func maxScoreSightseeingPair(values []int) int</code>",
            "functionSignature": "func maxScoreSightseeingPair(values []int) int",
            "testCases": [
              {
                "input": "[]int{8, 1, 5, 2, 6}",
                "output": "11",
                "note": "i=0, j=2: 8+5+0-2=11"
              },
              {
                "input": "[]int{1, 2}",
                "output": "2",
                "note": "1+2+0-1=2"
              },
              {
                "input": "[]int{1, 3, 5}",
                "output": "7",
                "note": "i=1, j=2: 3+5+1-2=7"
              }
            ],
            "solution": "func maxScoreSightseeingPair(values []int) int {\n    maxScore := 0\n    bestI := values[0] + 0  // values[i] + i\n    \n    for j := 1; j < len(values); j++ {\n        score := bestI + values[j] - j\n        if score > maxScore {\n            maxScore = score\n        }\n        if values[j] + j > bestI {\n            bestI = values[j] + j\n        }\n    }\n    return maxScore\n}",
            "solutionNotes": "Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for each j compute the score. Same pattern as stock problem!"
          },
          {
            "id": "v4",
            "title": "Maximum Subarray (Kadane's)",
            "description": "Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>",
            "functionSignature": "func maxSubArray(nums []int) int",
            "testCases": [
              {
                "input": "[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}",
                "output": "6",
                "note": "[4,-1,2,1] = 6"
              },
              {
                "input": "[]int{1}",
                "output": "1"
              },
              {
                "input": "[]int{-1, -2, -3}",
                "output": "-1",
                "note": "least negative"
              }
            ],
            "solution": "func maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if currentSum < 0 {\n            currentSum = nums[i]\n        } else {\n            currentSum += nums[i]\n        }\n        if currentSum > maxSum {\n            maxSum = currentSum\n        }\n    }\n    return maxSum\n}",
            "solutionNotes": "Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track the best sum seen so far. Same 'best so far' pattern!"
          },
          {
            "id": "v5",
            "title": "Best Time to Buy and Sell Stock II",
            "description": "You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit. <code>func maxProfitII(prices []int) int</code>",
            "functionSignature": "func maxProfitII(prices []int) int",
            "testCases": [
              {
                "input": "[]int{7, 1, 5, 3, 6, 4}",
                "output": "7",
                "note": "buy@1 sell@5 (+4), buy@3 sell@6 (+3)"
              },
              {
                "input": "[]int{1, 2, 3, 4, 5}",
                "output": "4",
                "note": "buy@1 sell@5, or buy/sell each day"
              },
              {
                "input": "[]int{7, 6, 4, 3, 1}",
                "output": "0",
                "note": "no profit possible"
              }
            ],
            "solution": "func maxProfitII(prices []int) int {\n    profit := 0\n    \n    for i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n            profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n}",
            "solutionNotes": "Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all positive differences. Much simpler than it seems!"
          },
          {
            "id": "v6",
            "title": "Trapping Rain Water",
            "description": "Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining. <code>func trap(height []int) int</code>",
            "functionSignature": "func trap(height []int) int",
            "testCases": [
              {
                "input": "[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}",
                "output": "6"
              },
              {
                "input": "[]int{4, 2, 0, 3, 2, 5}",
                "output": "9"
              },
              {
                "input": "[]int{1, 2, 3}",
                "output": "0",
                "note": "strictly increasing, no trapping"
              }
            ],
            "solution": "func trap(height []int) int {\n    if len(height) == 0 {\n        return 0\n    }\n    \n    n := len(height)\n    maxLeft := make([]int, n)\n    maxRight := make([]int, n)\n    \n    maxLeft[0] = height[0]\n    for i := 1; i < n; i++ {\n        if height[i] > maxLeft[i-1] {\n            maxLeft[i] = height[i]\n        } else {\n            maxLeft[i] = maxLeft[i-1]\n        }\n    }\n    \n    maxRight[n-1] = height[n-1]\n    for i := n - 2; i >= 0; i-- {\n        if height[i] > maxRight[i+1] {\n            maxRight[i] = height[i]\n        } else {\n            maxRight[i] = maxRight[i+1]\n        }\n    }\n    \n    water := 0\n    for i := 0; i < n; i++ {\n        level := maxLeft[i]\n        if maxRight[i] < level {\n            level = maxRight[i]\n        }\n        water += level - height[i]\n    }\n    return water\n}",
            "solutionNotes": "At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using the 'best so far' pattern in both directions!"
          }
        ]
      }
    ],
    "preExercises": {
      "advanced_1": {
        "title": "Pre-exercise: Map as a Set",
        "description": "Before tackling the algorithm, let's practice the core pattern: using a map to track what you've seen.",
        "exercises": [
          {
            "id": "pre1",
            "title": "Track Visited Pages",
            "problem": "You're building a browser history tracker. Write code that creates a <code>map[string]bool</code> called <code>visited</code>, marks three pages as visited, then checks if \"google.com\" has been visited.",
            "hints": [
              {
                "title": "Creating the map",
                "content": "Create with: <code>visited := make(map[string]bool)</code><br>This creates an empty map where keys are strings and values are booleans."
              },
              {
                "title": "Marking as visited",
                "content": "To mark a page as visited: <code>visited[\"google.com\"] = true</code><br>Do this for three different pages."
              },
              {
                "title": "Checking if visited",
                "content": "The simple way: <code>if visited[\"google.com\"]</code><br>This works because if the key doesn't exist, Go returns <code>false</code> (the zero value for bool)!"
              }
            ],
            "solution": "visited := make(map[string]bool)\n\n// Mark pages as visited\nvisited[\"google.com\"] = true\nvisited[\"github.com\"] = true\nvisited[\"go.dev\"] = true\n\n// Check if google.com was visited\nif visited[\"google.com\"] {\n    fmt.Println(\"You've been to google.com\")\n}\n\n// Check something NOT visited\nif visited[\"facebook.com\"] {\n    fmt.Println(\"You've been to facebook.com\")\n} else {\n    fmt.Println(\"Never visited facebook.com\")\n}",
            "expectedOutput": "You've been to google.com\nNever visited facebook.com",
            "keyInsight": "When you access a key that doesn't exist in a <code>map[T]bool</code>, Go returns <code>false</code>. This makes <code>if visited[key]</code> a clean way to check membership - no need for the comma-ok pattern here!"
          },
          {
            "id": "pre2",
            "title": "Unique Letter Collector",
            "problem": "Write code that loops through the string \"banana\" and collects each unique letter into a <code>map[rune]bool</code>. Print how many unique letters there are.",
            "hints": [
              {
                "title": "Setup",
                "content": "Create the map: <code>letters := make(map[rune]bool)</code><br>Loop with: <code>for _, char := range \"banana\"</code>"
              },
              {
                "title": "Collecting",
                "content": "For each character, just mark it as seen: <code>letters[char] = true</code><br>Maps automatically handle duplicates - setting the same key twice just overwrites."
              },
              {
                "title": "Counting",
                "content": "The number of unique letters is: <code>len(letters)</code>"
              }
            ],
            "solution": "letters := make(map[rune]bool)\n\nfor _, char := range \"banana\" {\n    letters[char] = true\n}\n\nfmt.Printf(\"Unique letters: %d\\n\", len(letters))  // 3: b, a, n",
            "expectedOutput": "Unique letters: 3",
            "keyInsight": "A map automatically handles duplicates - you can set the same key multiple times and it just overwrites. This is why <code>len(map)</code> gives you the count of unique keys!"
          }
        ]
      },
      "advanced_2": {
        "title": "Pre-exercise: Slow/Fast Pointer Prep",
        "description": "Before the in-place algorithm, let's practice the core logic of detecting duplicates in sorted arrays.",
        "exercises": [
          {
            "id": "pre2a",
            "title": "Copy Unique to New Slice",
            "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 3}</code>, create a NEW slice containing only the unique values <code>[1, 2, 3]</code>. Don't modify the original - just build a new one with <code>append</code>.",
            "hints": [
              {
                "title": "Step 1: Setup",
                "content": "<pre>nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element is always unique</pre>"
              },
              {
                "title": "Step 2: Loop starting from index 1",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    // Compare current with previous\n}</pre>"
              },
              {
                "title": "Step 3: Append when different",
                "content": "<pre>if nums[i] != nums[i-1] {\n    result = append(result, nums[i])\n}</pre>"
              }
            ],
            "solution": "nums := []int{1, 1, 2, 2, 3}\nresult := []int{nums[0]}  // First element always unique\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        result = append(result, nums[i])\n    }\n}\n\nfmt.Println(result)  // [1 2 3]",
            "expectedOutput": "[1 2 3]",
            "keyInsight": "In a sorted array, duplicates are always adjacent! So we only need to compare each element with the one before it. This same logic powers the in-place algorithm - we'll just write to the array instead of appending."
          },
          {
            "id": "pre2b",
            "title": "Count Consecutive Groups",
            "problem": "Given the sorted slice <code>[]int{1, 1, 2, 2, 2, 3}</code>, count how many distinct groups there are. Answer: 3 (the 1s, the 2s, and the 3).",
            "hints": [
              {
                "title": "Step 1: Initialize counter",
                "content": "<pre>nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group</pre>"
              },
              {
                "title": "Step 2: Loop and count transitions",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}</pre>"
              }
            ],
            "solution": "nums := []int{1, 1, 2, 2, 2, 3}\ngroups := 1  // First element starts the first group\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] != nums[i-1] {\n        groups++  // New value = new group\n    }\n}\n\nfmt.Printf(\"Groups: %d\\n\", groups)",
            "expectedOutput": "Groups: 3",
            "keyInsight": "This is exactly what the slow/fast algorithm returns! The slow pointer ends up at the last unique position, so slow+1 = number of unique elements = number of groups."
          }
        ]
      },
      "advanced_3": {
        "title": "Pre-exercise: Strings vs Runes",
        "description": "Before manipulating strings character-by-character, let's understand the difference between bytes and runes in Go.",
        "exercises": [
          {
            "id": "pre3a",
            "title": "Explore String Length vs Rune Count",
            "problem": "Compare the byte length and rune count of these strings: <code>\"hello\"</code>, <code>\"‰∏ñÁïå\"</code>, and <code>\"üéâ\"</code>. Print both <code>len(s)</code> and <code>len([]rune(s))</code> for each.",
            "hints": [
              {
                "title": "Step 1: ASCII string",
                "content": "<pre>s1 := \"hello\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s1, len(s1), len([]rune(s1)))</pre>"
              },
              {
                "title": "Step 2: Chinese characters",
                "content": "<pre>s2 := \"‰∏ñÁïå\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s2, len(s2), len([]rune(s2)))</pre>"
              },
              {
                "title": "Step 3: Emoji",
                "content": "<pre>s3 := \"üéâ\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s3, len(s3), len([]rune(s3)))</pre>"
              }
            ],
            "solution": "s1 := \"hello\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s1, len(s1), len([]rune(s1)))\n\ns2 := \"‰∏ñÁïå\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s2, len(s2), len([]rune(s2)))\n\ns3 := \"üéâ\"\nfmt.Printf(\"%s: %d bytes, %d runes\\n\", s3, len(s3), len([]rune(s3)))",
            "expectedOutput": "hello: 5 bytes, 5 runes\n‰∏ñÁïå: 6 bytes, 2 runes\nüéâ: 4 bytes, 1 runes",
            "keyInsight": "ASCII characters are 1 byte each, but Unicode characters can be 2-4 bytes! <code>len(string)</code> counts bytes, <code>len([]rune(string))</code> counts actual characters. Always convert to <code>[]rune</code> when you need to work with individual characters."
          },
          {
            "id": "pre3b",
            "title": "Convert, Modify, Convert Back",
            "problem": "Take the string <code>\"Go!\"</code>, convert to runes, change the first character to <code>'g'</code>, and convert back to a string. Print the result.",
            "hints": [
              {
                "title": "Step 1: Convert to runes",
                "content": "<pre>s := \"Go!\"\nrunes := []rune(s)</pre>"
              },
              {
                "title": "Step 2: Modify",
                "content": "<pre>runes[0] = 'g'  // Single quotes for rune literal</pre>"
              },
              {
                "title": "Step 3: Convert back",
                "content": "<pre>result := string(runes)\nfmt.Println(result)</pre>"
              }
            ],
            "solution": "s := \"Go!\"\nrunes := []rune(s)\n\nrunes[0] = 'g'  // Modify first character\n\nresult := string(runes)\nfmt.Println(result)",
            "expectedOutput": "go!",
            "keyInsight": "Strings in Go are immutable - you can't do <code>s[0] = 'g'</code>. The pattern is: convert to <code>[]rune</code>, modify the slice, convert back to <code>string</code>. This is exactly what we'll do for reversing strings!"
          }
        ]
      },
      "advanced_4": {
        "title": "Pre-exercise: Map Counting Prep",
        "description": "Before counting words, let's practice the building blocks: splitting strings and incrementing map values.",
        "exercises": [
          {
            "id": "pre4a",
            "title": "Explore strings.Fields",
            "problem": "Use <code>strings.Fields</code> to split the string <code>\"hello world go\"</code> into words and print each word on its own line.",
            "hints": [
              {
                "title": "Step 1: Import and split",
                "content": "<pre>import \"strings\"\n\nwords := strings.Fields(\"hello world go\")</pre>"
              },
              {
                "title": "Step 2: Loop and print",
                "content": "<pre>for _, word := range words {\n    fmt.Println(word)\n}</pre>"
              }
            ],
            "solution": "import \"strings\"\n\nwords := strings.Fields(\"hello world go\")\nfor _, word := range words {\n    fmt.Println(word)\n}",
            "expectedOutput": "hello\nworld\ngo",
            "keyInsight": "<code>strings.Fields</code> splits on any whitespace (spaces, tabs, newlines) and returns a <code>[]string</code>. It's smarter than <code>strings.Split(s, \" \")</code> because it handles multiple spaces correctly."
          },
          {
            "id": "pre4b",
            "title": "Count Letters (Simpler)",
            "problem": "Count how many times each letter appears in <code>\"hello\"</code>. Store in a <code>map[rune]int</code> and print the counts.",
            "hints": [
              {
                "title": "Step 1: Create the map",
                "content": "<pre>counts := make(map[rune]int)</pre>"
              },
              {
                "title": "Step 2: Loop through string",
                "content": "<pre>for _, char := range \"hello\" {\n    counts[char]++\n}</pre>"
              },
              {
                "title": "Step 3: Print results",
                "content": "<pre>for char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}</pre>"
              }
            ],
            "solution": "counts := make(map[rune]int)\n\nfor _, char := range \"hello\" {\n    counts[char]++\n}\n\nfor char, count := range counts {\n    fmt.Printf(\"%c: %d\\n\", char, count)\n}",
            "expectedOutput": "h: 1\ne: 1\nl: 2\no: 1",
            "keyInsight": "The <code>++</code> operator works on map values! When the key doesn't exist, Go returns 0 (the zero value for int), then increments to 1. So <code>counts[char]++</code> handles both first-time and repeat cases."
          }
        ]
      },
      "advanced_5": {
        "title": "Pre-exercise: Two Sum Building Blocks",
        "description": "Before the full algorithm, let's practice the two key operations: looking up complements and building index maps.",
        "exercises": [
          {
            "id": "pre5a",
            "title": "Find Complement in Map",
            "problem": "Given this pre-built map <code>map[int]int{2: 0, 7: 1, 11: 2}</code> (value to index), target=9, and current number=7: calculate the complement and check if it exists in the map. Print the result.",
            "hints": [
              {
                "title": "Step 1: Setup",
                "content": "<pre>seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7</pre>"
              },
              {
                "title": "Step 2: Calculate complement",
                "content": "<pre>complement := target - num  // 9 - 7 = 2</pre>"
              },
              {
                "title": "Step 3: Check map with comma-ok",
                "content": "<pre>if idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found! %d is at index %d\\n\", complement, idx)\n}</pre>"
              }
            ],
            "solution": "seen := map[int]int{2: 0, 7: 1, 11: 2}\ntarget := 9\nnum := 7\n\ncomplement := target - num  // 9 - 7 = 2\n\nif idx, ok := seen[complement]; ok {\n    fmt.Printf(\"Found %d at index %d\\n\", complement, idx)\n} else {\n    fmt.Println(\"Not found\")\n}",
            "expectedOutput": "Found 2 at index 0",
            "keyInsight": "The complement is <code>target - current</code>. If we're looking for two numbers that sum to 9, and we have 7, we need to find 2. The map tells us WHERE we saw the 2 (at index 0)."
          },
          {
            "id": "pre5b",
            "title": "Build Value-to-Index Map",
            "problem": "Given <code>[]int{2, 7, 11}</code>, build a map that maps each value to its index: <code>map[int]int{2: 0, 7: 1, 11: 2}</code>.",
            "hints": [
              {
                "title": "Step 1: Create empty map",
                "content": "<pre>nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)</pre>"
              },
              {
                "title": "Step 2: Loop with index",
                "content": "<pre>for i, num := range nums {\n    valueToIndex[num] = i\n}</pre>"
              }
            ],
            "solution": "nums := []int{2, 7, 11}\nvalueToIndex := make(map[int]int)\n\nfor i, num := range nums {\n    valueToIndex[num] = i\n}\n\nfmt.Println(valueToIndex)",
            "expectedOutput": "map[2:0 7:1 11:2]",
            "keyInsight": "The Two Sum algorithm builds this map AS it loops - checking for the complement first, then adding the current number. This ensures we don't match a number with itself!"
          }
        ]
      },
      "advanced_6": {
        "title": "Pre-exercise: Sliding Window Fundamentals",
        "description": "Before tackling sliding window problems, let's practice the core mechanics: managing a window and efficiently updating its state.",
        "exercises": [
          {
            "id": "pre6a",
            "title": "Fixed Window Sum",
            "problem": "Given <code>[]int{1, 2, 3, 4, 5}</code> and window size k=3, calculate the sum of the first window [1,2,3], then slide it one position and calculate the new sum [2,3,4] WITHOUT re-summing all elements.",
            "hints": [
              {
                "title": "Step 1: Calculate first window sum",
                "content": "<pre>nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first k elements\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Println(windowSum)  // 6</pre>"
              },
              {
                "title": "Step 2: Slide the window",
                "content": "<pre>// The trick: add new element, subtract old element\n// New element is at index k (which is 3)\n// Old element is at index 0\nwindowSum = windowSum + nums[k] - nums[0]</pre>"
              },
              {
                "title": "Step 3: General formula",
                "content": "When sliding from position i-1 to i:<pre>windowSum = windowSum + nums[i+k-1] - nums[i-1]</pre>Or equivalently, when the right edge moves to index i:<pre>windowSum = windowSum + nums[i] - nums[i-k]</pre>"
              }
            ],
            "solution": "nums := []int{1, 2, 3, 4, 5}\nk := 3\n\n// Sum first window\nwindowSum := 0\nfor i := 0; i < k; i++ {\n    windowSum += nums[i]\n}\nfmt.Printf(\"Window [0:3] sum: %d\\n\", windowSum)  // 6\n\n// Slide window: add nums[3], remove nums[0]\nwindowSum = windowSum + nums[3] - nums[0]\nfmt.Printf(\"Window [1:4] sum: %d\\n\", windowSum)  // 9\n\n// Slide again: add nums[4], remove nums[1]\nwindowSum = windowSum + nums[4] - nums[1]\nfmt.Printf(\"Window [2:5] sum: %d\\n\", windowSum)  // 12",
            "expectedOutput": "Window [0:3] sum: 6\nWindow [1:4] sum: 9\nWindow [2:5] sum: 12",
            "keyInsight": "The sliding window trick: instead of recalculating the entire sum (O(k)), just add the new element and subtract the leaving element (O(1)). This makes processing all windows O(n) instead of O(n*k)!"
          },
          {
            "id": "pre6b",
            "title": "Variable Window with Map",
            "problem": "Track characters in a variable-size window. Given string \"abca\", add characters one by one to a <code>map[byte]int</code> (tracking counts), then simulate shrinking by decrementing counts.",
            "hints": [
              {
                "title": "Step 1: Setup and expand",
                "content": "<pre>s := \"abca\"\nseen := make(map[byte]int)\n\n// Add each character (expanding window)\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n    fmt.Printf(\"Added %c, counts: %v\\n\", s[i], seen)\n}</pre>"
              },
              {
                "title": "Step 2: Shrink from left",
                "content": "<pre>// Remove the first character (shrink)\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])  // Clean up zero counts\n}\nfmt.Printf(\"After removing %c: %v\\n\", s[0], seen)</pre>"
              }
            ],
            "solution": "s := \"abca\"\nseen := make(map[byte]int)\n\n// Expand: add all characters\nfor i := 0; i < len(s); i++ {\n    seen[s[i]]++\n}\nfmt.Printf(\"Full window: %v\\n\", seen)  // a:2, b:1, c:1\n\n// Shrink: remove from left (index 0 = 'a')\nseen[s[0]]--\nif seen[s[0]] == 0 {\n    delete(seen, s[0])\n}\nfmt.Printf(\"After removing s[0]: %v\\n\", seen)  // a:1, b:1, c:1\n\n// Shrink more: remove s[1] = 'b'\nseen[s[1]]--\nif seen[s[1]] == 0 {\n    delete(seen, s[1])\n}\nfmt.Printf(\"After removing s[1]: %v\\n\", seen)  // a:1, c:1",
            "expectedOutput": "Full window: map[97:2 98:1 99:1]\nAfter removing s[0]: map[97:1 98:1 99:1]\nAfter removing s[1]: map[97:1 99:1]",
            "keyInsight": "Variable sliding windows use a map to track what's in the window. When expanding (right pointer moves), increment counts. When shrinking (left pointer moves), decrement counts. Delete keys when count hits 0 to keep the map clean."
          }
        ]
      },
      "advanced_7": {
        "title": "Pre-exercise: Tracking Best So Far",
        "description": "Before tackling optimization problems, let's practice the core pattern: tracking a running minimum/maximum while scanning.",
        "exercises": [
          {
            "id": "pre7a",
            "title": "Track Running Minimum",
            "problem": "Given <code>[]int{5, 3, 8, 1, 9, 2}</code>, print the running minimum after each element. Output should show: 5, 3, 3, 1, 1, 1.",
            "hints": [
              {
                "title": "Step 1: Initialize",
                "content": "<pre>nums := []int{5, 3, 8, 1, 9, 2}\nminSoFar := nums[0]\nfmt.Println(minSoFar)  // First element is the min so far</pre>"
              },
              {
                "title": "Step 2: Loop and update",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n    fmt.Println(minSoFar)\n}</pre>"
              }
            ],
            "solution": "nums := []int{5, 3, 8, 1, 9, 2}\nminSoFar := nums[0]\nfmt.Println(minSoFar)\n\nfor i := 1; i < len(nums); i++ {\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n    fmt.Println(minSoFar)\n}",
            "expectedOutput": "5\n3\n3\n1\n1\n1",
            "keyInsight": "At each position, <code>minSoFar</code> holds the smallest value we've seen from the start up to that point. This is the foundation of the 'Best So Far' pattern - we don't need to remember ALL previous values, just the one that matters!"
          },
          {
            "id": "pre7b",
            "title": "Calculate Difference from Minimum",
            "problem": "Given <code>[]int{5, 3, 8, 1, 9}</code>, for each element print the difference between it and the minimum of all PREVIOUS elements. Skip the first element (no previous elements). Output: -2, 5, -2, 8.",
            "hints": [
              {
                "title": "Step 1: Initialize",
                "content": "<pre>nums := []int{5, 3, 8, 1, 9}\nminSoFar := nums[0]  // Min of elements before current</pre>"
              },
              {
                "title": "Step 2: Loop from second element",
                "content": "<pre>for i := 1; i < len(nums); i++ {\n    diff := nums[i] - minSoFar\n    fmt.Println(diff)\n    // Update minSoFar AFTER calculating diff\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n}</pre>"
              },
              {
                "title": "Key insight",
                "content": "The order matters! Calculate the difference BEFORE updating minSoFar. This ensures we're comparing to the minimum of previous elements, not including the current one."
              }
            ],
            "solution": "nums := []int{5, 3, 8, 1, 9}\nminSoFar := nums[0]\n\nfor i := 1; i < len(nums); i++ {\n    diff := nums[i] - minSoFar\n    fmt.Println(diff)\n    \n    // Update min AFTER calculating diff\n    if nums[i] < minSoFar {\n        minSoFar = nums[i]\n    }\n}",
            "expectedOutput": "-2\n5\n-2\n8",
            "keyInsight": "This is exactly the stock problem! The difference <code>nums[i] - minSoFar</code> is the profit if you bought at the minimum price so far and sold today. The maximum of all these differences is your answer. Notice we update minSoFar AFTER calculating the diff - order matters!"
          }
        ]
      }
    }
  }
}
- id: methods_1
  concept: Methods
  difficulty: 2
  patternPrimer:
    bruteForce: Pass struct to function as first argument.
    bestApproach: Attach methods to types with receivers. Use pointer receivers to
      modify.
    typical: O(1) for method call
  variants:
  - id: v1
    title: Basic Method
    difficulty: 1
    description: |-
      Add a method <code>(p Point) IsOrigin() bool</code> that returns true if X and Y are both 0.
    functionSignature: func (p Point) IsOrigin() bool
    hints:
    - title: Think about it
      content: 'Method syntax: <code>func (receiver Type) Name() ReturnType</code>'
    - title: Hint
      content: <code>return p.X == 0 && p.Y == 0</code>
    solution: |-
      func (p Point) IsOrigin() bool {
          return p.X == 0 && p.Y == 0
      }
  - id: v2
    title: Counter Inc
    difficulty: 1
    description: |-
      Create <code>Counter</code> struct with Value int. Add <code>(c *Counter) Inc()</code> that increments it.
    functionSignature: func (c *Counter) Inc()
    hints:
    - title: Think about it
      content: To modify the struct, use a pointer receiver <code>*Counter</code>.
    - title: Hint
      content: <code>c.Value++</code>
    solution: |-
      type Counter struct {
          Value int
      }

      func (c *Counter) Inc() {
          c.Value++
      }
  - id: v3
    title: Getter Method
    difficulty: 1
    description: Add <code>(p Player) GetHP() int</code> that returns the player's
      HP.
    functionSignature: func (p Player) GetHP() int
    hints:
    - title: Hint
      content: Value receiver is fine for getters - no modification needed.
    solution: |-
      func (p Player) GetHP() int {
          return p.HP
      }
  - id: v4
    title: Point Distance
    difficulty: 2
    description: |-
      Add <code>(p Point) DistanceFromOrigin() float64</code> that returns distance from (0,0).
    functionSignature: func (p Point) DistanceFromOrigin() float64
    hints:
    - title: Think about it
      content: 'Distance formula: sqrt(x² + y²). Use <code>math.Sqrt</code>.'
    solution: |-
      func (p Point) DistanceFromOrigin() float64 {
          return math.Sqrt(float64(p.X*p.X + p.Y*p.Y))
      }
  - id: v5
    title: String Method
    difficulty: 2
    description: Add <code>String() string</code> method to Player that returns "Name
      (Lv.X)".
    functionSignature: func (p Player) String() string
    hints:
    - title: Think about it
      content: This makes Player implement fmt.Stringer - fmt.Println will use it!
    - title: Hint
      content: <code>fmt.Sprintf("%s (Lv.%d)", p.Name, p.Level)</code>
    solution: |-
      func (p Player) String() string {
          return fmt.Sprintf("%s (Lv.%d)", p.Name, p.Level)
      }
  - id: v6
    title: Heal Method
    difficulty: 2
    description: Add <code>(p *Player) Heal(amount int)</code> that adds HP, capped
      at 100.
    functionSignature: func (p *Player) Heal(amount int)
    hints:
    - title: Think about it
      content: Add the amount, then cap at max.
    solution: |-
      func (p *Player) Heal(amount int) {
          p.HP += amount
          if p.HP > 100 {
              p.HP = 100
          }
      }
  - id: v7
    title: TakeDamage Method
    difficulty: 2
    description: |-
      Add <code>(p *Player) TakeDamage(amount int) bool</code> that reduces HP and returns true if player died (HP <= 0).
    functionSignature: func (p *Player) TakeDamage(amount int) bool
    hints:
    - title: Hint
      content: Subtract damage, then check if HP <= 0.
    solution: |-
      func (p *Player) TakeDamage(amount int) bool {
          p.HP -= amount
          return p.HP <= 0
      }
  - id: v8
    title: Chain Methods
    difficulty: 3
    description: |-
      Make <code>(c *Counter) Add(n int) *Counter</code> return the counter for chaining: <code>c.Add(1).Add(2)</code>
    functionSignature: func (c *Counter) Add(n int) *Counter
    hints:
    - title: Think about it
      content: Return the receiver to enable chaining.
    - title: Hint
      content: <code>return c</code> at the end
    solution: |-
      func (c *Counter) Add(n int) *Counter {
          c.Value += n
          return c
      }
  - id: v9
    title: Move Point
    difficulty: 3
    description: |-
      Add <code>(p *Point) Move(dx, dy int) *Point</code> that shifts the point and returns it for chaining.
    functionSignature: func (p *Point) Move(dx, dy int) *Point
    hints:
    - title: Hint
      content: Add dx to X, dy to Y, return p.
    solution: |-
      func (p *Point) Move(dx, dy int) *Point {
          p.X += dx
          p.Y += dy
          return p
      }
  - id: v10
    title: Method on Alias
    difficulty: 3
    description: |-
      Create type <code>Celsius float64</code> and add method <code>(c Celsius) ToFahrenheit() float64</code>.
    functionSignature: func (c Celsius) ToFahrenheit() float64
    hints:
    - title: Think about it
      content: You can add methods to any named type, even type aliases.
    - title: Hint
      content: F = C × 9/5 + 32
    solution: |-
      type Celsius float64

      func (c Celsius) ToFahrenheit() float64 {
          return float64(c)*9/5 + 32
      }
  - id: v11
    title: Value vs Pointer Receiver
    difficulty: 2
    description: |-
      When should you use <code>(p Player)</code> vs <code>(p *Player)</code> as receiver?
    hints:
    - title: Think about it
      content: |-
        Pointer: to modify, for large structs, for consistency. Value: small immutable data.
    solution: |-
      // Use POINTER receiver when:
      // 1. Method needs to modify the struct
      func (p *Player) TakeDamage(d int) { p.HP -= d }

      // 2. Struct is large (avoid copying)
      // 3. Consistency - if one method needs pointer, use for all

      // Use VALUE receiver when:
      // 1. Read-only, small struct
      func (p Point) Distance() float64 { ... }
  - id: v12
    title: Method Set Rules
    difficulty: 3
    description: |-
      Given <code>func (p *Player) Heal()</code>, can you call <code>player.Heal()</code> where player is not a pointer?
    hints:
    - title: Think about it
      content: |-
        Go auto-converts <code>player.Heal()</code> to <code>(&player).Heal()</code> for you!
    solution: |-
      func (p *Player) Heal() { p.HP = 100 }

      player := Player{HP: 50}
      player.Heal()  // Works! Go does (&player).Heal()

      // But in interfaces, method sets matter:
      // *Player has ALL methods
      // Player only has value receiver methods
  - id: v13
    title: Method Expression
    difficulty: 3
    description: |-
      Get the <code>Heal</code> method as a function value and call it. Use method expression syntax.
    hints:
    - title: Think about it
      content: |-
        <code>(*Player).Heal</code> gives you a function that takes *Player as first arg.
    solution: |-
      func (p *Player) Heal() { p.HP = 100 }

      // Method expression - receiver becomes first param
      healFunc := (*Player).Heal

      player := &Player{HP: 50}
      healFunc(player)  // Same as player.Heal()
  - id: v14
    title: Method Value
    difficulty: 3
    description: Bind a method to a specific instance and pass it as a callback.
    hints:
    - title: Think about it
      content: <code>player.Heal</code> (without parens) is a function bound to that
        player.
    solution: |-
      player := &Player{Name: "Joker", HP: 50}

      // Method value - bound to specific instance
      callback := player.Heal

      // Later...
      callback()  // Heals THIS player
      fmt.Println(player.HP)  // 100
  - id: v15
    title: Methods on Primitives
    difficulty: 2
    description: |-
      Create <code>type ID int</code> with method <code>(id ID) String() string</code> that formats as "ID-0001".
    functionSignature: func (id ID) String() string
    hints:
    - title: Hint
      content: <code>fmt.Sprintf("ID-%04d", id)</code>
    solution: |-
      type ID int

      func (id ID) String() string {
          return fmt.Sprintf("ID-%04d", id)
      }

      playerID := ID(42)
      fmt.Println(playerID)  // ID-0042
  - id: v16
    title: Builder Pattern
    difficulty: 3
    description: |-
      Create a Builder for Player that chains: <code>NewPlayerBuilder().Name("x").HP(100).Build()</code>
    hints:
    - title: Think about it
      content: Each method returns the builder pointer for chaining.
    solution: |-
      type PlayerBuilder struct {
          player Player
      }

      func NewPlayerBuilder() *PlayerBuilder {
          return &PlayerBuilder{}
      }

      func (b *PlayerBuilder) Name(n string) *PlayerBuilder {
          b.player.Name = n
          return b
      }

      func (b *PlayerBuilder) HP(hp int) *PlayerBuilder {
          b.player.HP = hp
          return b
      }

      func (b *PlayerBuilder) Build() Player {
          return b.player
      }
  - id: v17
    title: Nil Receiver
    difficulty: 3
    description: |-
      Write a method that works even when called on nil: <code>func (p *Player) SafeName() string</code>
    functionSignature: func (p *Player) SafeName() string
    hints:
    - title: Think about it
      content: Methods can be called on nil pointers! Just check nil first.
    solution: |-
      func (p *Player) SafeName() string {
          if p == nil {
              return "<nil>"
          }
          return p.Name
      }

      var player *Player  // nil
      fmt.Println(player.SafeName())  // <nil> - no panic!
  - id: v18
    title: Receiver Copy Trap
    difficulty: 2
    description: |-
      Bug hunt: Why doesn't this work? <code>func (p Player) SetName(n string) { p.Name = n }</code>
    hints:
    - title: Think about it
      content: Value receiver gets a COPY. Changes don't affect the original.
    solution: |-
      // BROKEN - value receiver copies
      func (p Player) SetName(n string) {
          p.Name = n  // Modifies the copy only!
      }

      // FIXED - pointer receiver
      func (p *Player) SetName(n string) {
          p.Name = n  // Modifies the original
      }
  - id: v19
    title: Slice Type Method
    difficulty: 2
    description: |-
      Create <code>type Party []Player</code> with method <code>(p Party) TotalHP() int</code>.
    functionSignature: func (p Party) TotalHP() int
    hints:
    - title: Think about it
      content: You can add methods to any named type, including slice types!
    solution: |-
      type Party []Player

      func (p Party) TotalHP() int {
          total := 0
          for _, player := range p {
              total += player.HP
          }
          return total
      }

      party := Party{{HP: 100}, {HP: 80}}
      fmt.Println(party.TotalHP())  // 180
  - id: v20
    title: Method Promotes Through Embed
    difficulty: 3
    description: |-
      If <code>Engine</code> has <code>Start()</code> method and <code>Car</code> embeds Engine, what's <code>car.Start()</code> equivalent to?
    hints:
    - title: Think about it
      content: |-
        Embedding promotes methods. <code>car.Start()</code> calls <code>car.Engine.Start()</code>
    solution: |-
      type Engine struct{}
      func (e Engine) Start() { fmt.Println("Vroom!") }

      type Car struct {
          Engine  // Embedded
          Model string
      }

      car := Car{Model: "GTR"}
      car.Start()         // Calls car.Engine.Start()
      car.Engine.Start()  // Same thing, explicit

- id: challenge_1
  block: 1
  difficulty: 1
  concept: Accumulator Pattern
  docLinks:
  - url: https://go.dev/ref/spec#For_statements
    title: 'Go Spec: For statements'
    note: range loops
  - url: https://go.dev/ref/spec#Arithmetic_operators
    title: 'Go Spec: Arithmetic operators'
    note: += syntax
  patternPrimer:
    bruteForce: Loop and update a running result (sum/product/string).
    bestApproach: |-
      Initialize the identity value once, then update per element; sometimes early-return is possible.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Sum of Slice
    description: |-
      Write <code>func sum(numbers []int) int</code> that returns the sum of all numbers.
    functionSignature: func sum(numbers []int) int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '15'
    hints:
    - title: Think about it
      content: |-
        As you process each element, you need to build up a result. What variable do you need to track this running total?
    - title: Hint
      content: |-
        Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator.
    - title: Pattern
      content: |-
        <pre>1. Start with initial value (0 for sums, "" for strings)
        2. For each element:
           - Combine element with accumulator
        3. Return accumulator</pre>
    solution: |-
      func sum(numbers []int) int {
          total := 0
          for _, num := range numbers {
              total += num
          }
          return total
      }
    difficulty: 1
  - id: v2
    title: Join Words
    description: |-
      Write <code>func joinWords(words []string) string</code> that joins all words with spaces.
    functionSignature: func joinWords(words []string) string
    testCases:
    - input: '[]string{"go", "is", "fun"}'
      output: '"go is fun"'
    hints:
    - title: Think about it
      content: |-
        As you process each element, you need to build up a result. What variable do you need to track this running total?
    - title: Hint
      content: |-
        Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator.
    - title: Pattern
      content: |-
        <pre>1. Start with initial value (0 for sums, "" for strings)
        2. For each element:
           - Combine element with accumulator
        3. Return accumulator</pre>
    solution: |-
      func joinWords(words []string) string {
          result := ""
          for i, word := range words {
              if i > 0 {
                  result += " "
              }
              result += word
          }
          return result
      }
    difficulty: 2
  - id: v3
    title: Total String Length
    description: |-
      Write <code>func totalLength(words []string) int</code> that returns total length of all strings.
    functionSignature: func totalLength(words []string) int
    testCases:
    - input: '[]string{"go", "is", "fun"}'
      output: '7'
    hints:
    - title: Think about it
      content: |-
        As you process each element, you need to build up a result. What variable do you need to track this running total?
    - title: Hint
      content: |-
        Create an accumulator variable (number for sums, string for joining). Loop through and combine each element with your accumulator.
    - title: Pattern
      content: |-
        <pre>1. Start with initial value (0 for sums, "" for strings)
        2. For each element:
           - Combine element with accumulator
        3. Return accumulator</pre>
    solution: |-
      func totalLength(words []string) int {
          total := 0
          for _, word := range words {
              total += len(word)
          }
          return total
      }
    difficulty: 1
  - id: v4
    title: Product of Slice
    description: |-
      Write <code>func product(nums []int) int</code> that returns the product of all numbers (multiply them together).
    functionSignature: func product(nums []int) int
    testCases:
    - input: '[]int{2, 3, 4}'
      output: '24'
    - input: '[]int{5, 2, 1}'
      output: '10'
    hints:
    - title: Think about it
      content: 'Like sum, but multiply. What should your starting value be? (Hint:
        not 0!)'
    - title: Hint
      content: |-
        Start with result := 1 (identity for multiplication). Multiply each element into the accumulator.
    - title: Pattern
      content: |-
        <pre>1. Start with result := 1
        2. For each element:
           - result *= element
        3. Return result</pre>
    solution: |-
      func product(nums []int) int {
          result := 1
          for _, n := range nums {
              result *= n
          }
          return result
      }
    difficulty: 2
  - id: v5
    title: Running Balance
    description: |-
      Write <code>func balance(transactions []int) int</code> where positive numbers are deposits, negative are withdrawals. Return final balance.
    functionSignature: func balance(transactions []int) int
    testCases:
    - input: '[]int{100, -30, 50, -20}'
      output: '100'
      note: 100 - 30 + 50 - 20 = 100
    - input: '[]int{-10, 20, -5}'
      output: '5'
    hints:
    - title: Think about it
      content: This is just a sum! Positive and negative numbers handle themselves.
    - title: Hint
      content: |-
        Start with balance := 0. Add each transaction (negatives will subtract automatically).
    - title: Pattern
      content: |-
        <pre>1. Start with balance := 0
        2. For each transaction:
           - balance += transaction
        3. Return balance</pre>
    solution: |-
      func balance(transactions []int) int {
          bal := 0
          for _, t := range transactions {
              bal += t
          }
          return bal
      }
    difficulty: 1
  - id: v6
    title: Concat All
    description: |-
      Write <code>func concatAll(words []string) string</code> that concatenates all strings with no separator.
    functionSignature: func concatAll(words []string) string
    testCases:
    - input: '[]string{"a", "b", "c"}'
      output: '"abc"'
    - input: '[]string{"Go", "Lang"}'
      output: '"GoLang"'
    hints:
    - title: Think about it
      content: Build up a string by adding each word to the end.
    - title: Hint
      content: Start with result := "". For each word, result += word.
    - title: Pattern
      content: |-
        <pre>1. Start with result := ""
        2. For each word:
           - result += word
        3. Return result</pre>
    solution: |-
      func concatAll(words []string) string {
          result := ""
          for _, w := range words {
              result += w
          }
          return result
      }
    difficulty: 1
  - id: v7
    title: Sum of Squares
    difficulty: 2
    description: |-
      Write <code>func sumOfSquares(nums []int) int</code> that returns the sum of the squares of all numbers. For example, [1, 2, 3] → 1² + 2² + 3² = 14.
    functionSignature: func sumOfSquares(nums []int) int
    testCases:
    - input: '[]int{1, 2, 3}'
      output: '14'
      note: 1² + 2² + 3² = 1 + 4 + 9 = 14
    - input: '[]int{2, 4}'
      output: '20'
      note: 2² + 4² = 4 + 16 = 20
    hints:
    - title: Think about it
      content: |-
        This is accumulator pattern, but you need to transform each element before adding it. How do you square a number in Go?
    - title: Hint
      content: |-
        Start with sum := 0. For each number, calculate its square (n * n) and add that to the sum.
    - title: Pattern
      content: |-
        <pre>1. sum := 0
        2. For each num:
           - square := num * num
           - sum += square
        3. Return sum</pre>
    solution: |-
      func sumOfSquares(nums []int) int {
          sum := 0
          for _, n := range nums {
              sum += n * n
          }
          return sum
      }
  - id: v8
    title: Weighted Sum
    difficulty: 3
    description: "Write <code>func weightedSum(values []int, weights []int) int</code>\
      \ that returns the sum of values[i] Ã\x97 weights[i]. Assume both slices have\
      \ the same length."
    functionSignature: func weightedSum(values []int, weights []int) int
    testCases:
    - input: '[]int{10, 20, 30}, []int{1, 2, 3}'
      output: '140'
      note: "10Ã\x971 + 20Ã\x972 + 30Ã\x973 = 10 + 40 + 90 = 140"
    - input: '[]int{5, 5, 5}, []int{1, 2, 3}'
      output: '30'
      note: "5Ã\x971 + 5Ã\x972 + 5Ã\x973 = 5 + 10 + 15 = 30"
    hints:
    - title: Think about it
      content: |-
        You're working with TWO slices, but they have the same length. How do you access corresponding elements from both?
    - title: Hint
      content: |-
        You can use range with index: for i := range values. Then access values[i] and weights[i] to multiply them together.
    - title: Pattern
      content: |-
        <pre>1. sum := 0
        2. For i from 0 to len(values):
           - sum += values[i] * weights[i]
        3. Return sum</pre>
    solution: |-
      func weightedSum(values []int, weights []int) int {
          sum := 0
          for i := range values {
              sum += values[i] * weights[i]
          }
          return sum
      }
  - id: v9
    title: Alternating Sum
    difficulty: 2
    description: |-
      Write <code>func alternatingSum(nums []int) int</code> that returns nums[0] - nums[1] + nums[2] - nums[3] + ... (alternate adding and subtracting).
    functionSignature: func alternatingSum(nums []int) int
    testCases:
    - input: '[]int{10, 5, 3, 2}'
      output: '6'
      note: 10 - 5 + 3 - 2 = 6
    - input: '[]int{1, 2, 3}'
      output: '2'
      note: 1 - 2 + 3 = 2
    hints:
    - title: Think about it
      content: |-
        The operation alternates based on position. How can you tell if an index is even or odd?
    - title: Hint
      content: |-
        Use the index! Even indices (0, 2, 4...) are added, odd indices (1, 3, 5...) are subtracted. Check i % 2 == 0.
    - title: Pattern
      content: |-
        <pre>1. sum := 0
        2. For i, num in enumerate:
           - If i is even: sum += num
           - If i is odd: sum -= num
        3. Return sum</pre>
    solution: |-
      func alternatingSum(nums []int) int {
          sum := 0
          for i, n := range nums {
              if i%2 == 0 {
                  sum += n
              } else {
                  sum -= n
              }
          }
          return sum
      }
  - id: v10
    title: Total Revenue
    description: |-
      Write <code>func totalRevenue(sales []float64, taxRate float64) float64</code> that sums all sales including tax.
    functionSignature: func totalRevenue(sales []float64, taxRate float64) float64
    testCases:
    - input: '[]float64{100.0, 200.0, 50.0}, 0.08'
      output: '378.0'
      note: 350 * 1.08
    - input: '[]float64{25.0, 75.0}, 0.10'
      output: '110.0'
    hints:
    - title: Think about it
      content: 'First sum all sales, then add tax to the total: total * (1 + taxRate).'
    - title: Hint
      content: Accumulate sum, then multiply by (1 + taxRate) at the end.
    - title: Pattern
      content: |-
        <pre>1. sum := 0.0
        2. For each sale:
           - sum += sale
        3. Return sum * (1 + taxRate)</pre>
    solution: |-
      func totalRevenue(sales []float64, taxRate float64) float64 {
          sum := 0.0
          for _, sale := range sales {
              sum += sale
          }
          return sum * (1 + taxRate)
      }
    difficulty: 2
  - id: v11
    title: Dice Total
    description: |-
      Write <code>func diceTotal(rolls []int) int</code> that sums dice rolls and returns -1 if any roll is invalid (not 1-6).
    functionSignature: func diceTotal(rolls []int) int
    testCases:
    - input: '[]int{6, 3, 4, 2}'
      output: '15'
    - input: '[]int{6, 7, 4}'
      output: '-1'
      note: 7 is invalid
    hints:
    - title: Think about it
      content: |-
        Check validity while accumulating. If any roll is outside 1-6, return -1 immediately.
    - title: Hint
      content: As you sum, check each roll. Use early return for invalid rolls.
    - title: Pattern
      content: |-
        <pre>1. sum := 0
        2. For each roll:
           - roll < 1 OR roll > 6? → return -1
           - sum += roll
        3. Return sum</pre>
    solution: |-
      func diceTotal(rolls []int) int {
          sum := 0
          for _, roll := range rolls {
              if roll < 1 || roll > 6 { return -1 }
              sum += roll
          }
          return sum
      }
    difficulty: 2
  - id: v12
    title: Compound Interest
    description: |-
      Write <code>func compoundInterest(deposits []float64, rate float64) float64</code> that calculates compound interest where each deposit earns interest at rate (as decimal) per period. Process deposits in order, adding interest to running balance before adding next deposit.
    functionSignature: func compoundInterest(deposits []float64, rate float64) float64
    testCases:
    - input: '[]float64{100.0, 100.0}, 0.10'
      output: '221.0'
      note: 'Period 1: 100. Period 2: 100*1.1 + 100 = 210. Final: 210*1.1 = 231 (approx)'
    - input: '[]float64{1000.0}, 0.05'
      output: '1050.0'
    hints:
    - title: Think about it
      content: |-
        Each period, you apply interest to the current balance, then add the new deposit.
    - title: Hint
      content: |-
        Keep a running balance. For each deposit: balance = balance * (1 + rate), then balance += deposit.
    - title: Pattern
      content: |-
        <pre>1. balance := 0.0
        2. For each deposit:
           - balance *= (1 + rate)
           - balance += deposit
        3. Return balance</pre>
    solution: |-
      func compoundInterest(deposits []float64, rate float64) float64 {
          balance := 0.0
          for _, deposit := range deposits {
              balance = balance * (1 + rate)
              balance += deposit
          }
          return balance
      }
    difficulty: 3
  - id: v13
    title: Running Max Product
    description: |-
      Write <code>func runningMaxProduct(nums []int) []int</code> that returns a slice where each element is the maximum product of any two consecutive elements seen so far (including current position).
    functionSignature: func runningMaxProduct(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: '[]int{0, 2, 6, 12}'
      note: |-
        Position 0: no pair (0), Pos 1: max(1*2)=2, Pos 2: max(1*2, 2*3)=6, Pos 3: max(1*2, 2*3, 3*4)=12
    - input: '[]int{5, 1, 3, 2}'
      output: '[]int{0, 5, 5, 6}'
    hints:
    - title: Think about it
      content: |-
        At each position, you need to track the maximum product of consecutive pairs seen up to that point.
    - title: Hint
      content: |-
        Keep track of maxProduct as you go. At position i, calculate nums[i-1]*nums[i] and update maxProduct if it's larger.
    - title: Pattern
      content: |-
        <pre>1. result := []int{0}, maxProduct := 0
        2. For i from 1 to len:
           - product := nums[i-1] * nums[i]
           - if product > maxProduct: maxProduct = product
           - append maxProduct to result
        3. Return result</pre>
    solution: |-
      func runningMaxProduct(nums []int) []int {
          result := []int{0}
          maxProduct := 0
          for i := 1; i < len(nums); i++ {
              product := nums[i-1] * nums[i]
              if product > maxProduct {
                  maxProduct = product
              }
              result = append(result, maxProduct)
          }
          return result
      }
    difficulty: 3
- id: challenge_2
  block: 1
  difficulty: 1
  concept: Conditional Counter
  docLinks:
  - url: https://go.dev/ref/spec#If_statements
    title: 'Go Spec: If statements'
    note: conditionals
  - url: https://go.dev/ref/spec#Arithmetic_operators
    title: 'Go Spec: Arithmetic operators'
    note: '% modulo operator'
  patternPrimer:
    bruteForce: Loop through, check condition for each element, increment counter.
    bestApproach: Same approach - this is already optimal! Just loop once and count
      matches.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Count Evens
    description: Write <code>func countEvens(nums []int) int</code> that counts even
      numbers.
    functionSignature: func countEvens(nums []int) int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6}'
      output: '3'
    hints:
    - title: Think about it
      content: |-
        You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?
    - title: Hint
      content: |-
        Start a counter at 0. For each element, check your condition - if true, increment the counter.
    - title: Pattern
      content: |-
        <pre>1. Start counter at 0
        2. For each element:
           - Meets condition? → increment counter
        3. Return counter</pre>
    solution: |-
      func countEvens(nums []int) int {
          count := 0
          for _, num := range nums {
              if num%2 == 0 {
                  count++
              }
          }
          return count
      }
    difficulty: 1
  - id: v2
    title: Count Negatives
    description: |-
      Write <code>func countNegatives(nums []int) int</code> that counts negative numbers.
    functionSignature: func countNegatives(nums []int) int
    testCases:
    - input: '[]int{-1, 2, -3, 4}'
      output: '2'
    hints:
    - title: Think about it
      content: |-
        You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?
    - title: Hint
      content: |-
        Start a counter at 0. For each element, check your condition - if true, increment the counter.
    - title: Pattern
      content: |-
        <pre>1. Start counter at 0
        2. For each element:
           - Meets condition? → increment counter
        3. Return counter</pre>
    solution: |-
      func countNegatives(nums []int) int {
          count := 0
          for _, num := range nums {
              if num < 0 {
                  count++
              }
          }
          return count
      }
    difficulty: 1
  - id: v3
    title: Count Passing Scores
    description: |-
      Write <code>func countPassing(scores []int, threshold int) int</code> that counts scores >= threshold.
    functionSignature: func countPassing(scores []int, threshold int) int
    testCases:
    - input: '[]int{55, 72, 68, 90, 45}, 60'
      output: '3'
    hints:
    - title: Think about it
      content: |-
        You need to count things that meet a condition. What two pieces do you need: one to track the count, and one to check each element?
    - title: Hint
      content: |-
        Start a counter at 0. For each element, check your condition - if true, increment the counter.
    - title: Pattern
      content: |-
        <pre>1. Start counter at 0
        2. For each element:
           - Meets condition? → increment counter
        3. Return counter</pre>
    solution: |-
      func countPassing(scores []int, threshold int) int {
          count := 0
          for _, score := range scores {
              if score >= threshold {
                  count++
              }
          }
          return count
      }
    difficulty: 1
  - id: v4
    title: Count Divisible By
    description: |-
      Write <code>func countDivisible(nums []int, d int) int</code> that counts numbers divisible by d.
    functionSignature: func countDivisible(nums []int, d int) int
    testCases:
    - input: '[]int{3, 6, 7, 9, 12}, 3'
      output: '4'
      note: 3, 6, 9, 12 are divisible by 3
    - input: '[]int{1, 2, 3, 4, 5}, 2'
      output: '2'
    hints:
    - title: Think about it
      content: |-
        How do you check if a number is divisible by another? What operation gives you the remainder?
    - title: Hint
      content: 'Use the modulo operator: num % d == 0 means num is divisible by d.'
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each num:
           - num % d == 0? → count++
        3. Return count</pre>
    solution: |-
      func countDivisible(nums []int, d int) int {
          count := 0
          for _, n := range nums {
              if n % d == 0 { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v5
    title: Count Long Words
    description: |-
      Write <code>func countLongWords(words []string, minLen int) int</code> that counts words with length >= minLen.
    functionSignature: func countLongWords(words []string, minLen int) int
    testCases:
    - input: '[]string{"go", "python", "rust", "c"}, 4'
      output: '2'
      note: python and rust have len >= 4
    - input: '[]string{"a", "ab", "abc"}, 2'
      output: '2'
    hints:
    - title: Think about it
      content: Same counting pattern, just checking string length instead of numeric
        value.
    - title: Hint
      content: Use len(word) >= minLen as your condition.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - len(word) >= minLen? → count++
        3. Return count</pre>
    solution: |-
      func countLongWords(words []string, minLen int) int {
          count := 0
          for _, w := range words {
              if len(w) >= minLen { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v6
    title: Count In Range
    description: |-
      Write <code>func countInRange(nums []int, min, max int) int</code> that counts numbers where min <= num <= max.
    functionSignature: func countInRange(nums []int, min, max int) int
    testCases:
    - input: '[]int{1, 5, 10, 15, 20}, 5, 15'
      output: '3'
      note: 5, 10, 15 are in range
    - input: '[]int{1, 2, 3, 4, 5}, 2, 4'
      output: '3'
    hints:
    - title: Think about it
      content: 'You need to check TWO conditions: num >= min AND num <= max.'
    - title: Hint
      content: 'Combine conditions with &&: if num >= min && num <= max.'
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each num:
           - num >= min && num <= max? → count++
        3. Return count</pre>
    solution: |-
      func countInRange(nums []int, min, max int) int {
          count := 0
          for _, n := range nums {
              if n >= min && n <= max { count++ }
          }
          return count
      }
    difficulty: 2
  - id: v7
    title: Count Prime Numbers
    difficulty: 3
    description: |-
      Write <code>func countPrimes(nums []int) int</code> that counts how many prime numbers are in the slice. A prime number is greater than 1 and only divisible by 1 and itself.
    functionSignature: func countPrimes(nums []int) int
    testCases:
    - input: '[]int{2, 3, 4, 5, 6, 7}'
      output: '4'
      note: 2, 3, 5, 7 are prime
    - input: '[]int{1, 4, 6, 8, 9}'
      output: '0'
      note: No primes
    hints:
    - title: Think about it
      content: |-
        Checking if a number is prime requires nested logic. For each number, you need to check if any number from 2 to n-1 divides it evenly.
    - title: Hint
      content: |-
        Create a helper function isPrime(n int) bool. A number is prime if it's > 1 and no number from 2 to sqrt(n) divides it evenly. Then count how many numbers pass the isPrime test.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each num:
           - If isPrime(num): count++
        3. Return count

        isPrime(n):
          - If n <= 1: return false
          - For i from 2 to sqrt(n):
            - If n % i == 0: return false
          - return true</pre>
    solution: |-
      func countPrimes(nums []int) int {
          count := 0
          for _, n := range nums {
              if isPrime(n) {
                  count++
              }
          }
          return count
      }

      func isPrime(n int) bool {
          if n <= 1 {
              return false
          }
          for i := 2; i*i <= n; i++ {
              if n%i == 0 {
                  return false
              }
          }
          return true
      }
  - id: v8
    title: Count Words Starting With Vowel
    difficulty: 2
    description: |-
      Write <code>func countVowelStart(words []string) int</code> that counts how many words start with a vowel (a, e, i, o, u). Use lowercase comparison.
    functionSignature: func countVowelStart(words []string) int
    testCases:
    - input: '[]string{"apple", "banana", "orange", "grape"}'
      output: '2'
      note: apple and orange start with vowels
    - input: '[]string{"Go", "is", "awesome"}'
      output: '2'
      note: is and awesome start with vowels
    hints:
    - title: Think about it
      content: |-
        You need to check the first character of each word. How do you get the first character, and how do you check if it's in the set {a, e, i, o, u}?
    - title: Hint
      content: |-
        Use strings.ToLower() to convert to lowercase, then check if word[0] is one of the vowel bytes. You can use multiple OR conditions, or create a helper function.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - Get first character (lowercase)
           - If it's a, e, i, o, or u: count++
        3. Return count</pre>
    solution: |-
      func countVowelStart(words []string) int {
          count := 0
          for _, word := range words {
              if len(word) > 0 {
                  first := strings.ToLower(string(word[0]))
                  if first == "a" || first == "e" || first == "i" || first == "o" || first == "u" {
                      count++
                  }
              }
          }
          return count
      }
  - id: v9
    title: Three Letter Words
    description: |-
      Write <code>func threeLetterWords(words []string) int</code> that counts words with exactly 3 letters.
    functionSignature: func threeLetterWords(words []string) int
    testCases:
    - input: '[]string{"cat", "dog", "elephant", "bat"}'
      output: '3'
    - input: '[]string{"hello", "world"}'
      output: '0'
    hints:
    - title: Think about it
      content: Count words where len(word) == 3.
    - title: Hint
      content: 'Simple counter with condition: if len(word) == 3, count++'
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - len(word) == 3? → count++
        3. Return count</pre>
    solution: |-
      func threeLetterWords(words []string) int {
          count := 0
          for _, word := range words {
              if len(word) == 3 { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v10
    title: Temperature Extremes
    description: |-
      Write <code>func tempExtremes(temps []int) int</code> that counts how many temps are below 0 or above 100.
    functionSignature: func tempExtremes(temps []int) int
    testCases:
    - input: '[]int{-5, 50, 105, 25, -10}'
      output: '3'
    - input: '[]int{20, 30, 40}'
      output: '0'
    hints:
    - title: Think about it
      content: Count temperatures that are < 0 OR > 100.
    - title: Hint
      content: if temp < 0 || temp > 100, increment count.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each temp:
           - temp < 0 OR temp > 100? → count++
        3. Return count</pre>
    solution: |-
      func tempExtremes(temps []int) int {
          count := 0
          for _, temp := range temps {
              if temp < 0 || temp > 100 { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v11
    title: Count By Multiple Criteria
    description: |-
      Write <code>func countByCriteria(words []string, minLen, maxLen int, mustContain string) int</code> that counts words where length is between minLen and maxLen (inclusive) AND the word contains the substring mustContain.
    functionSignature: func countByCriteria(words []string, minLen, maxLen int, mustContain
      string) int
    testCases:
    - input: '["hello", "world", "hi", "help"], 4, 6, "el"'
      output: '2'
      note: hello and help both have length 4-5 and contain 'el'
    - input: '["go", "gopher", "golang", "rust"], 2, 6, "go"'
      output: '3'
      note: go, gopher, golang all contain 'go' and fit length constraint
    hints:
    - title: Think about it
      content: |-
        You need to check THREE conditions for each word: minimum length, maximum length, and contains substring. Use strings.Contains() to check for substring.
    - title: Hint
      content: |-
        Import strings package. For each word, check: len(word) >= minLen AND len(word) <= maxLen AND strings.Contains(word, mustContain). Only count if all three are true.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - length in range? AND
           - contains substring?
           - Both true? → count++
        3. Return count</pre>
    solution: |-
      import "strings"

      func countByCriteria(words []string, minLen, maxLen int, mustContain string) int {
          count := 0
          for _, word := range words {
              if len(word) >= minLen && len(word) <= maxLen && strings.Contains(word, mustContain) {
                  count++
              }
          }
          return count
      }
    difficulty: 3
  - id: v12
    title: Count Valid Pairs
    description: |-
      Write <code>func countValidPairs(nums []int, targetSum int) int</code> that counts how many pairs of adjacent elements sum to targetSum.
    functionSignature: func countValidPairs(nums []int, targetSum int) int
    testCases:
    - input: '[]int{1, 4, 3, 2, 5}, 5'
      output: '2'
      note: pairs (1,4) and (3,2) both sum to 5
    - input: '[]int{2, 3, 2, 3}, 5'
      output: '3'
      note: all three adjacent pairs (2,3), (3,2), (2,3) sum to 5
    hints:
    - title: Think about it
      content: |-
        You need to look at each pair of consecutive elements. For position i, check if nums[i] + nums[i+1] equals targetSum.
    - title: Hint
      content: |-
        Loop from i=0 to len(nums)-2 (so i+1 is valid). For each i, check if nums[i] + nums[i+1] == targetSum.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For i from 0 to len-2:
           - nums[i] + nums[i+1] == target?
           - Yes → count++
        3. Return count</pre>
    solution: |-
      func countValidPairs(nums []int, targetSum int) int {
          count := 0
          for i := 0; i < len(nums)-1; i++ {
              if nums[i] + nums[i+1] == targetSum {
                  count++
              }
          }
          return count
      }
    difficulty: 3
  - id: v13
    title: Count Pattern Match
    description: |-
      Write <code>func countPatternMatch(words []string, prefix, suffix string) int</code> that counts words that start with prefix AND end with suffix.
    functionSignature: func countPatternMatch(words []string, prefix, suffix string)
      int
    testCases:
    - input: '["hello", "hero", "hermit", "world"], "he", "o"'
      output: '2'
      note: hello and hero both start with 'he' and end with 'o'
    - input: '["testing", "resting", "test", "ing"], "test", "ing"'
      output: '1'
      note: only 'testing' starts with 'test' and ends with 'ing'
    hints:
    - title: Think about it
      content: |-
        Use strings.HasPrefix() and strings.HasSuffix() to check both ends of each word. Count only if both conditions are true.
    - title: Hint
      content: |-
        Import strings package. For each word: if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix), increment count.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - starts with prefix? AND
           - ends with suffix?
           - Both true? → count++
        3. Return count</pre>
    solution: |-
      import "strings"

      func countPatternMatch(words []string, prefix, suffix string) int {
          count := 0
          for _, word := range words {
              if strings.HasPrefix(word, prefix) && strings.HasSuffix(word, suffix) {
                  count++
              }
          }
          return count
      }
    difficulty: 3
  - id: v14
    title: Count Words Starting With Letter
    description: |-
      Write <code>func countStartsWith(words []string, letter rune) int</code> that counts words starting with the given letter (case-insensitive).
    functionSignature: func countStartsWith(words []string, letter rune) int
    testCases:
    - input: '["Hello", "world", "Hi"], ''h'''
      output: '2'
      note: Hello and Hi start with h (case-insensitive)
    - input: '["Go", "Python", "Rust", "Go"], ''g'''
      output: '2'
    hints:
    - title: Think about it
      content: |-
        Check the first character of each word. Convert both to lowercase for case-insensitive comparison.
    - title: Hint
      content: |-
        Use strings.ToLower() on the first character. Get first rune with rune(word[0]) if word is non-empty.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each word:
           - Get first letter (lowercase)
           - Matches target letter? → count++
        3. Return count</pre>
    solution: "import \"strings\"\n\nfunc countStartsWith(words []string, letter rune)\
      \ int {\n    count := 0\n    targetLower := strings.ToLower(string(letter))\n\
      \    \n    for _, word := range words {\n        if len(word) > 0 {\n      \
      \      firstLetter := strings.ToLower(string(word[0]))\n            if firstLetter\
      \ == targetLower {\n                count++\n            }\n        }\n    }\n\
      \    \n    return count\n}"
    difficulty: 2
  - id: v15
    title: Count Between (Exclusive)
    description: |-
      Write <code>func countBetween(nums []int, low, high int) int</code> that counts numbers strictly between low and high (exclusive on both ends: low < num < high).
    functionSignature: func countBetween(nums []int, low, high int) int
    testCases:
    - input: '[]int{1, 5, 10, 15, 20}, 5, 15'
      output: '1'
      note: only 10 is strictly between 5 and 15
    - input: '[]int{1, 2, 3, 4, 5}, 1, 5'
      output: '3'
      note: 2, 3, 4 are between 1 and 5 (exclusive)
    hints:
    - title: Think about it
      content: |-
        Exclusive means not including the boundaries. Check num > low AND num < high (not >= or <=).
    - title: Hint
      content: 'Use strict inequality: if num > low && num < high, count it.'
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each num:
           - num > low AND num < high? → count++
        3. Return count</pre>
    solution: |-
      func countBetween(nums []int, low, high int) int {
          count := 0
          for _, num := range nums {
              if num > low && num < high {
                  count++
              }
          }
          return count
      }
    difficulty: 2
- id: challenge_3
  block: 1
  difficulty: 1
  concept: Branching Logic
  docLinks:
  - url: https://go.dev/ref/spec#If_statements
    title: 'Go Spec: If statements'
    note: else-if chains
  - url: https://go.dev/ref/spec#Comparison_operators
    title: 'Go Spec: Comparison operators'
    note: '>=, <, == etc.'
  variants:
  - id: v1
    title: FizzBuzz
    description: 'Print 1-20. Multiples of 3: "Fizz", 5: "Buzz", both: "FizzBuzz".'
    functionSignature: // loop
    testCases:
    - input: '15'
      output: FizzBuzz
    hints:
    - title: Think about it
      content: |-
        When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?
    - title: Hint
      content: |-
        Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually.
    - title: Pattern
      content: |-
        <pre>1. Check most specific condition first
        2. Then check less specific conditions
        3. Default case last
        (Order matters: check "both 3 AND 5" before "just 3" or "just 5")</pre>
    solution: |-
      for i := 1; i <= 20; i++ {
          if i%15 == 0 {
              fmt.Println("FizzBuzz")
          } else if i%3 == 0 {
              fmt.Println("Fizz")
          } else if i%5 == 0 {
              fmt.Println("Buzz")
          } else {
              fmt.Println(i)
          }
      }
    difficulty: 2
  - id: v2
    title: Grade Classifier
    description: Write <code>func grade(score int) string</code> returning A/B/C/D/F.
    functionSignature: func grade(score int) string
    testCases:
    - input: '85'
      output: '"B"'
    hints:
    - title: Think about it
      content: |-
        When you have overlapping conditions (like a number divisible by both 3 AND 5), which case should you check first?
    - title: Hint
      content: |-
        Check the most specific condition first! For FizzBuzz, 15 is divisible by both 3 and 5, so check for 15 before checking 3 or 5 individually.
    - title: Pattern
      content: |-
        <pre>1. Check most specific condition first
        2. Then check less specific conditions
        3. Default case last
        (Order matters: check "both 3 AND 5" before "just 3" or "just 5")</pre>
    solution: |-
      func grade(score int) string {
          if score >= 90 { return "A" }
          if score >= 80 { return "B" }
          if score >= 70 { return "C" }
          if score >= 60 { return "D" }
          return "F"
      }
    difficulty: 1
  - id: v3
    title: Age Category
    description: |-
      Write <code>func ageCategory(age int) string</code> returning "infant" (0-1), "toddler" (2-3), "child" (4-12), "teen" (13-19), or "adult" (20+).
    functionSignature: func ageCategory(age int) string
    testCases:
    - input: '15'
      output: '"teen"'
    - input: '2'
      output: '"toddler"'
    hints:
    - title: Think about it
      content: |-
        When you have multiple age ranges to check, what order should you check them in to avoid incorrect matches?
    - title: Hint
      content: |-
        Check ranges in ascending order using upper bounds. If age <= 1, it's infant. If age <= 3, it's toddler. And so on.
    - title: Pattern
      content: |-
        <pre>1. Check ranges in order from youngest to oldest
        2. Use upper bounds (<=) for each category
        3. Default to "adult" for 20+</pre>
    solution: |-
      func ageCategory(age int) string {
          if age <= 1 { return "infant" }
          if age <= 3 { return "toddler" }
          if age <= 12 { return "child" }
          if age <= 19 { return "teen" }
          return "adult"
      }
    difficulty: 2
  - id: v4
    title: Number Sign
    description: |-
      Write <code>func sign(n int) string</code> returning "positive", "negative", or "zero".
    functionSignature: func sign(n int) string
    testCases:
    - input: '5'
      output: '"positive"'
    - input: '-3'
      output: '"negative"'
    - input: '0'
      output: '"zero"'
    hints:
    - title: Think about it
      content: 'Three cases: greater than 0, less than 0, or equal to 0.'
    - title: Hint
      content: Check n > 0, then n < 0, else it's zero.
    - title: Pattern
      content: |-
        <pre>if n > 0 { return "positive" }
        if n < 0 { return "negative" }
        return "zero"</pre>
    solution: |-
      func sign(n int) string {
          if n > 0 { return "positive" }
          if n < 0 { return "negative" }
          return "zero"
      }
    difficulty: 1
  - id: v5
    title: Ticket Price
    description: |-
      Write <code>func ticketPrice(age int) int</code>: children (0-12) pay 5, teens (13-17) pay 8, adults (18-64) pay 12, seniors (65+) pay 7.
    functionSignature: func ticketPrice(age int) int
    testCases:
    - input: '10'
      output: '5'
    - input: '15'
      output: '8'
    - input: '30'
      output: '12'
    - input: '70'
      output: '7'
    hints:
    - title: Think about it
      content: Multiple age ranges with different prices. Check from youngest to oldest.
    - title: Hint
      content: 'Use if-else chain checking upper bounds: <= 12, <= 17, <= 64, else
        senior.'
    - title: Pattern
      content: |-
        <pre>if age <= 12 { return 5 }
        if age <= 17 { return 8 }
        if age <= 64 { return 12 }
        return 7</pre>
    solution: |-
      func ticketPrice(age int) int {
          if age <= 12 { return 5 }
          if age <= 17 { return 8 }
          if age <= 64 { return 12 }
          return 7
      }
    difficulty: 2
  - id: v6
    title: Shipping Cost
    description: |-
      Write <code>func shippingCost(weight int) int</code>: 0-1kg costs 5, 2-5kg costs 10, 6-10kg costs 20, over 10kg costs 50.
    functionSignature: func shippingCost(weight int) int
    testCases:
    - input: '1'
      output: '5'
    - input: '3'
      output: '10'
    - input: '8'
      output: '20'
    - input: '15'
      output: '50'
    hints:
    - title: Think about it
      content: Multiple weight brackets. Check from lightest to heaviest.
    - title: Hint
      content: 'Check upper bounds: <= 1, <= 5, <= 10, else heavy.'
    - title: Pattern
      content: |-
        <pre>if weight <= 1 { return 5 }
        if weight <= 5 { return 10 }
        if weight <= 10 { return 20 }
        return 50</pre>
    solution: |-
      func shippingCost(weight int) int {
          if weight <= 1 { return 5 }
          if weight <= 5 { return 10 }
          if weight <= 10 { return 20 }
          return 50
      }
    difficulty: 2
  - id: v7
    title: Tax Bracket Calculator
    difficulty: 3
    description: |-
      Write <code>func calculateTax(income int) int</code>. Tax brackets: 0-10k: 0%, 10k-50k: 10%, 50k-100k: 20%, 100k+: 30%. Calculate progressive tax (each bracket taxed at its rate).
    functionSignature: func calculateTax(income int) int
    testCases:
    - input: '15000'
      output: '500'
      note: 'First 10k: 0, next 5k at 10% = 500'
    - input: '60000'
      output: '6000'
      note: 10k@0% + 40k@10% + 10k@20% = 0 + 4000 + 2000 = 6000
    - input: '5000'
      output: '0'
      note: All in 0% bracket
    hints:
    - title: Think about it
      content: |-
        This is NOT a simple if-else! Each bracket taxes only the portion of income in that range. Someone earning 60k pays 10% on the middle 40k, not on all 60k.
    - title: Hint
      content: |-
        Calculate tax bracket by bracket. For each bracket, determine how much income falls in it (min of remaining income and bracket size), multiply by rate, add to total tax.
    - title: Pattern
      content: |-
        <pre>1. tax := 0, remaining := income
        2. First bracket (0-10k at 0%):
           - amount = min(remaining, 10000)
           - tax += amount * 0.0
           - remaining -= amount
        3. Repeat for each bracket
        4. Return tax</pre>
    solution: |-
      func calculateTax(income int) int {
          if income <= 10000 {
              return 0
          }
          tax := 0
          if income > 10000 {
              taxable := income - 10000
              if taxable > 40000 {
                  taxable = 40000
              }
              tax += taxable * 10 / 100
          }
          if income > 50000 {
              taxable := income - 50000
              if taxable > 50000 {
                  taxable = 50000
              }
              tax += taxable * 20 / 100
          }
          if income > 100000 {
              tax += (income - 100000) * 30 / 100
          }
          return tax
      }
  - id: v8
    title: Rock Paper Scissors
    difficulty: 2
    description: |-
      Write <code>func rps(p1, p2 string) string</code> that takes "rock", "paper", or "scissors" and returns "p1", "p2", or "tie".
    functionSignature: func rps(p1, p2 string) string
    testCases:
    - input: '"rock", "scissors"'
      output: '"p1"'
      note: Rock beats scissors
    - input: '"paper", "rock"'
      output: '"p1"'
      note: Paper beats rock
    - input: '"rock", "rock"'
      output: '"tie"'
    - input: '"scissors", "paper"'
      output: '"p1"'
    hints:
    - title: Think about it
      content: "There are 9 possible combinations (3Ã\x973), but some simplify. Check\
        \ for tie first, then you have 6 win cases to check."
    - title: Hint
      content: |-
        First check if p1 == p2 (tie). Then check the three cases where p1 wins: (rock, scissors), (paper, rock), (scissors, paper). Otherwise p2 wins.
    - title: Pattern
      content: |-
        <pre>1. If p1 == p2: return "tie"
        2. If (p1==rock && p2==scissors) OR
              (p1==paper && p2==rock) OR
              (p1==scissors && p2==paper):
              return "p1"
        3. Else: return "p2"</pre>
    solution: |-
      func rps(p1, p2 string) string {
          if p1 == p2 {
              return "tie"
          }
          if (p1 == "rock" && p2 == "scissors") ||
             (p1 == "paper" && p2 == "rock") ||
             (p1 == "scissors" && p2 == "paper") {
              return "p1"
          }
          return "p2"
      }
  - id: v9
    title: Rating Categories
    description: |-
      Write <code>func ratingCategory(rating int) string</code>: "Poor" (0-2), "Fair" (3-5), "Good" (6-8), "Excellent" (9-10).
    functionSignature: func ratingCategory(rating int) string
    testCases:
    - input: '8'
      output: '"Good"'
    - input: '10'
      output: '"Excellent"'
    - input: '1'
      output: '"Poor"'
    hints:
    - title: Think about it
      content: |-
        Use if-else chain to check ranges. Order matters - check highest first or use <= appropriately.
    - title: Hint
      content: if rating <= 2 return "Poor", else if rating <= 5 return "Fair", etc.
    - title: Pattern
      content: |-
        <pre>if rating <= 2: Poor
        else if rating <= 5: Fair
        else if rating <= 8: Good
        else: Excellent</pre>
    solution: |-
      func ratingCategory(rating int) string {
          if rating <= 2 { return "Poor" }
          if rating <= 5 { return "Fair" }
          if rating <= 8 { return "Good" }
          return "Excellent"
      }
    difficulty: 2
  - id: v10
    title: Message Priority
    description: |-
      Write <code>func messagePriority(msg string) string</code>: "URGENT" if contains "ASAP", "High" if starts with "Important", else "Normal".
    functionSignature: func messagePriority(msg string) string
    testCases:
    - input: '"Please reply ASAP"'
      output: '"URGENT"'
    - input: '"Important meeting tomorrow"'
      output: '"High"'
    - input: '"Hello there"'
      output: '"Normal"'
    hints:
    - title: Think about it
      content: |-
        Check for "ASAP" first (most urgent), then check prefix, otherwise default to Normal.
    - title: Hint
      content: Use strings.Contains() for ASAP, strings.HasPrefix() for Important.
    - title: Pattern
      content: |-
        <pre>if contains "ASAP": URGENT
        else if starts with "Important": High
        else: Normal</pre>
    solution: |-
      func messagePriority(msg string) string {
          if strings.Contains(msg, "ASAP") { return "URGENT" }
          if strings.HasPrefix(msg, "Important") { return "High" }
          return "Normal"
      }
    difficulty: 2
  - id: v11
    title: BMI Category
    description: |-
      Write <code>func bmiCategory(bmi float64) string</code> returning "Underweight" (bmi < 18.5), "Normal" (18.5-24.9), "Overweight" (25-29.9), or "Obese" (30+).
    functionSignature: func bmiCategory(bmi float64) string
    testCases:
    - input: '22.5'
      output: '"Normal"'
    - input: '17.0'
      output: '"Underweight"'
    - input: '31.5'
      output: '"Obese"'
    hints:
    - title: Think about it
      content: |-
        Multiple ranges to check. What order should you check them to avoid incorrect matches?
    - title: Hint
      content: |-
        Check from lowest to highest using upper bounds: if bmi < 18.5, if bmi < 25, if bmi < 30, else.
    - title: Pattern
      content: |-
        <pre>if bmi < 18.5 { return "Underweight" }
        if bmi < 25 { return "Normal" }
        if bmi < 30 { return "Overweight" }
        return "Obese"</pre>
    solution: |-
      func bmiCategory(bmi float64) string {
          if bmi < 18.5 { return "Underweight" }
          if bmi < 25 { return "Normal" }
          if bmi < 30 { return "Overweight" }
          return "Obese"
      }
    difficulty: 1
  - id: v12
    title: Water State
    description: |-
      Write <code>func waterState(temp int) string</code> returning "ice" (temp <= 0), "water" (1-99), or "steam" (temp >= 100). Temperatures in Celsius.
    functionSignature: func waterState(temp int) string
    testCases:
    - input: '25'
      output: '"water"'
    - input: '-5'
      output: '"ice"'
    - input: '100'
      output: '"steam"'
    hints:
    - title: Think about it
      content: |-
        Three states with specific temperature boundaries. What's the cleanest order to check them?
    - title: Hint
      content: |-
        Check boundaries in order: if temp <= 0 (ice), else if temp >= 100 (steam), else (water).
    - title: Pattern
      content: |-
        <pre>if temp <= 0 { return "ice" }
        if temp >= 100 { return "steam" }
        return "water"</pre>
    solution: |-
      func waterState(temp int) string {
          if temp <= 0 { return "ice" }
          if temp >= 100 { return "steam" }
          return "water"
      }
    difficulty: 1
  - id: v13
    title: Discount Calculator
    description: |-
      Write <code>func discount(price int, isPremium bool, quantity int) int</code>. Premium members get 20% off. Non-premium get 10% off if quantity >= 5, else no discount. Return final price.
    functionSignature: func discount(price int, isPremium bool, quantity int) int
    testCases:
    - input: 100, true, 1
      output: '80'
      note: 'Premium: 20% off'
    - input: 100, false, 6
      output: '90'
      note: 'Non-premium bulk: 10% off'
    - input: 100, false, 3
      output: '100'
      note: 'Non-premium small: no discount'
    hints:
    - title: Think about it
      content: |-
        Multiple conditions that interact: membership status AND quantity. Check premium first since it's simpler.
    - title: Hint
      content: if isPremium → 20% off. else if quantity >= 5 → 10% off. else → no
        discount.
    - title: Pattern
      content: |-
        <pre>if isPremium { return price * 80 / 100 }
        if quantity >= 5 { return price * 90 / 100 }
        return price</pre>
    solution: |-
      func discount(price int, isPremium bool, quantity int) int {
          if isPremium { return price * 80 / 100 }
          if quantity >= 5 { return price * 90 / 100 }
          return price
      }
    difficulty: 1
  - id: v14
    title: Categorize Numbers
    description: |-
      Write <code>func categorizeNumbers(nums []int) map[string][]int</code> that categorizes numbers into "small" (<10), "medium" (10-99), or "large" (>=100). Returns a map where keys are categories and values are slices of numbers in that category.
    functionSignature: func categorizeNumbers(nums []int) map[string][]int
    testCases:
    - input: '[]int{5, 15, 150, 8, 25, 200}'
      output: map["small":[5, 8] "medium":[15, 25] "large":[150, 200]]
    - input: '[]int{1, 10, 100}'
      output: map["small":[1] "medium":[10] "large":[100]]
    hints:
    - title: Think about it
      content: |-
        Create a map where each category name maps to a slice of integers. For each number, determine which category it belongs to and append it to that category's slice.
    - title: Hint
      content: |-
        Initialize map with three empty slices. Use if-else to check: num < 10, num < 100, else. Append to the appropriate slice.
    - title: Pattern
      content: |-
        <pre>1. Create map[string][]int
        2. For each num:
           - num < 10? → append to "small"
           - num < 100? → append to "medium"
           - else → append to "large"
        3. Return map</pre>
    solution: "func categorizeNumbers(nums []int) map[string][]int {\n    categories\
      \ := map[string][]int{\n        \"small\": {},\n        \"medium\": {},\n  \
      \      \"large\": {},\n    }\n    \n    for _, num := range nums {\n       \
      \ if num < 10 {\n            categories[\"small\"] = append(categories[\"small\"\
      ], num)\n        } else if num < 100 {\n            categories[\"medium\"] =\
      \ append(categories[\"medium\"], num)\n        } else {\n            categories[\"\
      large\"] = append(categories[\"large\"], num)\n        }\n    }\n    \n    return\
      \ categories\n}"
    difficulty: 3
  - id: v15
    title: Score to Grade with Plus/Minus
    description: |-
      Write <code>func scoreToGradePlus(score int) string</code> that converts a score to a letter grade with +/- modifiers. A+ (97-100), A (93-96), A- (90-92), B+ (87-89), B (83-86), B- (80-82), etc. Below 60 is F.
    functionSignature: func scoreToGradePlus(score int) string
    testCases:
    - input: '98'
      output: '"A+"'
    - input: '85'
      output: '"B"'
    - input: '72'
      output: '"C-"'
    hints:
    - title: Think about it
      content: |-
        You need precise range checking for 12 different grade levels. Start from the top (100) and work down with else-if chains.
    - title: Hint
      content: |-
        Check score >= 97 for A+, >= 93 for A, >= 90 for A-, >= 87 for B+, and so on. Each check needs exact boundaries.
    - title: Pattern
      content: |-
        <pre>if score >= 97 { return "A+" }
        if score >= 93 { return "A" }
        if score >= 90 { return "A-" }
        ... continue pattern ...
        return "F"</pre>
    solution: |-
      func scoreToGradePlus(score int) string {
          if score >= 97 { return "A+" }
          if score >= 93 { return "A" }
          if score >= 90 { return "A-" }
          if score >= 87 { return "B+" }
          if score >= 83 { return "B" }
          if score >= 80 { return "B-" }
          if score >= 77 { return "C+" }
          if score >= 73 { return "C" }
          if score >= 70 { return "C-" }
          if score >= 67 { return "D+" }
          if score >= 63 { return "D" }
          if score >= 60 { return "D-" }
          return "F"
      }
    difficulty: 3
  - id: v16
    title: Calculate Shipping Cost
    description: |-
      Write <code>func calculateShipping(weight float64, distance int, isPriority bool) float64</code> that calculates shipping cost. Base cost = weight * 0.5 + distance * 0.1. If isPriority, multiply total by 1.5. If weight > 50, add $10. If distance > 1000, add $20.
    functionSignature: func calculateShipping(weight float64, distance int, isPriority
      bool) float64
    testCases:
    - input: 30.0, 500, false
      output: '65.0'
      note: 30*0.5 + 500*0.1 = 15 + 50 = 65
    - input: 60.0, 1200, true
      output: '247.5'
      note: (60*0.5 + 1200*0.1 + 10 + 20) * 1.5 = 165 * 1.5 = 247.5
    hints:
    - title: Think about it
      content: |-
        Calculate base cost first. Then add conditional fees. Finally, apply priority multiplier if needed. Order matters!
    - title: Hint
      content: |-
        Start: cost = weight * 0.5 + distance * 0.1. Then: if weight > 50, cost += 10. if distance > 1000, cost += 20. Finally: if isPriority, cost *= 1.5.
    - title: Pattern
      content: |-
        <pre>1. Calculate base: weight*0.5 + distance*0.1
        2. Add weight surcharge if needed
        3. Add distance surcharge if needed
        4. Apply priority multiplier if needed
        5. Return total</pre>
    solution: "func calculateShipping(weight float64, distance int, isPriority bool)\
      \ float64 {\n    cost := weight * 0.5 + float64(distance) * 0.1\n    \n    if\
      \ weight > 50 {\n        cost += 10\n    }\n    \n    if distance > 1000 {\n\
      \        cost += 20\n    }\n    \n    if isPriority {\n        cost *= 1.5\n\
      \    }\n    \n    return cost\n}"
    difficulty: 3
- id: challenge_4
  block: 1
  difficulty: 1
  concept: Finding Extrema
  docLinks:
  - url: https://go.dev/ref/spec#Index_expressions
    title: 'Go Spec: Index expressions'
    note: accessing slice elements
  - url: https://pkg.go.dev/builtin#len
    title: Builtin len()
    note: string and slice length
  patternPrimer:
    bruteForce: Track the current best value; update whenever you find a better one.
    bestApproach: |-
      Same approach - initialize to first element, then compare each subsequent element.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Find Maximum
    description: Write <code>func max(nums []int) int</code> that returns the largest
      number.
    functionSignature: func max(nums []int) int
    testCases:
    - input: '[]int{3, 7, 2, 9}'
      output: '9'
    hints:
    - title: Think about it
      content: |-
        If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?
    - title: Hint
      content: |-
        Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best.
    - title: Pattern
      content: |-
        <pre>1. Start with first element as "best so far"
        2. For each remaining element:
           - Better than current best? → update best
        3. Return best</pre>
    solution: |-
      func max(nums []int) int {
          m := nums[0]
          for _, n := range nums {
              if n > m { m = n }
          }
          return m
      }
    difficulty: 1
  - id: v2
    title: Find Minimum
    description: Write <code>func min(nums []int) int</code> that returns the smallest
      number.
    functionSignature: func min(nums []int) int
    testCases:
    - input: '[]int{3, 7, 2, 9}'
      output: '2'
    hints:
    - title: Think about it
      content: |-
        If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?
    - title: Hint
      content: |-
        Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best.
    - title: Pattern
      content: |-
        <pre>1. Start with first element as "best so far"
        2. For each remaining element:
           - Better than current best? → update best
        3. Return best</pre>
    solution: |-
      func min(nums []int) int {
          m := nums[0]
          for _, n := range nums {
              if n < m { m = n }
          }
          return m
      }
    difficulty: 1
  - id: v3
    title: Longest String
    description: |-
      Write <code>func longest(words []string) string</code> that returns the longest word.
    functionSignature: func longest(words []string) string
    testCases:
    - input: '[]string{"go", "python"}'
      output: '"python"'
    hints:
    - title: Think about it
      content: |-
        If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?
    - title: Hint
      content: |-
        Initialize with the first element (not 0 or some arbitrary value). Compare each subsequent element - if it's better, update your best.
    - title: Pattern
      content: |-
        <pre>1. Start with first element as "best so far"
        2. For each remaining element:
           - Better than current best? → update best
        3. Return best</pre>
    solution: |-
      func longest(words []string) string {
          r := words[0]
          for _, w := range words {
              if len(w) > len(r) { r = w }
          }
          return r
      }
    difficulty: 1
  - id: v4
    title: Shortest String
    description: |-
      Write <code>func shortest(words []string) string</code> that returns the shortest word.
    functionSignature: func shortest(words []string) string
    testCases:
    - input: '[]string{"go", "python", "java"}'
      output: '"go"'
    hints:
    - title: Think about it
      content: |-
        If you want to track the 'best so far', what's a reasonable starting value? Hint: what if the first element is the answer?
    - title: Hint
      content: |-
        Initialize with the first element. Compare each subsequent element - if it's shorter, update your best.
    - title: Pattern
      content: |-
        <pre>1. Start with first element as "best so far"
        2. For each remaining element:
           - Shorter than current best? → update best
        3. Return best</pre>
    solution: |-
      func shortest(words []string) string {
          r := words[0]
          for _, w := range words {
              if len(w) < len(r) { r = w }
          }
          return r
      }
    difficulty: 1
  - id: v5
    title: Second Largest
    description: |-
      Write <code>func secondLargest(nums []int) int</code> that returns the second largest number. Assume at least 2 distinct numbers.
    functionSignature: func secondLargest(nums []int) int
    testCases:
    - input: '[]int{5, 1, 9, 3}'
      output: '5'
    - input: '[]int{10, 10, 8, 5}'
      output: '8'
    hints:
    - title: Think about it
      content: |-
        You need to track TWO values: the best so far AND the second best. When should each one update?
    - title: Hint
      content: |-
        Track first and second. When you find a new max, the old max becomes second. When you find something bigger than second but smaller than first, that becomes the new second.
    - title: Pattern
      content: |-
        <pre>1. Initialize first and second with smallest possible values
        2. For each element:
           - Bigger than first? → second = first, first = element
           - Bigger than second (and != first)? → second = element
        3. Return second</pre>
    solution: |-
      func secondLargest(nums []int) int {
          first, second := nums[0], nums[1]
          if second > first { first, second = second, first }
          for _, n := range nums[2:] {
              if n > first { second, first = first, n
              } else if n > second && n != first { second = n }
          }
          return second
      }
    difficulty: 3
  - id: v6
    title: Smallest Positive
    description: |-
      Write <code>func smallestPositive(nums []int) int</code> that returns the smallest positive number, or -1 if none exist.
    functionSignature: func smallestPositive(nums []int) int
    testCases:
    - input: '[]int{-5, 3, -1, 7, 2}'
      output: '2'
    - input: '[]int{-3, -1, 0}'
      output: '-1'
    hints:
    - title: Think about it
      content: |-
        You need to find an extrema (minimum) but with a condition (must be positive). What's tricky about initializing the 'best so far'?
    - title: Hint
      content: |-
        You can't initialize with nums[0] if it might not be positive. Either find the first positive to initialize, or use a flag to track if you've found any positive.
    - title: Pattern
      content: |-
        <pre>1. Initialize result to -1 (not found)
        2. For each element:
           - Is positive AND (first positive OR smaller than result)?
           → update result
        3. Return result</pre>
    solution: |-
      func smallestPositive(nums []int) int {
          result := -1
          for _, n := range nums {
              if n > 0 && (result == -1 || n < result) {
                  result = n
              }
          }
          return result
      }
    difficulty: 2
  - id: v7
    title: Highest Temperature
    description: |-
      Write <code>func highestTemp(temps []float64) float64</code> that returns the highest temperature reading.
    functionSignature: func highestTemp(temps []float64) float64
    testCases:
    - input: '[]float64{23.5, 28.7, 22.1, 30.2}'
      output: '30.2'
    - input: '[]float64{-5.5, -2.0, -10.0}'
      output: '-2.0'
    hints:
    - title: Think about it
      content: Track the highest temperature seen so far. Initialize with the first
        reading.
    - title: Hint
      content: |-
        Same pattern as finding max - start with first element, update when you find a higher value.
    - title: Pattern
      content: |-
        <pre>1. highest := temps[0]
        2. For each temp:
           - temp > highest? → highest = temp
        3. Return highest</pre>
    solution: |-
      func highestTemp(temps []float64) float64 {
          highest := temps[0]
          for _, t := range temps {
              if t > highest { highest = t }
          }
          return highest
      }
    difficulty: 1
  - id: v8
    title: Best Game Score
    description: |-
      Write <code>func bestScore(scores []int) int</code> that finds the highest score. Return -1 if no valid scores (all negative).
    functionSignature: func bestScore(scores []int) int
    testCases:
    - input: '[]int{450, 320, 580, 410}'
      output: '580'
    - input: '[]int{-1, -5, -3}'
      output: '-1'
    hints:
    - title: Think about it
      content: |-
        Find the maximum, but only count non-negative scores as valid. What if all scores are negative?
    - title: Hint
      content: |-
        Track the max, but initialize to -1. Only update if you find a score >= 0 that's also greater than current max.
    - title: Pattern
      content: |-
        <pre>1. bestScore := -1
        2. For each score:
           - score >= 0 AND score > bestScore?
             → bestScore = score
        3. Return bestScore</pre>
    solution: |-
      func bestScore(scores []int) int {
          bestScore := -1
          for _, s := range scores {
              if s >= 0 && s > bestScore {
                  bestScore = s
              }
          }
          return bestScore
      }
    difficulty: 2
  - id: v9
    title: Most Expensive Item
    description: |-
      Write <code>func mostExpensive(prices []float64) int</code> that returns the INDEX of the most expensive item.
    functionSignature: func mostExpensive(prices []float64) int
    testCases:
    - input: '[]float64{12.99, 45.50, 23.75, 50.00}'
      output: '3'
    - input: '[]float64{100.0, 200.0, 150.0}'
      output: '1'
    hints:
    - title: Think about it
      content: Instead of tracking the maximum VALUE, track the INDEX where the maximum
        occurs.
    - title: Hint
      content: |-
        Keep two variables: maxPrice and maxIndex. When you find a higher price, update both.
    - title: Pattern
      content: |-
        <pre>1. maxPrice, maxIndex := prices[0], 0
        2. For i, price:
           - price > maxPrice?
             → maxPrice = price, maxIndex = i
        3. Return maxIndex</pre>
    solution: |-
      func mostExpensive(prices []float64) int {
          maxPrice, maxIndex := prices[0], 0
          for i, price := range prices {
              if price > maxPrice {
                  maxPrice = price
                  maxIndex = i
              }
          }
          return maxIndex
      }
    difficulty: 2
  - id: v10
    title: Find Two Largest
    description: |-
      Write <code>func findTwoLargest(nums []int) (int, int)</code> that returns the two largest distinct values. First return value is the largest, second is second-largest.
    functionSignature: func findTwoLargest(nums []int) (int, int)
    testCases:
    - input: '[]int{3, 7, 2, 9, 5}'
      output: 9, 7
    - input: '[]int{1, 2, 3, 4, 5}'
      output: 5, 4
    hints:
    - title: Think about it
      content: |-
        You need to track TWO values as you iterate: the largest and second-largest. When you find a new max, the old max becomes second-max.
    - title: Hint
      content: |-
        Initialize first and second to very small values. For each number: if it's bigger than first, shift first to second, then update first. Else if it's bigger than second, update second.
    - title: Pattern
      content: |-
        <pre>1. first, second := nums[0], nums[1]
           (handle if first < second)
        2. For each remaining num:
           - num > first? → second = first, first = num
           - num > second? → second = num
        3. Return first, second</pre>
    solution: "func findTwoLargest(nums []int) (int, int) {\n    first, second :=\
      \ nums[0], nums[1]\n    if first < second {\n        first, second = second,\
      \ first\n    }\n    \n    for i := 2; i < len(nums); i++ {\n        if nums[i]\
      \ > first {\n            second = first\n            first = nums[i]\n     \
      \   } else if nums[i] > second {\n            second = nums[i]\n        }\n\
      \    }\n    \n    return first, second\n}"
    difficulty: 3
  - id: v11
    title: Longest String and Length
    description: |-
      Write <code>func longestStringAndLen(words []string) (string, int)</code> that returns the longest string and its length. If multiple strings tie for longest, return the first one.
    functionSignature: func longestStringAndLen(words []string) (string, int)
    testCases:
    - input: '["go", "rust", "python"]'
      output: '"python", 6'
    - input: '["hello", "world"]'
      output: '"hello", 5'
      note: both length 5, return first
    hints:
    - title: Think about it
      content: |-
        Track both the longest word AND its length. For each word, compute len(word) and compare to current max length.
    - title: Hint
      content: |-
        Keep longest string and maxLen. For each word, if len(word) > maxLen, update both longest and maxLen.
    - title: Pattern
      content: |-
        <pre>1. longest := words[0], maxLen := len(words[0])
        2. For each word:
           - len(word) > maxLen?
             → longest = word, maxLen = len(word)
        3. Return longest, maxLen</pre>
    solution: "func longestStringAndLen(words []string) (string, int) {\n    longest\
      \ := words[0]\n    maxLen := len(words[0])\n    \n    for _, word := range words\
      \ {\n        if len(word) > maxLen {\n            longest = word\n         \
      \   maxLen = len(word)\n        }\n    }\n    \n    return longest, maxLen\n\
      }"
    difficulty: 3
  - id: v12
    title: Find Range (Max - Min)
    description: |-
      Write <code>func findRange(nums []int) int</code> that returns the difference between the maximum and minimum values in the slice (range = max - min).
    functionSignature: func findRange(nums []int) int
    testCases:
    - input: '[]int{3, 7, 2, 9, 5}'
      output: '7'
      note: 9 - 2 = 7
    - input: '[]int{1, 1, 1}'
      output: '0'
    hints:
    - title: Think about it
      content: |-
        You need to find both the maximum and minimum values, then calculate their difference.
    - title: Hint
      content: |-
        Track both max and min as you iterate. Initialize both to nums[0]. For each number, update max if larger, update min if smaller. Return max - min.
    - title: Pattern
      content: |-
        <pre>1. max, min := nums[0], nums[0]
        2. For each num:
           - num > max? → max = num
           - num < min? → min = num
        3. Return max - min</pre>
    solution: "func findRange(nums []int) int {\n    max, min := nums[0], nums[0]\n\
      \    \n    for _, num := range nums {\n        if num > max {\n            max\
      \ = num\n        }\n        if num < min {\n            min = num\n        }\n\
      \    }\n    \n    return max - min\n}"
    difficulty: 3
  - id: v1
    title: Best Time to Buy and Sell Stock
    description: |-
      Given an array of stock prices where prices[i] is the price on day i, find the maximum profit from one buy and one sell. You must buy before you sell. <code>func maxProfit(prices []int) int</code>
    functionSignature: func maxProfit(prices []int) int
    testCases:
    - input: '[]int{7, 1, 5, 3, 6, 4}'
      output: '5'
      note: buy at 1, sell at 6
    - input: '[]int{7, 6, 4, 3, 1}'
      output: '0'
      note: prices only go down, no profit possible
    - input: '[]int{2, 4, 1}'
      output: '2'
      note: buy at 2, sell at 4
    solution: "func maxProfit(prices []int) int {\n    if len(prices) == 0 {\n   \
      \     return 0\n    }\n    \n    minPrice := prices[0]\n    maxProfit := 0\n\
      \    \n    for _, price := range prices {\n        if price < minPrice {\n \
      \           minPrice = price\n        } else if price - minPrice > maxProfit\
      \ {\n            maxProfit = price - minPrice\n        }\n    }\n    return\
      \ maxProfit\n}"
    difficulty: 4
  - id: v2
    title: Maximum Difference
    description: |-
      Find the maximum difference between any two elements where the larger element comes after the smaller one. Return 0 if no such pair exists. <code>func maxDiff(nums []int) int</code>
    functionSignature: func maxDiff(nums []int) int
    testCases:
    - input: '[]int{2, 3, 10, 6, 4, 8, 1}'
      output: '8'
      note: 10 - 2 = 8
    - input: '[]int{7, 9, 5, 6, 3, 2}'
      output: '2'
      note: 9 - 7 = 2
    - input: '[]int{5, 4, 3, 2, 1}'
      output: '0'
      note: decreasing, no valid pair
    solution: "func maxDiff(nums []int) int {\n    if len(nums) < 2 {\n        return\
      \ 0\n    }\n    \n    minSoFar := nums[0]\n    maxDiff := 0\n    \n    for i\
      \ := 1; i < len(nums); i++ {\n        diff := nums[i] - minSoFar\n        if\
      \ diff > maxDiff {\n            maxDiff = diff\n        }\n        if nums[i]\
      \ < minSoFar {\n            minSoFar = nums[i]\n        }\n    }\n    return\
      \ maxDiff\n}"
    solutionNotes: |-
      This is the same problem as Best Time to Buy/Sell Stock! Track the minimum seen so far, and at each position calculate the potential profit/difference.
    difficulty: 4
  - id: v3
    title: Best Sightseeing Pair
    description: |-
      Given an array of values, find max score of values[i] + values[j] + i - j where i < j. <code>func maxScoreSightseeingPair(values []int) int</code>
    functionSignature: func maxScoreSightseeingPair(values []int) int
    testCases:
    - input: '[]int{8, 1, 5, 2, 6}'
      output: '11'
      note: 'i=0, j=2: 8+5+0-2=11'
    - input: '[]int{1, 2}'
      output: '2'
      note: 1+2+0-1=2
    - input: '[]int{1, 3, 5}'
      output: '7'
      note: 'i=1, j=2: 3+5+1-2=7'
    solution: "func maxScoreSightseeingPair(values []int) int {\n    maxScore := 0\n\
      \    bestI := values[0] + 0  // values[i] + i\n    \n    for j := 1; j < len(values);\
      \ j++ {\n        score := bestI + values[j] - j\n        if score > maxScore\
      \ {\n            maxScore = score\n        }\n        if values[j] + j > bestI\
      \ {\n            bestI = values[j] + j\n        }\n    }\n    return maxScore\n\
      }"
    solutionNotes: |-
      Rewrite the formula: (values[i] + i) + (values[j] - j). Track the best (values[i] + i) seen so far, then for each j compute the score. Same pattern as stock problem!
    difficulty: 4
  - id: v4
    title: Maximum Subarray (Kadane's)
    description: |-
      Find the contiguous subarray with the largest sum. <code>func maxSubArray(nums []int) int</code>
    functionSignature: func maxSubArray(nums []int) int
    testCases:
    - input: '[]int{-2, 1, -3, 4, -1, 2, 1, -5, 4}'
      output: '6'
      note: '[4,-1,2,1] = 6'
    - input: '[]int{1}'
      output: '1'
    - input: '[]int{-1, -2, -3}'
      output: '-1'
      note: least negative
    solution: "func maxSubArray(nums []int) int {\n    maxSum := nums[0]\n    currentSum\
      \ := nums[0]\n    \n    for i := 1; i < len(nums); i++ {\n        if currentSum\
      \ < 0 {\n            currentSum = nums[i]\n        } else {\n            currentSum\
      \ += nums[i]\n        }\n        if currentSum > maxSum {\n            maxSum\
      \ = currentSum\n        }\n    }\n    return maxSum\n}"
    solutionNotes: |-
      Kadane's algorithm: at each position, decide whether to extend the current subarray or start fresh. Track the best sum seen so far. Same 'best so far' pattern!
    difficulty: 4
  - id: v5
    title: Best Time to Buy and Sell Stock II
    description: |-
      You can buy and sell multiple times (but must sell before buying again). Find the maximum total profit. <code>func maxProfitII(prices []int) int</code>
    functionSignature: func maxProfitII(prices []int) int
    testCases:
    - input: '[]int{7, 1, 5, 3, 6, 4}'
      output: '7'
      note: buy@1 sell@5 (+4), buy@3 sell@6 (+3)
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '4'
      note: buy@1 sell@5, or buy/sell each day
    - input: '[]int{7, 6, 4, 3, 1}'
      output: '0'
      note: no profit possible
    solution: "func maxProfitII(prices []int) int {\n    profit := 0\n    \n    for\
      \ i := 1; i < len(prices); i++ {\n        if prices[i] > prices[i-1] {\n   \
      \         profit += prices[i] - prices[i-1]\n        }\n    }\n    return profit\n\
      }"
    solutionNotes: |-
      Greedy insight: capture every upward movement! If tomorrow's price is higher, that's profit. Sum all positive differences. Much simpler than it seems!
    difficulty: 4
  - id: v6
    title: Trapping Rain Water
    description: |-
      Given an elevation map where width of each bar is 1, compute how much water can be trapped after raining. <code>func trap(height []int) int</code>
    functionSignature: func trap(height []int) int
    testCases:
    - input: '[]int{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}'
      output: '6'
    - input: '[]int{4, 2, 0, 3, 2, 5}'
      output: '9'
    - input: '[]int{1, 2, 3}'
      output: '0'
      note: strictly increasing, no trapping
    solution: "func trap(height []int) int {\n    if len(height) == 0 {\n        return\
      \ 0\n    }\n    \n    n := len(height)\n    maxLeft := make([]int, n)\n    maxRight\
      \ := make([]int, n)\n    \n    maxLeft[0] = height[0]\n    for i := 1; i < n;\
      \ i++ {\n        if height[i] > maxLeft[i-1] {\n            maxLeft[i] = height[i]\n\
      \        } else {\n            maxLeft[i] = maxLeft[i-1]\n        }\n    }\n\
      \    \n    maxRight[n-1] = height[n-1]\n    for i := n - 2; i >= 0; i-- {\n\
      \        if height[i] > maxRight[i+1] {\n            maxRight[i] = height[i]\n\
      \        } else {\n            maxRight[i] = maxRight[i+1]\n        }\n    }\n\
      \    \n    water := 0\n    for i := 0; i < n; i++ {\n        level := maxLeft[i]\n\
      \        if maxRight[i] < level {\n            level = maxRight[i]\n       \
      \ }\n        water += level - height[i]\n    }\n    return water\n}"
    solutionNotes: |-
      At each position, water level = min(maxLeft, maxRight). Pre-compute maxLeft[i] and maxRight[i] arrays using the 'best so far' pattern in both directions!
    difficulty: 4
- id: challenge_5
  block: 2
  difficulty: 2
  concept: Filter with Append
  docLinks:
  - url: https://pkg.go.dev/builtin#append
    title: Builtin append()
    note: growing slices dynamically
  - url: https://go.dev/blog/slices-intro
    title: 'Go Blog: Slices introduction'
    note: slice internals
  patternPrimer:
    bruteForce: Create a new slice and append elements that pass the condition.
    bestApproach: Same approach - loop once, append conditionally. Can't do better
      than O(n).
    typical: Typically O(n) time, O(k) extra space where k = filtered elements
  variants:
  - id: v1
    title: Filter Positives
    description: |-
      Write <code>func filterPositives(nums []int) []int</code> returning only positive numbers.
    functionSignature: func filterPositives(nums []int) []int
    testCases:
    - input: '[]int{-2, 3, -1, 5}'
      output: '[3, 5]'
    hints:
    - title: Think about it
      content: |-
        You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?
    - title: Hint
      content: |-
        Start with an empty slice. Loop through, check your condition, and append elements that pass.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result collection
        2. For each element:
           - Passes test? → add to result
        3. Return result</pre>
    solution: |-
      func filterPositives(nums []int) []int {
          r := []int{}
          for _, n := range nums {
              if n > 0 { r = append(r, n) }
          }
          return r
      }
    difficulty: 1
  - id: v2
    title: Filter Evens
    description: |-
      Write <code>func filterEvens(nums []int) []int</code> returning only even numbers.
    functionSignature: func filterEvens(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: '[2, 4]'
    hints:
    - title: Think about it
      content: |-
        You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?
    - title: Hint
      content: |-
        Start with an empty slice. Loop through, check your condition, and append elements that pass.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result collection
        2. For each element:
           - Passes test? → add to result
        3. Return result</pre>
    solution: |-
      func filterEvens(nums []int) []int {
          r := []int{}
          for _, n := range nums {
              if n%2 == 0 { r = append(r, n) }
          }
          return r
      }
    difficulty: 1
  - id: v3
    title: Filter Short Words
    description: |-
      Write <code>func filterShort(words []string, max int) []string</code> returning words with len <= max.
    functionSignature: func filterShort(words []string, max int) []string
    testCases:
    - input: '[]string{"go", "python"}, 3'
      output: '["go"]'
    hints:
    - title: Think about it
      content: |-
        You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?
    - title: Hint
      content: |-
        Start with an empty slice. Loop through, check your condition, and append elements that pass.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result collection
        2. For each element:
           - Passes test? → add to result
        3. Return result</pre>
    solution: |-
      func filterShort(words []string, max int) []string {
          r := []string{}
          for _, w := range words {
              if len(w) <= max { r = append(r, w) }
          }
          return r
      }
    difficulty: 2
  - id: v4
    title: Filter Greater Than
    description: |-
      Write <code>func filterGreater(nums []int, threshold int) []int</code> returning only numbers greater than threshold.
    functionSignature: func filterGreater(nums []int, threshold int) []int
    testCases:
    - input: '[]int{1, 5, 3, 8, 2}, 3'
      output: '[5, 8]'
    hints:
    - title: Think about it
      content: |-
        You want to build a new collection containing only some elements. What do you start with, and how do you add elements that pass your test?
    - title: Hint
      content: |-
        Start with an empty slice. Loop through, check if n > threshold, and append elements that pass.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result slice
        2. For each element:
           - Passes test? → append to result
        3. Return result</pre>
    solution: |-
      func filterGreater(nums []int, threshold int) []int {
          r := []int{}
          for _, n := range nums {
              if n > threshold { r = append(r, n) }
          }
          return r
      }
    difficulty: 1
  - id: v5
    title: Filter Non-Empty
    description: |-
      Write <code>func filterNonEmpty(words []string) []string</code> returning only non-empty strings.
    functionSignature: func filterNonEmpty(words []string) []string
    testCases:
    - input: '[]string{"go", "", "python", ""}'
      output: '["go", "python"]'
    hints:
    - title: Think about it
      content: You want to filter out empty strings. How do you check if a string
        is empty?
    - title: Hint
      content: |-
        Check if len(w) > 0 or equivalently w != "". Append only strings that pass this test.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result slice
        2. For each element:
           - Not empty? → append to result
        3. Return result</pre>
    solution: |-
      func filterNonEmpty(words []string) []string {
          r := []string{}
          for _, w := range words {
              if w != "" { r = append(r, w) }
          }
          return r
      }
    difficulty: 1
  - id: v6
    title: Filter In Range
    description: |-
      Write <code>func filterInRange(nums []int, min, max int) []int</code> returning numbers where min <= n <= max.
    functionSignature: func filterInRange(nums []int, min, max int) []int
    testCases:
    - input: '[]int{1, 5, 3, 8, 2}, 2, 5'
      output: '[5, 3, 2]'
    hints:
    - title: Think about it
      content: 'You need to check TWO conditions: the number must be >= min AND <=
        max.'
    - title: Hint
      content: |-
        Use n >= min && n <= max as your filter condition. Only append elements that satisfy both conditions.
    - title: Pattern
      content: |-
        <pre>1. Start with empty result slice
        2. For each element:
           - In range [min, max]? → append to result
        3. Return result</pre>
    solution: |-
      func filterInRange(nums []int, min, max int) []int {
          r := []int{}
          for _, n := range nums {
              if n >= min && n <= max { r = append(r, n) }
          }
          return r
      }
    difficulty: 2
  - id: v7
    title: Filter Palindromes
    difficulty: 3
    description: |-
      Write <code>func filterPalindromes(words []string) []string</code> that returns only palindromes (words that read the same forwards and backwards). Ignore case.
    functionSignature: func filterPalindromes(words []string) []string
    testCases:
    - input: '[]string{"racecar", "hello", "level", "world", "noon"}'
      output: '["racecar", "level", "noon"]'
    - input: '[]string{"Go", "was", "it", "a", "cat", "I", "saw"}'
      output: '["a", "I"]'
      note: Single chars are palindromes
    hints:
    - title: Think about it
      content: |-
        You need to filter, but the condition itself is complex (checking if a word is a palindrome). You'll need a helper function.
    - title: Hint
      content: |-
        Create isPalindrome(s string) bool that uses two pointers from opposite ends. Then filter: for each word, if isPalindrome(word), append it.
    - title: Pattern
      content: |-
        <pre>1. result := []string{}
        2. For each word:
           - If isPalindrome(word): append to result
        3. Return result

        isPalindrome(s):
          - left, right pointers from ends
          - Compare chars moving inward</pre>
    solution: |-
      func filterPalindromes(words []string) []string {
          result := []string{}
          for _, w := range words {
              if isPalindrome(w) {
                  result = append(result, w)
              }
          }
          return result
      }

      func isPalindrome(s string) bool {
          s = strings.ToLower(s)
          left, right := 0, len(s)-1
          for left < right {
              if s[left] != s[right] {
                  return false
              }
              left++
              right--
          }
          return true
      }
  - id: v8
    title: Filter Prime Numbers
    difficulty: 3
    description: |-
      Write <code>func filterPrimes(nums []int) []int</code> that returns only prime numbers. A prime is > 1 and divisible only by 1 and itself.
    functionSignature: func filterPrimes(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}'
      output: '[2, 3, 5, 7]'
    - input: '[]int{11, 12, 13, 14, 15}'
      output: '[11, 13]'
    hints:
    - title: Think about it
      content: |-
        Filtering + prime checking. You'll need an isPrime helper function that checks divisibility.
    - title: Hint
      content: |-
        Create isPrime(n int) bool. A number is prime if n > 1 and no number from 2 to sqrt(n) divides it evenly. Then filter using this function.
    - title: Pattern
      content: |-
        <pre>1. result := []int{}
        2. For each num:
           - If isPrime(num): append to result
        3. Return result</pre>
    solution: |-
      func filterPrimes(nums []int) []int {
          result := []int{}
          for _, n := range nums {
              if isPrime(n) {
                  result = append(result, n)
              }
          }
          return result
      }

      func isPrime(n int) bool {
          if n <= 1 {
              return false
          }
          for i := 2; i*i <= n; i++ {
              if n%i == 0 {
                  return false
              }
          }
          return true
      }
  - id: v9
    title: Affordable Items
    description: |-
      Write <code>func affordableItems(prices []float64, budget float64) []float64</code> that returns prices within budget.
    functionSignature: func affordableItems(prices []float64, budget float64) []float64
    testCases:
    - input: '[]float64{29.99, 45.00, 15.50, 60.00}, 40.0'
      output: '[]float64{29.99, 15.50}'
    - input: '[]float64{100.0, 200.0}, 50.0'
      output: '[]float64{}'
    hints:
    - title: Think about it
      content: Filter prices that are <= budget. Append matching prices to result
        slice.
    - title: Hint
      content: 'Standard filter pattern: if price <= budget, append it.'
    - title: Pattern
      content: |-
        <pre>1. result := []float64{}
        2. For each price:
           - price <= budget? → append to result
        3. Return result</pre>
    solution: |-
      func affordableItems(prices []float64, budget float64) []float64 {
          result := []float64{}
          for _, price := range prices {
              if price <= budget {
                  result = append(result, price)
              }
          }
          return result
      }
    difficulty: 1
  - id: v10
    title: Valid Emails
    description: |-
      Write <code>func validEmails(emails []string) []string</code> that returns emails containing '@' symbol.
    functionSignature: func validEmails(emails []string) []string
    testCases:
    - input: '[]string{"user@example.com", "invalid", "admin@site.org"}'
      output: '[]string{"user@example.com", "admin@site.org"}'
    - input: '[]string{"nope", "nada"}'
      output: '[]string{}'
    hints:
    - title: Think about it
      content: 'Simple validation: check if email contains ''@''. Use strings.Contains().'
    - title: Hint
      content: Filter emails where strings.Contains(email, "@") is true.
    - title: Pattern
      content: |-
        <pre>1. result := []string{}
        2. For each email:
           - contains '@'? → append to result
        3. Return result</pre>
    solution: |-
      func validEmails(emails []string) []string {
          result := []string{}
          for _, email := range emails {
              if strings.Contains(email, "@") {
                  result = append(result, email)
              }
          }
          return result
      }
    difficulty: 1
  - id: v11
    title: Filter By Length Range
    description: |-
      Write <code>func filterByLengthRange(words []string, minLen, maxLen int) []string</code> that returns words where minLen <= len(word) <= maxLen.
    functionSignature: func filterByLengthRange(words []string, minLen, maxLen int)
      []string
    testCases:
    - input: '[]string{"go", "rust", "python", "c"}, 2, 4'
      output: '[]string{"go", "rust"}'
    - input: '[]string{"a", "ab", "abc", "abcd"}, 2, 3'
      output: '[]string{"ab", "abc"}'
    hints:
    - title: Think about it
      content: 'Check two conditions: length must be >= minLen AND <= maxLen.'
    - title: Hint
      content: Filter words where len(word) >= minLen && len(word) <= maxLen.
    - title: Pattern
      content: |-
        <pre>1. result := []string{}
        2. For each word:
           - len(word) in range? → append
        3. Return result</pre>
    solution: |-
      func filterByLengthRange(words []string, minLen, maxLen int) []string {
          result := []string{}
          for _, word := range words {
              if len(word) >= minLen && len(word) <= maxLen {
                  result = append(result, word)
              }
          }
          return result
      }
    difficulty: 2
  - id: v12
    title: Filter Multiples
    description: |-
      Write <code>func filterMultiples(nums []int, divisor int) []int</code> that returns only numbers divisible by divisor (multiples of divisor).
    functionSignature: func filterMultiples(nums []int, divisor int) []int
    testCases:
    - input: '[]int{3, 6, 7, 9, 12, 15}, 3'
      output: '[]int{3, 6, 9, 12, 15}'
    - input: '[]int{1, 2, 3, 4, 5, 6}, 2'
      output: '[]int{2, 4, 6}'
    hints:
    - title: Think about it
      content: |-
        A number is divisible by divisor if num % divisor == 0. Filter based on this condition.
    - title: Hint
      content: For each number, check if num % divisor == 0, then append to result.
    - title: Pattern
      content: |-
        <pre>1. result := []int{}
        2. For each num:
           - num % divisor == 0? → append
        3. Return result</pre>
    solution: |-
      func filterMultiples(nums []int, divisor int) []int {
          result := []int{}
          for _, num := range nums {
              if num % divisor == 0 {
                  result = append(result, num)
              }
          }
          return result
      }
    difficulty: 2
  - id: v13
    title: Filter Contains Substring
    description: |-
      Write <code>func filterContains(words []string, substr string) []string</code> that returns words containing the substring.
    functionSignature: func filterContains(words []string, substr string) []string
    testCases:
    - input: '[]string{"hello", "world", "help", "loop"}, "lo"'
      output: '[]string{"hello", "loop"}'
    - input: '[]string{"go", "gopher", "python"}, "go"'
      output: '[]string{"go", "gopher"}'
    hints:
    - title: Think about it
      content: Use strings.Contains() to check if a word contains the substring.
    - title: Hint
      content: Import strings. Filter words where strings.Contains(word, substr) is
        true.
    - title: Pattern
      content: |-
        <pre>1. result := []string{}
        2. For each word:
           - contains substr? → append
        3. Return result</pre>
    solution: |-
      import "strings"

      func filterContains(words []string, substr string) []string {
          result := []string{}
          for _, word := range words {
              if strings.Contains(word, substr) {
                  result = append(result, word)
              }
          }
          return result
      }
    difficulty: 2
- id: challenge_6
  block: 2
  difficulty: 2
  concept: Find Index
  docLinks:
  - url: https://go.dev/ref/spec#For_statements
    title: 'Go Spec: For statements'
    note: range with index
  - url: https://go.dev/ref/spec#Return_statements
    title: 'Go Spec: Return statements'
    note: early returns
  patternPrimer:
    bruteForce: Loop through, return index immediately when found; return -1 if not
      found.
    bestApproach: |-
      Same approach - early return is already optimal! No need to continue after finding match.
    typical: Typically O(n) time worst case, O(1) if found early, O(1) extra space
  variants:
  - id: v1
    title: Find Index
    description: |-
      Write <code>func findIndex(nums []int, target int) int</code> returning index or -1.
    functionSignature: func findIndex(nums []int, target int) int
    testCases:
    - input: '[]int{10, 20, 30}, 20'
      output: '1'
    hints:
    - title: Think about it
      content: |-
        If you're looking for something specific, when should you stop looking? What should you return if you never find it?
    - title: Hint
      content: |-
        Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1.
    - title: Pattern
      content: |-
        <pre>1. For each element with its index:
           - Matches target? → return index immediately
        2. Loop finished? → return -1 (not found)</pre>
    solution: |-
      func findIndex(nums []int, target int) int {
          for i, n := range nums {
              if n == target { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v2
    title: Find Word
    description: |-
      Write <code>func findWord(words []string, target string) int</code> returning index or -1.
    functionSignature: func findWord(words []string, target string) int
    testCases:
    - input: '[]string{"go", "py"}, "py"'
      output: '1'
    hints:
    - title: Think about it
      content: |-
        If you're looking for something specific, when should you stop looking? What should you return if you never find it?
    - title: Hint
      content: |-
        Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1.
    - title: Pattern
      content: |-
        <pre>1. For each element with its index:
           - Matches target? → return index immediately
        2. Loop finished? → return -1 (not found)</pre>
    solution: |-
      func findWord(words []string, target string) int {
          for i, w := range words {
              if w == target { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v3
    title: First Negative Index
    description: |-
      Write <code>func firstNegIdx(nums []int) int</code> returning index of first negative or -1.
    functionSignature: func firstNegIdx(nums []int) int
    testCases:
    - input: '[]int{5, -2, 3}'
      output: '1'
    hints:
    - title: Think about it
      content: |-
        If you're looking for something specific, when should you stop looking? What should you return if you never find it?
    - title: Hint
      content: |-
        Loop with the index variable. When you find a match, return that index immediately (early return). If the loop completes without finding anything, return -1.
    - title: Pattern
      content: |-
        <pre>1. For each element with its index:
           - Matches target? → return index immediately
        2. Loop finished? → return -1 (not found)</pre>
    solution: |-
      func firstNegIdx(nums []int) int {
          for i, n := range nums {
              if n < 0 { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v4
    title: Find First Even
    description: |-
      Write <code>func firstEvenIdx(nums []int) int</code> returning the index of the first even number, or -1 if none.
    functionSignature: func firstEvenIdx(nums []int) int
    testCases:
    - input: '[]int{1, 3, 4, 5}'
      output: '2'
    - input: '[]int{1, 3, 5}'
      output: '-1'
    hints:
    - title: Think about it
      content: How do you check if a number is even? Use the modulo operator.
    - title: Hint
      content: |-
        Check if n % 2 == 0. If so, return that index immediately. Otherwise keep looking.
    - title: Pattern
      content: |-
        <pre>1. For each element with its index:
           - Is even (n % 2 == 0)? → return index
        2. Loop finished? → return -1 (not found)</pre>
    solution: |-
      func firstEvenIdx(nums []int) int {
          for i, n := range nums {
              if n % 2 == 0 { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v5
    title: Last Index Of
    description: |-
      Write <code>func lastIndex(nums []int, target int) int</code> returning the LAST index where target appears, or -1.
    functionSignature: func lastIndex(nums []int, target int) int
    testCases:
    - input: '[]int{1, 2, 3, 2, 1}, 2'
      output: '3'
    - input: '[]int{1, 2, 3}, 5'
      output: '-1'
    hints:
    - title: Think about it
      content: |-
        Unlike finding the FIRST match (where you return immediately), for the LAST match you need to keep track of matches as you go.
    - title: Hint
      content: |-
        Initialize result to -1. Each time you find a match, update result to that index. After the loop, return result.
    - title: Pattern
      content: |-
        <pre>1. Initialize result := -1
        2. For each element with its index:
           - Matches target? → result = index
        3. Return result (last match, or -1)</pre>
    solution: |-
      func lastIndex(nums []int, target int) int {
          result := -1
          for i, n := range nums {
              if n == target { result = i }
          }
          return result
      }
    difficulty: 2
  - id: v6
    title: Find Long Word Index
    description: |-
      Write <code>func findLongWordIdx(words []string, minLen int) int</code> returning the index of first word with length >= minLen, or -1.
    functionSignature: func findLongWordIdx(words []string, minLen int) int
    testCases:
    - input: '[]string{"go", "hi", "python"}, 4'
      output: '2'
    - input: '[]string{"a", "bb"}, 5'
      output: '-1'
    hints:
    - title: Think about it
      content: |-
        Instead of matching an exact value, you're matching a condition (length >= minLen).
    - title: Hint
      content: |-
        Check if len(w) >= minLen. If so, return that index immediately. Otherwise keep looking.
    - title: Pattern
      content: |-
        <pre>1. For each word with its index:
           - Long enough? → return index
        2. Loop finished? → return -1 (not found)</pre>
    solution: |-
      func findLongWordIdx(words []string, minLen int) int {
          for i, w := range words {
              if len(w) >= minLen { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v7
    title: Find All Indices
    difficulty: 3
    description: |-
      Write <code>func findAllIndices(nums []int, target int) []int</code> that returns a slice of ALL positions where target appears. Return empty slice if not found.
    functionSignature: func findAllIndices(nums []int, target int) []int
    testCases:
    - input: '[]int{1, 3, 5, 3, 7, 3}, 3'
      output: '[1, 3, 5]'
      note: 3 appears at indices 1, 3, and 5
    - input: '[]int{1, 2, 3}, 5'
      output: '[]'
      note: Not found, return empty slice
    hints:
    - title: Think about it
      content: |-
        Instead of returning on first match, you need to collect ALL matching indices and keep searching.
    - title: Hint
      content: |-
        Create an empty result slice. Loop through all elements - whenever you find a match, append the index to result. Don't return early, keep searching.
    - title: Pattern
      content: |-
        <pre>1. indices := []int{}
        2. For i, num in enumerate:
           - If num == target: append i to indices
        3. Return indices (might be empty)</pre>
    solution: |-
      func findAllIndices(nums []int, target int) []int {
          indices := []int{}
          for i, n := range nums {
              if n == target {
                  indices = append(indices, i)
              }
          }
          return indices
      }
  - id: v8
    title: Binary Search Index
    difficulty: 3
    description: |-
      Write <code>func binarySearch(nums []int, target int) int</code> that finds target in a SORTED slice using binary search. Return index or -1. Must use divide-and-conquer, not linear search.
    functionSignature: func binarySearch(nums []int, target int) int
    testCases:
    - input: '[]int{1, 3, 5, 7, 9, 11}, 7'
      output: '3'
    - input: '[]int{1, 3, 5, 7, 9, 11}, 4'
      output: '-1'
    - input: '[]int{2, 4, 6, 8, 10}, 2'
      output: '0'
    hints:
    - title: Think about it
      content: |-
        Since the slice is sorted, you don't need to check every element. Compare target to the middle element - this tells you which half to search next.
    - title: Hint
      content: |-
        Use two pointers: left = 0, right = len-1. While left <= right: calculate mid = (left+right)/2. If nums[mid] == target, found it! If target < nums[mid], search left half (right = mid-1). Otherwise search right half (left = mid+1).
    - title: Pattern
      content: |-
        <pre>1. left := 0, right := len(nums)-1
        2. While left <= right:
           - mid := (left + right) / 2
           - If nums[mid] == target: return mid
           - If target < nums[mid]: right = mid - 1
           - Else: left = mid + 1
        3. Return -1 (not found)</pre>
    solution: |-
      func binarySearch(nums []int, target int) int {
          left, right := 0, len(nums)-1
          for left <= right {
              mid := (left + right) / 2
              if nums[mid] == target {
                  return mid
              } else if target < nums[mid] {
                  right = mid - 1
              } else {
                  left = mid + 1
              }
          }
          return -1
      }
  - id: v9
    title: First Negative Index
    description: |-
      Write <code>func firstNegativeIdx(nums []int) int</code> that returns index of first negative number, or -1.
    functionSignature: func firstNegativeIdx(nums []int) int
    testCases:
    - input: '[]int{5, 3, -2, 8}'
      output: '2'
    - input: '[]int{1, 2, 3}'
      output: '-1'
    hints:
    - title: Think about it
      content: Return index as soon as you find num < 0.
    - title: Hint
      content: 'Early return pattern: for i, num := range nums { if num < 0 { return
        i } }'
    - title: Pattern
      content: |-
        <pre>1. For i, num:
           - num < 0? → return i
        2. Return -1</pre>
    solution: |-
      func firstNegativeIdx(nums []int) int {
          for i, num := range nums {
              if num < 0 { return i }
          }
          return -1
      }
    difficulty: 1
  - id: v10
    title: Find Keyword Position
    description: |-
      Write <code>func findKeyword(words []string, keyword string) int</code> that returns index of keyword (case-insensitive).
    functionSignature: func findKeyword(words []string, keyword string) int
    testCases:
    - input: '[]string{"hello", "WORLD", "Go"}, "world"'
      output: '1'
    - input: '[]string{"apple", "banana"}, "orange"'
      output: '-1'
    hints:
    - title: Think about it
      content: Compare lowercase versions of both word and keyword.
    - title: Hint
      content: Use strings.ToLower() to normalize before comparing.
    - title: Pattern
      content: |-
        <pre>1. For i, word:
           - ToLower(word) == ToLower(keyword)?
             → return i
        2. Return -1</pre>
    solution: |-
      func findKeyword(words []string, keyword string) int {
          keyword = strings.ToLower(keyword)
          for i, word := range words {
              if strings.ToLower(word) == keyword {
                  return i
              }
          }
          return -1
      }
    difficulty: 2
  - id: v11
    title: Find First Negative
    description: |-
      Write <code>func findFirstNegative(nums []int) int</code> that returns the index of the first negative number, or -1 if none found.
    functionSignature: func findFirstNegative(nums []int) int
    testCases:
    - input: '[]int{5, 3, -2, 8, -1}'
      output: '2'
    - input: '[]int{1, 2, 3}'
      output: '-1'
    hints:
    - title: Think about it
      content: |-
        Loop through and check each number. Return the index as soon as you find a negative.
    - title: Hint
      content: 'Use early return: if num < 0, return i immediately.'
    - title: Pattern
      content: |-
        <pre>1. For i, num:
           - num < 0? → return i
        2. Return -1 (not found)</pre>
    solution: |-
      func findFirstNegative(nums []int) int {
          for i, num := range nums {
              if num < 0 {
                  return i
              }
          }
          return -1
      }
    difficulty: 2
  - id: v12
    title: Find Last Index Of
    description: |-
      Write <code>func findLastIndexOf(nums []int, target int) int</code> that returns the index of the LAST occurrence of target, or -1 if not found.
    functionSignature: func findLastIndexOf(nums []int, target int) int
    testCases:
    - input: '[]int{1, 2, 3, 2, 5}, 2'
      output: '3'
      note: last occurrence of 2 is at index 3
    - input: '[]int{5, 5, 5}, 5'
      output: '2'
    hints:
    - title: Think about it
      content: |-
        Loop through all elements and track the most recent index where you found the target.
    - title: Hint
      content: Keep updating lastIndex whenever you find target. Initialize to -1.
    - title: Pattern
      content: |-
        <pre>1. lastIndex := -1
        2. For i, num:
           - num == target? → lastIndex = i
        3. Return lastIndex</pre>
    solution: |-
      func findLastIndexOf(nums []int, target int) int {
          lastIndex := -1
          for i, num := range nums {
              if num == target {
                  lastIndex = i
              }
          }
          return lastIndex
      }
    difficulty: 2
  - id: v13
    title: Find Index of Longest Word
    description: |-
      Write <code>func findLongestWordIndex(words []string) int</code> that returns the index of the longest word. If multiple words tie, return the first occurrence.
    functionSignature: func findLongestWordIndex(words []string) int
    testCases:
    - input: '[]string{"go", "rust", "python", "c"}'
      output: '2'
      note: python is longest at index 2
    - input: '[]string{"hello", "world"}'
      output: '0'
      note: both length 5, return first
    hints:
    - title: Think about it
      content: Track both the maximum length seen and the index where it occurred.
    - title: Hint
      content: Keep maxLen and maxIndex. For each word, if len(word) > maxLen, update
        both.
    - title: Pattern
      content: |-
        <pre>1. maxLen := 0, maxIndex := 0
        2. For i, word:
           - len(word) > maxLen?
             → maxLen = len(word), maxIndex = i
        3. Return maxIndex</pre>
    solution: "func findLongestWordIndex(words []string) int {\n    maxLen := 0\n\
      \    maxIndex := 0\n    \n    for i, word := range words {\n        if len(word)\
      \ > maxLen {\n            maxLen = len(word)\n            maxIndex = i\n   \
      \     }\n    }\n    \n    return maxIndex\n}"
    difficulty: 2
- id: challenge_7
  block: 2
  difficulty: 2
  concept: Frequency Map
  docLinks:
  - url: https://go.dev/blog/maps
    title: 'Go Blog: Go maps in action'
    note: map operations
  - url: https://go.dev/ref/spec#Making_slices_maps_and_channels
    title: 'Go Spec: make()'
    note: creating maps
  patternPrimer:
    bruteForce: |-
      Nested loops: for each unique element, scan the entire array again to count occurrences.
    bestApproach: |-
      Single pass with a map, incrementing counts[element]++ as we go. Map automatically tracks unique keys.
    typical: Typically O(n) time, O(n) extra space
  variants:
  - id: v1
    title: Count Occurrences
    description: Write <code>func countOccurrences(nums []int) map[int]int</code>.
    functionSignature: func countOccurrences(nums []int) map[int]int
    testCases:
    - input: '[]int{1, 2, 2, 3, 3, 3}'
      output: map[1:1 2:2 3:3]
    hints:
    - title: Think about it
      content: |-
        You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?
    - title: Hint
      content: |-
        Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each element:
           - Increment count for that element
        3. Return map</pre>
    solution: |-
      func countOccurrences(nums []int) map[int]int {
          c := make(map[int]int)
          for _, n := range nums { c[n]++ }
          return c
      }
    difficulty: 1
  - id: v2
    title: Count Characters
    description: Write <code>func countChars(s string) map[rune]int</code>.
    functionSignature: func countChars(s string) map[rune]int
    testCases:
    - input: '"hello"'
      output: map[e:1 h:1 l:2 o:1]
    hints:
    - title: Think about it
      content: |-
        You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?
    - title: Hint
      content: |-
        Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each element:
           - Increment count for that element
        3. Return map</pre>
    solution: |-
      func countChars(s string) map[rune]int {
          c := make(map[rune]int)
          for _, r := range s { c[r]++ }
          return c
      }
    difficulty: 1
  - id: v3
    title: Word Frequency
    description: Write <code>func wordFreq(words []string) map[string]int</code>.
    functionSignature: func wordFreq(words []string) map[string]int
    testCases:
    - input: '[]string{"go", "go", "py"}'
      output: map[go:2 py:1]
    hints:
    - title: Think about it
      content: |-
        You want to count how many times each element appears. What data structure maps 'thing' to 'count of that thing'?
    - title: Hint
      content: |-
        Use a map where keys are the elements and values are counts. The magic: accessing a non-existent key returns 0, so you can just do counts[item]++ even for the first occurrence.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each element:
           - Increment count for that element
        3. Return map</pre>
    solution: |-
      func wordFreq(words []string) map[string]int {
          c := make(map[string]int)
          for _, w := range words { c[w]++ }
          return c
      }
    difficulty: 1
  - id: v4
    title: Count Even and Odd
    description: |-
      Write <code>func countEvenOdd(nums []int) map[string]int</code> returning a map with keys "even" and "odd" showing how many of each.
    functionSignature: func countEvenOdd(nums []int) map[string]int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}'
      output: map[even:2 odd:3]
    hints:
    - title: Think about it
      content: |-
        Similar to counting positives/negatives, but now store the counts in a map instead of separate variables.
    - title: Hint
      content: |-
        Use num % 2 to check: if it equals 0, the number is even. Increment the appropriate key in your map.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each element:
           - Is it even (num % 2 == 0)? → increment "even"
           - Otherwise → increment "odd"
        3. Return map</pre>
    solution: |-
      func countEvenOdd(nums []int) map[string]int {
          c := make(map[string]int)
          for _, n := range nums {
              if n % 2 == 0 { c["even"]++ } else { c["odd"]++ }
          }
          return c
      }
    difficulty: 2
  - id: v5
    title: Invert Count Map
    description: |-
      Write <code>func invertCounts(counts map[string]int) map[int][]string</code> that inverts a frequency map. Keys become values grouped by their original values.
    functionSignature: func invertCounts(counts map[string]int) map[int][]string
    testCases:
    - input: 'map[string]int{"a": 2, "b": 1, "c": 2}'
      output: map[1:[b] 2:[a c]]
      note: 'words with count 1: [b], words with count 2: [a, c]'
    hints:
    - title: Think about it
      content: |-
        You're flipping the relationship: instead of word→count, you want count→[words with that count].
    - title: Hint
      content: |-
        Loop through the original map. For each key-value pair, append the key to the slice stored at the value in your new map.
    - title: Pattern
      content: |-
        <pre>1. Create result map[int][]string
        2. For each word, count in original:
           - Append word to result[count]
        3. Return result</pre>
    solution: |-
      func invertCounts(counts map[string]int) map[int][]string {
          result := make(map[int][]string)
          for word, count := range counts {
              result[count] = append(result[count], word)
          }
          return result
      }
    difficulty: 3
  - id: v6
    title: Count by Length
    description: |-
      Write <code>func countByLength(words []string) map[int]int</code> that groups words by their length and counts how many words are in each group. Keys are lengths, values are counts.
    functionSignature: func countByLength(words []string) map[int]int
    testCases:
    - input: '[]string{"go", "rust", "c", "js"}'
      output: map[1:1 2:2 4:1]
      note: 1 word of length 1 (c), 2 words of length 2 (go, js), 1 word of length
        4 (rust)
    hints:
    - title: Think about it
      content: |-
        Instead of counting the words themselves, you're counting a property of each word. What property? Its length.
    - title: Hint
      content: |-
        Use len(word) as the key. Same counting pattern, just using the length instead of the word itself.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each word:
           - Get its length with len(word)
           - Increment count for that length
        3. Return map</pre>
    solution: |-
      func countByLength(words []string) map[int]int {
          c := make(map[int]int)
          for _, w := range words { c[len(w)]++ }
          return c
      }
    difficulty: 2
  - id: v7
    title: Count by Remainder
    description: |-
      Write <code>func countByRemainder(nums []int, divisor int) map[int]int</code> that groups numbers by their remainder when divided by divisor.
    functionSignature: func countByRemainder(nums []int, divisor int) map[int]int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6}, 3'
      output: map[0:2 1:2 2:2]
      note: 3,6 have remainder 0; 1,4 have remainder 1; 2,5 have remainder 2
    - input: '[]int{10, 20, 30}, 10'
      output: map[0:3]
    hints:
    - title: Think about it
      content: |-
        The key is num % divisor (the remainder). Count how many numbers give each remainder.
    - title: Hint
      content: Same counting pattern as before, but use num % divisor as the key.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each num:
           - remainder := num % divisor
           - counts[remainder]++
        3. Return counts</pre>
    solution: |-
      func countByRemainder(nums []int, divisor int) map[int]int {
          c := make(map[int]int)
          for _, n := range nums { c[n % divisor]++ }
          return c
      }
    difficulty: 2
  - id: v8
    title: Group by First Letter
    description: |-
      Write <code>func countByFirstLetter(words []string) map[string]int</code> that counts how many words start with each letter. Use lowercase keys.
    functionSignature: func countByFirstLetter(words []string) map[string]int
    testCases:
    - input: '[]string{"apple", "ant", "bear", "ace"}'
      output: map[a:3 b:1]
    - input: '[]string{"Go", "great", "Python"}'
      output: map[g:2 p:1]
      note: lowercase keys
    hints:
    - title: Think about it
      content: |-
        Extract the first character of each word and use it as the key. How do you get the first character of a string?
    - title: Hint
      content: |-
        Use strings.ToLower(string(word[0])) to get the lowercase first letter as a string. Then count like before.
    - title: Pattern
      content: |-
        <pre>1. Create empty count map
        2. For each word:
           - Get first letter (lowercase)
           - Increment count for that letter
        3. Return map</pre>
    solution: |-
      func countByFirstLetter(words []string) map[string]int {
          c := make(map[string]int)
          for _, w := range words {
              if len(w) > 0 {
                  first := strings.ToLower(string(w[0]))
                  c[first]++
              }
          }
          return c
      }
    difficulty: 2
  - id: v9
    title: Vote Tally
    description: |-
      Write <code>func voteTally(votes []string) map[string]int</code> that counts votes for each candidate.
    functionSignature: func voteTally(votes []string) map[string]int
    testCases:
    - input: '[]string{"Alice", "Bob", "Alice", "Charlie", "Alice"}'
      output: 'map[string]int{"Alice": 3, "Bob": 1, "Charlie": 1}'
    - input: '[]string{"Yes", "No", "Yes"}'
      output: 'map[string]int{"Yes": 2, "No": 1}'
    hints:
    - title: Think about it
      content: 'Standard frequency map: increment count for each vote.'
    - title: Hint
      content: counts[vote]++ for each vote.
    - title: Pattern
      content: |-
        <pre>1. counts := make(map[string]int)
        2. For each vote:
           - counts[vote]++
        3. Return counts</pre>
    solution: |-
      func voteTally(votes []string) map[string]int {
          counts := make(map[string]int)
          for _, vote := range votes {
              counts[vote]++
          }
          return counts
      }
    difficulty: 1
  - id: v10
    title: Grade Distribution
    description: |-
      Write <code>func gradeDistribution(grades []string) map[string]int</code> that counts how many of each letter grade.
    functionSignature: func gradeDistribution(grades []string) map[string]int
    testCases:
    - input: '[]string{"A", "B", "A", "C", "A", "B"}'
      output: 'map[string]int{"A": 3, "B": 2, "C": 1}'
    - input: '[]string{"F", "F", "D"}'
      output: 'map[string]int{"F": 2, "D": 1}'
    hints:
    - title: Think about it
      content: Another frequency map - count occurrences of each grade.
    - title: Hint
      content: 'Same pattern: dist[grade]++ for each grade.'
    - title: Pattern
      content: |-
        <pre>1. dist := make(map[string]int)
        2. For each grade:
           - dist[grade]++
        3. Return dist</pre>
    solution: |-
      func gradeDistribution(grades []string) map[string]int {
          dist := make(map[string]int)
          for _, grade := range grades {
              dist[grade]++
          }
          return dist
      }
    difficulty: 1
  - id: v11
    title: Most Common Element
    description: |-
      Write <code>func mostCommonElement(items []string) string</code> that returns the element appearing most frequently. If multiple items tie for most common, return the one that appeared first.
    functionSignature: func mostCommonElement(items []string) string
    testCases:
    - input: '["cat", "dog", "cat", "bird", "dog", "dog"]'
      output: '"dog"'
      note: dog appears 3 times
    - input: '["a", "b", "a"]'
      output: '"a"'
    hints:
    - title: Think about it
      content: |-
        First build a frequency map to count all items. Then find the key with the highest value. Track both the item and its frequency as you search.
    - title: Hint
      content: |-
        Build frequency map with freq[item]++. Then loop through the map to find the key with maximum value. Keep track of maxCount and mostCommon item.
    - title: Pattern
      content: |-
        <pre>1. Build frequency map
        2. maxCount := 0, mostCommon := ""
        3. For each item, count in map:
           - count > maxCount?
             → maxCount = count, mostCommon = item
        4. Return mostCommon</pre>
    solution: "func mostCommonElement(items []string) string {\n    freq := make(map[string]int)\n\
      \    for _, item := range items {\n        freq[item]++\n    }\n    \n    maxCount\
      \ := 0\n    mostCommon := \"\"\n    \n    for item, count := range freq {\n\
      \        if count > maxCount {\n            maxCount = count\n            mostCommon\
      \ = item\n        }\n    }\n    \n    return mostCommon\n}"
    difficulty: 3
  - id: v12
    title: Frequency Histogram
    description: |-
      Write <code>func frequencyHistogram(nums []int) map[int]int</code> that returns a "meta-map" showing how many elements appear each number of times. For example, if 2 elements appear once and 1 element appears twice, return map[1:2, 2:1].
    functionSignature: func frequencyHistogram(nums []int) map[int]int
    testCases:
    - input: '[]int{1, 1, 2, 3, 3, 3}'
      output: map[1:1 2:2 3:1]
      note: |-
        one element appears 1x (2), two elements appear 2x (1), one element appears 3x (3)
    - input: '[]int{5, 5, 5, 5}'
      output: map[4:1]
      note: one element appears 4 times
    hints:
    - title: Think about it
      content: |-
        Build a frequency map first to count how often each number appears. Then build a second map that counts how many numbers have each frequency.
    - title: Hint
      content: |-
        Step 1: Build freq map with freq[num]++. Step 2: Build histogram with histogram[count]++ for each count in freq. This creates a frequency-of-frequencies map.
    - title: Pattern
      content: |-
        <pre>1. Build freq map (num → count)
        2. Create histogram map[int]int
        3. For each count in freq.values:
           - histogram[count]++
        4. Return histogram</pre>
    solution: "func frequencyHistogram(nums []int) map[int]int {\n    freq := make(map[int]int)\n\
      \    for _, num := range nums {\n        freq[num]++\n    }\n    \n    histogram\
      \ := make(map[int]int)\n    for _, count := range freq {\n        histogram[count]++\n\
      \    }\n    \n    return histogram\n}"
    difficulty: 3
  - id: v13
    title: Merge Frequency Maps
    description: |-
      Write <code>func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int</code> that merges two frequency maps by adding their counts. If a key exists in both maps, add the counts together.
    functionSignature: func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int
    testCases:
    - input: map["a":2, "b":1], map["a":1, "c":3]
      output: map["a":3 "b":1 "c":3]
    - input: map["x":5], map["x":3]
      output: map["x":8]
    hints:
    - title: Think about it
      content: |-
        Copy all entries from map1 to result. Then iterate through map2, adding each count to result (which may already have that key).
    - title: Hint
      content: |-
        Create result map. Copy map1: result[k] = v. Then for each k, v in map2: result[k] += v. This adds to existing or creates new entry.
    - title: Pattern
      content: |-
        <pre>1. Create result map
        2. Copy all from map1 to result
        3. For each key, value in map2:
           - result[key] += value
        4. Return result</pre>
    solution: "func mergeFrequencyMaps(map1, map2 map[string]int) map[string]int {\n\
      \    result := make(map[string]int)\n    \n    for k, v := range map1 {\n  \
      \      result[k] = v\n    }\n    \n    for k, v := range map2 {\n        result[k]\
      \ += v\n    }\n    \n    return result\n}"
    difficulty: 3
  - id: v1
    title: Contains Duplicate
    description: |-
      Write a function <code>func containsDuplicate(nums []int) bool</code> that returns <code>true</code> if any number appears more than once in the slice, <code>false</code> if all numbers are unique.
    functionSignature: func containsDuplicate(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 3, 1}'
      output: 'true'
    - input: '[]int{1, 2, 3, 4}'
      output: 'false'
    - input: '[]int{1, 1, 1, 1}'
      output: 'true'
    solution: |-
      func containsDuplicate(nums []int) bool {
          seen := make(map[int]bool)
          for _, num := range nums {
              if seen[num] {
                  return true
              }
              seen[num] = true
          }
          return false
      }
    difficulty: 4
  - id: v2
    title: First Duplicate Value
    description: |-
      Write a function <code>func firstDuplicate(nums []int) int</code> that returns the first number that appears twice (the second occurrence). Return <code>-1</code> if no duplicates exist.
    functionSignature: func firstDuplicate(nums []int) int
    testCases:
    - input: '[]int{2, 1, 3, 5, 3, 2}'
      output: '3'
      note: 3 is seen again before 2 is
    - input: '[]int{1, 2, 3, 4}'
      output: '-1'
    - input: '[]int{1, 1, 2, 2}'
      output: '1'
    solution: |-
      func firstDuplicate(nums []int) int {
          seen := make(map[int]bool)
          for _, num := range nums {
              if seen[num] {
                  return num
              }
              seen[num] = true
          }
          return -1
      }
    solutionNotes: |-
      Unlike Contains Duplicate which returns a bool, this returns the actual duplicate value. Same pattern, different return type!
    difficulty: 4
  - id: v3
    title: Count Unique Elements
    description: |-
      Write a function <code>func countUnique(nums []int) int</code> that returns how many distinct values are in the slice.
    functionSignature: func countUnique(nums []int) int
    testCases:
    - input: '[]int{1, 2, 2, 3, 3, 3}'
      output: '3'
      note: 'unique values: 1, 2, 3'
    - input: '[]int{5, 5, 5, 5}'
      output: '1'
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '5'
    solution: |-
      func countUnique(nums []int) int {
          seen := make(map[int]bool)
          for _, num := range nums {
              seen[num] = true
          }
          return len(seen)
      }
    solutionNotes: |-
      Here we don't check if seen - we just add everything. The map handles duplicates automatically, and <code>len(seen)</code> gives us the count of unique keys!
    difficulty: 4
  - id: v4
    title: Find All Duplicates
    description: |-
      Write a function <code>func findDuplicates(nums []int) []int</code> that returns a slice containing each number that appears more than once. Each duplicate should only appear once in the result.
    functionSignature: func findDuplicates(nums []int) []int
    testCases:
    - input: '[]int{4, 3, 2, 7, 8, 2, 3, 1}'
      output: '[2, 3]'
    - input: '[]int{1, 1, 2, 2, 3, 3}'
      output: '[1, 2, 3]'
    - input: '[]int{1, 2, 3}'
      output: '[]'
    solution: "func findDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n\
      \    added := make(map[int]bool)\n    result := []int{}\n    \n    for _, num\
      \ := range nums {\n        if seen[num] && !added[num] {\n            result\
      \ = append(result, num)\n            added[num] = true\n        }\n        seen[num]\
      \ = true\n    }\n    return result\n}"
    solutionNotes: |-
      We need TWO maps here: one to track what we've seen, and one to avoid adding the same duplicate twice to the result.
    difficulty: 4
  - id: v5
    title: Common Elements
    description: |-
      Write a function <code>func hasCommon(a, b []int) bool</code> that returns <code>true</code> if the two slices share at least one common element.
    functionSignature: func hasCommon(a, b []int) bool
    testCases:
    - input: '[]int{1, 2, 3}, []int{3, 4, 5}'
      output: 'true'
      note: 3 is common
    - input: '[]int{1, 2}, []int{3, 4}'
      output: 'false'
    - input: '[]int{1}, []int{1}'
      output: 'true'
    solution: "func hasCommon(a, b []int) bool {\n    setA := make(map[int]bool)\n\
      \    for _, num := range a {\n        setA[num] = true\n    }\n    \n    for\
      \ _, num := range b {\n        if setA[num] {\n            return true\n   \
      \     }\n    }\n    return false\n}"
    solutionNotes: |-
      Build a set from the first slice, then check if any element from the second slice exists in it. This is O(n+m) instead of O(n*m)!
    difficulty: 4
  - id: v6
    title: Find Intersection
    description: |-
      Write a function <code>func intersection(a, b []int) []int</code> that returns a slice of elements that appear in both input slices. Each element should appear only once in the result.
    functionSignature: func intersection(a, b []int) []int
    testCases:
    - input: '[]int{1, 2, 2, 1}, []int{2, 2}'
      output: '[2]'
    - input: '[]int{4, 9, 5}, []int{9, 4, 9, 8, 4}'
      output: '[9, 4]'
      note: or [4, 9] - order doesn't matter
    - input: '[]int{1, 2}, []int{3, 4}'
      output: '[]'
    solution: "func intersection(a, b []int) []int {\n    setA := make(map[int]bool)\n\
      \    for _, num := range a {\n        setA[num] = true\n    }\n    \n    result\
      \ := []int{}\n    seen := make(map[int]bool)\n    for _, num := range b {\n\
      \        if setA[num] && !seen[num] {\n            result = append(result, num)\n\
      \            seen[num] = true\n        }\n    }\n    return result\n}"
    solutionNotes: |-
      Similar to hasCommon, but we collect the common elements instead of just returning true. We use a second map to avoid adding duplicates to the result.
    difficulty: 4
  - id: v1
    title: Word Counter
    description: |-
      Write <code>func wordCount(s string) map[string]int</code> that counts how many times each word appears in a string.
    functionSignature: func wordCount(s string) map[string]int
    testCases:
    - input: '"the quick brown fox jumps over the lazy dog"'
      output: map[brown:1 dog:1 fox:1 jumps:1 lazy:1 over:1 quick:1 the:2]
    solution: |-
      import "strings"

      func wordCount(s string) map[string]int {
          counts := make(map[string]int)
          for _, word := range strings.Fields(s) {
              counts[word]++
          }
          return counts
      }
    difficulty: 4
  - id: v2
    title: Most Frequent Element
    description: |-
      Write <code>func mostFrequent(nums []int) int</code> that returns the element that appears most frequently. If there's a tie, return any of them.
    functionSignature: func mostFrequent(nums []int) int
    testCases:
    - input: '[]int{1, 3, 2, 1, 4, 1}'
      output: '1'
      note: 1 appears 3 times
    - input: '[]int{5, 5, 4, 4, 4}'
      output: '4'
    - input: '[]int{7}'
      output: '7'
    solution: "func mostFrequent(nums []int) int {\n    counts := make(map[int]int)\n\
      \    for _, num := range nums {\n        counts[num]++\n    }\n    \n    maxCount\
      \ := 0\n    result := nums[0]\n    for num, count := range counts {\n      \
      \  if count > maxCount {\n            maxCount = count\n            result =\
      \ num\n        }\n    }\n    return result\n}"
    solutionNotes: |-
      First count everything, then iterate the map to find the max. This is a two-pass approach over different data structures.
    difficulty: 4
  - id: v3
    title: First Unique Character
    description: |-
      Write <code>func firstUniqChar(s string) int</code> that returns the index of the first non-repeating character. Return -1 if none exists.
    functionSignature: func firstUniqChar(s string) int
    testCases:
    - input: '"leetcode"'
      output: '0'
      note: '''l'' is first unique'
    - input: '"loveleetcode"'
      output: '2'
      note: '''v'' is first unique'
    - input: '"aabb"'
      output: '-1'
    solution: "func firstUniqChar(s string) int {\n    counts := make(map[rune]int)\n\
      \    runes := []rune(s)\n    \n    for _, r := range runes {\n        counts[r]++\n\
      \    }\n    \n    for i, r := range runes {\n        if counts[r] == 1 {\n \
      \           return i\n        }\n    }\n    return -1\n}"
    solutionNotes: |-
      Two passes needed: first to count, second to find the first character with count == 1. We iterate the original string (not the map) to preserve order.
    difficulty: 4
  - id: v4
    title: Is Anagram
    description: |-
      Write <code>func isAnagram(s, t string) bool</code> that returns true if t is an anagram of s (same letters, different order).
    functionSignature: func isAnagram(s, t string) bool
    testCases:
    - input: '"anagram", "nagaram"'
      output: 'true'
    - input: '"rat", "car"'
      output: 'false'
    - input: '"listen", "silent"'
      output: 'true'
    solution: "func isAnagram(s, t string) bool {\n    if len(s) != len(t) {\n   \
      \     return false\n    }\n    \n    counts := make(map[rune]int)\n    for _,\
      \ r := range s {\n        counts[r]++\n    }\n    for _, r := range t {\n  \
      \      counts[r]--\n        if counts[r] < 0 {\n            return false\n \
      \       }\n    }\n    return true\n}"
    solutionNotes: |-
      Count characters in s (increment), then 'uncount' characters in t (decrement). If we ever go negative, t has a character s doesn't have.
    difficulty: 4
  - id: v5
    title: Can Construct
    description: |-
      Write <code>func canConstruct(ransomNote, magazine string) bool</code> that returns true if ransomNote can be constructed from magazine letters (each letter used once).
    functionSignature: func canConstruct(ransomNote, magazine string) bool
    testCases:
    - input: '"a", "b"'
      output: 'false'
    - input: '"aa", "aab"'
      output: 'true'
    - input: '"aa", "ab"'
      output: 'false'
      note: need 2 a's but only 1
    solution: "func canConstruct(ransomNote, magazine string) bool {\n    available\
      \ := make(map[rune]int)\n    \n    for _, r := range magazine {\n        available[r]++\n\
      \    }\n    \n    for _, r := range ransomNote {\n        available[r]--\n \
      \       if available[r] < 0 {\n            return false\n        }\n    }\n\
      \    return true\n}"
    solutionNotes: |-
      Similar to anagram check, but one-directional: we only need to verify ransomNote letters exist in magazine, not vice versa.
    difficulty: 4
  - id: v6
    title: Majority Element
    description: |-
      Write <code>func majorityElement(nums []int) int</code> that finds the element appearing more than n/2 times. Assume such element always exists.
    functionSignature: func majorityElement(nums []int) int
    testCases:
    - input: '[]int{3, 2, 3}'
      output: '3'
    - input: '[]int{2, 2, 1, 1, 1, 2, 2}'
      output: '2'
    - input: '[]int{1, 1, 1, 1}'
      output: '1'
    solution: "func majorityElement(nums []int) int {\n    counts := make(map[int]int)\n\
      \    threshold := len(nums) / 2\n    \n    for _, num := range nums {\n    \
      \    counts[num]++\n        if counts[num] > threshold {\n            return\
      \ num\n        }\n    }\n    return -1\n}"
    solutionNotes: |-
      We can return early as soon as any element exceeds n/2 count. No need to finish counting everything!
    difficulty: 4
- id: challenge_8
  block: 3
  difficulty: 3
  concept: Swap Pattern
  docLinks:
  - url: https://go.dev/ref/spec#Assignments
    title: 'Go Spec: Assignments'
    note: tuple assignment (a, b = b, a)
  - url: https://go.dev/ref/spec#Index_expressions
    title: 'Go Spec: Index expressions'
    note: slice indexing
  patternPrimer:
    bruteForce: 'Use a temp variable: temp = a, a = b, b = temp (three operations).'
    bestApproach: |-
      Go's simultaneous assignment: a, b = b, a (evaluates right side first, then assigns).
    typical: Typically O(1) time, O(1) extra space
  variants:
  - id: v1
    title: Swap Elements
    description: |-
      Write <code>func swap(nums []int, i, j int)</code> that swaps elements at i and j.
    functionSignature: func swap(nums []int, i, j int)
    testCases:
    - input: '[]int{1,2,3}, 0, 2'
      output: '[3,2,1]'
    hints:
    - title: Think about it
      content: |-
        How do you swap two values without losing one of them? Think about what happens if you just write a = b.
    - title: Hint
      content: |-
        Go has a special syntax for simultaneous assignment: a, b = b, a. This evaluates the right side first, then assigns, so nothing is lost.
    - title: Pattern
      content: |-
        <pre>1. Simultaneous assignment: left, right = right, left
        (Both sides evaluated before assignment - nothing lost!)</pre>
    solution: |-
      func swap(nums []int, i, j int) {
          nums[i], nums[j] = nums[j], nums[i]
      }
    difficulty: 1
  - id: v2
    title: Swap Using Temp
    description: |-
      Write <code>func swapWithTemp(nums []int, i, j int)</code> that swaps elements using a temporary variable (not Go's simultaneous assignment).
    functionSignature: func swapWithTemp(nums []int, i, j int)
    testCases:
    - input: '[]int{1,2,3,4}, 0, 3'
      output: '[4,2,3,1]'
    hints:
    - title: Think about it
      content: 'The classic 3-step swap: save one value, overwrite it, then use the
        saved value.'
    - title: Hint
      content: temp := nums[i], then nums[i] = nums[j], then nums[j] = temp.
    - title: Pattern
      content: |-
        <pre>1. temp := nums[i]  // save first value
        2. nums[i] = nums[j]  // overwrite with second
        3. nums[j] = temp  // put saved value in second spot</pre>
    solution: |-
      func swapWithTemp(nums []int, i, j int) {
          temp := nums[i]
          nums[i] = nums[j]
          nums[j] = temp
      }
    difficulty: 1
  - id: v3
    title: Swap Adjacent Pairs
    description: |-
      Write <code>func swapPairs(nums []int)</code> that swaps elements at indices 0&1, 2&3, 4&5, etc. If odd length, last element stays.
    functionSignature: func swapPairs(nums []int)
    testCases:
    - input: '[]int{1,2,3,4,5}'
      output: '[2,1,4,3,5]'
    - input: '[]int{1,2,3,4}'
      output: '[2,1,4,3]'
    hints:
    - title: Think about it
      content: |-
        How do you swap two values without losing one of them? Think about what happens if you just write a = b.
    - title: Hint
      content: |-
        Loop through the slice incrementing by 2 each time. Use Go's simultaneous assignment to swap pairs: nums[i], nums[i+1] = nums[i+1], nums[i].
    - title: Pattern
      content: |-
        <pre>1. Loop with i += 2
        2. Check i+1 < len to avoid out of bounds
        3. Swap: nums[i], nums[i+1] = nums[i+1], nums[i]</pre>
    solution: |-
      func swapPairs(nums []int) {
          for i := 0; i+1 < len(nums); i += 2 {
              nums[i], nums[i+1] = nums[i+1], nums[i]
          }
      }
    difficulty: 2
  - id: v4
    title: Swap First Two
    description: |-
      Write <code>func swapFirstTwo(nums []int)</code> that swaps the elements at index 0 and index 1. Assume slice has at least 2 elements.
    functionSignature: func swapFirstTwo(nums []int)
    testCases:
    - input: '[]int{1,2,3,4}'
      output: '[2,1,3,4]'
    - input: '[]int{5,10}'
      output: '[10,5]'
    hints:
    - title: Think about it
      content: This is just one swap - no loop needed. What indices do you need?
    - title: Hint
      content: Swap nums[0] and nums[1] using simultaneous assignment.
    - title: Pattern
      content: <pre>nums[0], nums[1] = nums[1], nums[0]</pre>
    solution: |-
      func swapFirstTwo(nums []int) {
          nums[0], nums[1] = nums[1], nums[0]
      }
    difficulty: 1
  - id: v5
    title: Swap Middle Two
    description: |-
      Write <code>func swapMiddle(nums []int)</code> that swaps the two middle elements. Assume even length.
    functionSignature: func swapMiddle(nums []int)
    testCases:
    - input: '[]int{1,2,3,4}'
      output: '[1,3,2,4]'
    - input: '[]int{10,20,30,40,50,60}'
      output: '[10,20,40,30,50,60]'
    hints:
    - title: Think about it
      content: For a slice of length n, the two middle elements are at indices n/2-1
        and n/2.
    - title: Hint
      content: Calculate mid := len(nums)/2. Then swap nums[mid-1] and nums[mid].
    - title: Pattern
      content: |-
        <pre>mid := len(nums) / 2
        nums[mid-1], nums[mid] = nums[mid], nums[mid-1]</pre>
    solution: |-
      func swapMiddle(nums []int) {
          mid := len(nums) / 2
          nums[mid-1], nums[mid] = nums[mid], nums[mid-1]
      }
    difficulty: 2
  - id: v6
    title: Swap at Offset
    description: |-
      Write <code>func swapAtOffset(nums []int, k int)</code> that swaps element at index k with element at index len-1-k (mirror positions from each end).
    functionSignature: func swapAtOffset(nums []int, k int)
    testCases:
    - input: '[]int{1,2,3,4,5}, 1'
      output: '[1,4,3,2,5]'
      note: swaps index 1 with index 3
    - input: '[]int{1,2,3,4,5}, 0'
      output: '[5,2,3,4,1]'
      note: swaps index 0 with index 4 (same as swapEnds)
    hints:
    - title: Think about it
      content: The mirror position of index k from the start is len-1-k from the end.
    - title: Hint
      content: Swap nums[k] with nums[len(nums)-1-k].
    - title: Pattern
      content: <pre>nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]</pre>
    solution: |-
      func swapAtOffset(nums []int, k int) {
          nums[k], nums[len(nums)-1-k] = nums[len(nums)-1-k], nums[k]
      }
    difficulty: 2
  - id: v7
    title: Swap Min and Max
    description: |-
      Write <code>func swapMinMax(nums []int)</code> that finds the minimum and maximum elements and swaps their positions.
    functionSignature: func swapMinMax(nums []int)
    testCases:
    - input: '[]int{3,1,4,1,5}'
      output: '[3,5,4,1,1]'
    - input: '[]int{5,2,8,1}'
      output: '[5,2,1,8]'
    hints:
    - title: Think about it
      content: |-
        First you need to find WHERE the min and max are (their indices), then swap the elements at those positions.
    - title: Hint
      content: |-
        Track minIdx and maxIdx as you loop. Start with both at 0. Update minIdx when you find a smaller value, maxIdx when you find a larger value. Then swap at the end.
    - title: Pattern
      content: |-
        <pre>1. Initialize minIdx = 0, maxIdx = 0
        2. Loop through slice:
           - nums[i] < nums[minIdx]? → minIdx = i
           - nums[i] > nums[maxIdx]? → maxIdx = i
        3. Swap: nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]</pre>
    solution: |-
      func swapMinMax(nums []int) {
          minIdx, maxIdx := 0, 0
          for i := range nums {
              if nums[i] < nums[minIdx] { minIdx = i }
              if nums[i] > nums[maxIdx] { maxIdx = i }
          }
          nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]
      }
    difficulty: 3
  - id: v8
    title: Rotate Left by One
    description: |-
      Write <code>func rotateLeft(nums []int)</code> that shifts all elements one position left, wrapping the first element to the end. E.g., [1,2,3,4] → [2,3,4,1].
    functionSignature: func rotateLeft(nums []int)
    testCases:
    - input: '[]int{1,2,3,4}'
      output: '[2,3,4,1]'
    - input: '[]int{5,10,15}'
      output: '[10,15,5]'
    hints:
    - title: Think about it
      content: |-
        You need to save the first element, shift everything left, then put the saved element at the end.
    - title: Hint
      content: |-
        Save first := nums[0]. Loop from i=0 to len-2, copying nums[i+1] to nums[i]. Finally set nums[len-1] = first.
    - title: Pattern
      content: |-
        <pre>1. Save first element: first := nums[0]
        2. Shift elements left: for i := 0; i < len-1; i++ → nums[i] = nums[i+1]
        3. Place first at end: nums[len-1] = first</pre>
    solution: |-
      func rotateLeft(nums []int) {
          if len(nums) == 0 { return }
          first := nums[0]
          for i := 0; i < len(nums)-1; i++ {
              nums[i] = nums[i+1]
          }
          nums[len(nums)-1] = first
      }
    difficulty: 2
  - id: v9
    title: Swap Halves
    description: |-
      Write <code>func swapHalves(nums []int)</code> that swaps the first half with the second half. For [1,2,3,4] → [3,4,1,2]. Assume even length.
    functionSignature: func swapHalves(nums []int)
    testCases:
    - input: '[]int{1,2,3,4}'
      output: '[3,4,1,2]'
    - input: '[]int{10,20,30,40,50,60}'
      output: '[40,50,60,10,20,30]'
    hints:
    - title: Think about it
      content: |-
        You need to swap element 0 with element n/2, element 1 with element n/2+1, etc. How many swaps is that?
    - title: Hint
      content: Loop from i=0 to len/2. Each iteration swaps nums[i] with nums[i +
        len/2].
    - title: Pattern
      content: |-
        <pre>1. Calculate mid := len(nums) / 2
        2. Loop i from 0 to mid:
           - Swap nums[i] with nums[i + mid]
        </pre>
    solution: |-
      func swapHalves(nums []int) {
          mid := len(nums) / 2
          for i := 0; i < mid; i++ {
              nums[i], nums[i+mid] = nums[i+mid], nums[i]
          }
      }
    difficulty: 2
  - id: v10
    title: Bubble Up
    description: |-
      Write <code>func bubbleUp(nums []int, idx int)</code> that 'bubbles' the element at idx towards the front by swapping with its left neighbor until it reaches index 0.
    functionSignature: func bubbleUp(nums []int, idx int)
    testCases:
    - input: '[]int{1,2,3,4}, 3'
      output: '[4,1,2,3]'
      note: 4 bubbles from idx 3 to idx 0
    - input: '[]int{5,10,15}, 1'
      output: '[10,5,15]'
      note: 10 bubbles from idx 1 to idx 0
    hints:
    - title: Think about it
      content: Start at idx and work backwards to 0, swapping adjacent elements each
        step.
    - title: Hint
      content: |-
        Loop from idx down to 1: for i := idx; i > 0; i--. Each iteration swap nums[i] with nums[i-1].
    - title: Pattern
      content: |-
        <pre>1. for i := idx; i > 0; i--
        2.   swap nums[i] and nums[i-1]
        (Element 'bubbles' left one position each iteration)</pre>
    solution: |-
      func bubbleUp(nums []int, idx int) {
          for i := idx; i > 0; i-- {
              nums[i], nums[i-1] = nums[i-1], nums[i]
          }
      }
    difficulty: 3
  - id: v11
    title: Swap If Out of Order
    description: |-
      Write <code>func swapIfGreater(nums []int, i, j int)</code> that swaps elements at i and j only if nums[i] > nums[j]. This is a building block for sorting!
    functionSignature: func swapIfGreater(nums []int, i, j int)
    testCases:
    - input: '[]int{5,2,8,1}, 0, 1'
      output: '[2,5,8,1]'
      note: 5 > 2, so swap
    - input: '[]int{1,5,3,4}, 0, 1'
      output: '[1,5,3,4]'
      note: 1 < 5, no swap
    hints:
    - title: Think about it
      content: Check if the first element is greater. If yes, swap. If no, do nothing.
    - title: Hint
      content: 'Use an if statement: if nums[i] > nums[j], then do the swap.'
    - title: Pattern
      content: |-
        <pre>if nums[i] > nums[j] {
            nums[i], nums[j] = nums[j], nums[i]
        }</pre>
    solution: |-
      func swapIfGreater(nums []int, i, j int) {
          if nums[i] > nums[j] {
              nums[i], nums[j] = nums[j], nums[i]
          }
      }
    difficulty: 2
  - id: v12
    title: Move to Front
    description: |-
      Write <code>func moveToFront(nums []int, idx int)</code> that moves the element at idx to the front, shifting other elements right. E.g., [1,2,3,4] with idx=2 → [3,1,2,4].
    functionSignature: func moveToFront(nums []int, idx int)
    testCases:
    - input: '[]int{1,2,3,4}, 2'
      output: '[3,1,2,4]'
    - input: '[]int{10,20,30,40}, 3'
      output: '[40,10,20,30]'
    hints:
    - title: Think about it
      content: |-
        Save the element at idx. Shift elements from 0 to idx-1 one position right. Put saved element at front.
    - title: Hint
      content: |-
        Save val := nums[idx]. Loop backwards from idx down to 1, copying nums[i-1] to nums[i]. Set nums[0] = val.
    - title: Pattern
      content: |-
        <pre>1. Save element: val := nums[idx]
        2. Shift right: for i := idx; i > 0; i-- → nums[i] = nums[i-1]
        3. Place at front: nums[0] = val</pre>
    solution: |-
      func moveToFront(nums []int, idx int) {
          val := nums[idx]
          for i := idx; i > 0; i-- {
              nums[i] = nums[i-1]
          }
          nums[0] = val
      }
    difficulty: 2
  - id: v1
    title: Reverse a String
    description: |-
      Write <code>func reverse(s string) string</code> that reverses any string, including Unicode characters like emojis.
    functionSignature: func reverse(s string) string
    testCases:
    - input: '"hello"'
      output: '"olleh"'
    - input: '"世界"'
      output: "\"ç\x95\x8Cä¸\x96\""
    - input: '"Go🚀"'
      output: '"🚀oG"'
    solution: |-
      func reverse(s string) string {
          runes := []rune(s)
          for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
              runes[i], runes[j] = runes[j], runes[i]
          }
          return string(runes)
      }
    difficulty: 4
  - id: v2
    title: Is Palindrome
    description: |-
      Write <code>func isPalindrome(s string) bool</code> that checks if a string reads the same forwards and backwards. Consider only alphanumeric characters and ignore case.
    functionSignature: func isPalindrome(s string) bool
    testCases:
    - input: '"A man, a plan, a canal: Panama"'
      output: 'true'
    - input: '"race a car"'
      output: 'false'
    - input: '"Was it a car or a cat I saw?"'
      output: 'true'
    solution: "import \"unicode\"\n\nfunc isPalindrome(s string) bool {\n    runes\
      \ := []rune{}\n    for _, r := range s {\n        if unicode.IsLetter(r) ||\
      \ unicode.IsDigit(r) {\n            runes = append(runes, unicode.ToLower(r))\n\
      \        }\n    }\n    \n    for i, j := 0, len(runes)-1; i < j; i, j = i+1,\
      \ j-1 {\n        if runes[i] != runes[j] {\n            return false\n     \
      \   }\n    }\n    return true\n}"
    solutionNotes: |-
      First filter to only alphanumeric and lowercase, then use two-pointer comparison. The <code>unicode</code> package helps with character classification.
    difficulty: 4
  - id: v3
    title: Reverse Words in String
    description: |-
      Write <code>func reverseWords(s string) string</code> that reverses the order of words (not characters). Words are separated by spaces.
    functionSignature: func reverseWords(s string) string
    testCases:
    - input: '"hello world"'
      output: '"world hello"'
    - input: '"the sky is blue"'
      output: '"blue is sky the"'
    - input: '"Go"'
      output: '"Go"'
    solution: "import \"strings\"\n\nfunc reverseWords(s string) string {\n    words\
      \ := strings.Fields(s)\n    \n    for i, j := 0, len(words)-1; i < j; i, j =\
      \ i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    \n\
      \    return strings.Join(words, \" \")\n}"
    solutionNotes: |-
      Use <code>strings.Fields</code> to split by whitespace, reverse the slice of words, then <code>strings.Join</code> back together.
    difficulty: 4
  - id: v4
    title: Reverse Only Letters
    description: |-
      Write <code>func reverseOnlyLetters(s string) string</code> that reverses only the letters in a string. All other characters stay in their original positions.
    functionSignature: func reverseOnlyLetters(s string) string
    testCases:
    - input: '"a-bC-dEf-ghIj"'
      output: '"j-Ih-gfE-dCba"'
    - input: '"ab-cd"'
      output: '"dc-ba"'
    - input: '"Test1ng-Leet=code-Q!"'
      output: '"Qedo1teleC-test=gnin-T!"'
      note: wait that's wrong
    solution: "import \"unicode\"\n\nfunc reverseOnlyLetters(s string) string {\n\
      \    runes := []rune(s)\n    i, j := 0, len(runes)-1\n    \n    for i < j {\n\
      \        for i < j && !unicode.IsLetter(runes[i]) {\n            i++\n     \
      \   }\n        for i < j && !unicode.IsLetter(runes[j]) {\n            j--\n\
      \        }\n        if i < j {\n            runes[i], runes[j] = runes[j], runes[i]\n\
      \            i++\n            j--\n        }\n    }\n    return string(runes)\n\
      }"
    solutionNotes: |-
      Two pointers that skip non-letters. Only swap when both pointers are on letters. This is a variation of the standard reverse with added skip logic.
    difficulty: 4
  - id: v5
    title: Valid Palindrome II
    description: |-
      Write <code>func validPalindromeII(s string) bool</code> that returns true if the string can become a palindrome by removing <strong>at most one</strong> character.
    functionSignature: func validPalindromeII(s string) bool
    testCases:
    - input: '"aba"'
      output: 'true'
      note: already palindrome
    - input: '"abca"'
      output: 'true'
      note: remove 'c' or 'b'
    - input: '"abc"'
      output: 'false'
    solution: "func validPalindromeII(s string) bool {\n    runes := []rune(s)\n \
      \   \n    isPalin := func(i, j int) bool {\n        for i < j {\n          \
      \  if runes[i] != runes[j] {\n                return false\n            }\n\
      \            i++\n            j--\n        }\n        return true\n    }\n \
      \   \n    i, j := 0, len(runes)-1\n    for i < j {\n        if runes[i] != runes[j]\
      \ {\n            return isPalin(i+1, j) || isPalin(i, j-1)\n        }\n    \
      \    i++\n        j--\n    }\n    return true\n}"
    solutionNotes: |-
      When we find a mismatch, we have one chance: try skipping the left char OR the right char. If either results in a palindrome, return true.
    difficulty: 4
  - id: v6
    title: Rotate String Left
    description: |-
      Write <code>func rotateLeft(s string, k int) string</code> that rotates a string left by k positions. Characters that fall off the left reappear on the right.
    functionSignature: func rotateLeft(s string, k int) string
    testCases:
    - input: '"abcdef", 2'
      output: '"cdefab"'
    - input: '"hello", 1'
      output: '"elloh"'
    - input: '"Go", 4'
      output: '"Go"'
      note: k=4 is same as k=0 for len=2
    solution: "func rotateLeft(s string, k int) string {\n    if len(s) == 0 {\n \
      \       return s\n    }\n    runes := []rune(s)\n    k = k % len(runes)\n  \
      \  \n    reverse := func(start, end int) {\n        for start < end {\n    \
      \        runes[start], runes[end] = runes[end], runes[start]\n            start++\n\
      \            end--\n        }\n    }\n    \n    reverse(0, k-1)\n    reverse(k,\
      \ len(runes)-1)\n    reverse(0, len(runes)-1)\n    \n    return string(runes)\n\
      }"
    solutionNotes: |-
      The "reversal algorithm" for rotation: reverse the first k elements, reverse the rest, then reverse the entire array. Three reversals achieve a rotation!
    difficulty: 4
- id: challenge_9
  block: 3
  difficulty: 3
  concept: Two-Pointer Comparison
  docLinks:
  - url: https://go.dev/ref/spec#For_statements
    title: 'Go Spec: For statements'
    note: two-variable initialization (i, j := ...)
  - url: https://go.dev/ref/spec#Comparison_operators
    title: 'Go Spec: Comparison operators'
    note: '!= for mismatch detection'
  patternPrimer:
    bruteForce: |-
      Create a reversed copy of the array, then compare element-by-element with the original.
    bestApproach: |-
      Compare from both ends simultaneously, moving inward; stop as soon as mismatch found.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Palindrome Check
    description: Write <code>func isPalindrome(nums []int) bool</code> - same forwards/backwards.
    functionSignature: func isPalindrome(nums []int) bool
    testCases:
    - input: '[]int{1,2,3,2,1}'
      output: 'true'
    hints:
    - title: Think about it
      content: |-
        To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?
    - title: Hint
      content: |-
        Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is.
    - title: Pattern
      content: |-
        <pre>1. left pointer at start, right pointer at end
        2. While left < right:
           - Compare elements at both pointers
           - Mismatch? → return false
           - Move both pointers inward
        3. Return true (all pairs matched)</pre>
    solution: |-
      func isPalindrome(nums []int) bool {
          for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
              if nums[i] != nums[j] { return false }
          }
          return true
      }
    difficulty: 3
  - id: v2
    title: String Palindrome
    description: Write <code>func isSymmetric(s string) bool</code>.
    functionSignature: func isSymmetric(s string) bool
    testCases:
    - input: '"racecar"'
      output: 'true'
    hints:
    - title: Think about it
      content: |-
        To check if something reads the same forwards and backwards, where should you start comparing? Do you need to check every element?
    - title: Hint
      content: |-
        Compare from both ends moving inward. Start with pointers at index 0 and len-1. If any pair doesn't match, it's not a palindrome. If you make it to the middle without mismatches, it is.
    - title: Pattern
      content: |-
        <pre>1. left pointer at start, right pointer at end
        2. While left < right:
           - Compare elements at both pointers
           - Mismatch? → return false
           - Move both pointers inward
        3. Return true (all pairs matched)</pre>
    solution: |-
      func isSymmetric(s string) bool {
          r := []rune(s)
          for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
              if r[i] != r[j] { return false }
          }
          return true
      }
    difficulty: 3
  - id: v3
    title: Is Sorted Ascending
    description: |-
      Write <code>func isSorted(nums []int) bool</code> - true if each element <= the next.
    functionSignature: func isSorted(nums []int) bool
    testCases:
    - input: '[]int{1,2,3,4}'
      output: 'true'
    - input: '[]int{1,3,2,4}'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        To verify sorted order, what pairs of elements do you need to compare? Do you need to compare every element to every other element?
    - title: Hint
      content: |-
        Check adjacent pairs: compare nums[i] with nums[i+1]. If any pair is out of order (nums[i] > nums[i+1]), return false immediately.
    - title: Pattern
      content: |-
        <pre>1. Loop through indices 0 to len-2
        2. Compare each element with the next
        3. If nums[i] > nums[i+1] → return false
        4. Return true (all pairs in order)</pre>
    solution: |-
      func isSorted(nums []int) bool {
          for i := 0; i < len(nums)-1; i++ {
              if nums[i] > nums[i+1] { return false }
          }
          return true
      }
    difficulty: 2
  - id: v4
    title: Has Adjacent Duplicates
    description: |-
      Write <code>func hasAdjacentDups(nums []int) bool</code> - true if any two adjacent elements are equal.
    functionSignature: func hasAdjacentDups(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 2, 3}'
      output: 'true'
    - input: '[]int{1, 2, 3, 4}'
      output: 'false'
    hints:
    - title: Think about it
      content: You need to compare each element with its neighbor. What pairs should
        you check?
    - title: Hint
      content: |-
        Loop through indices 0 to len-2. Compare nums[i] with nums[i+1]. If they're equal, you found adjacent duplicates.
    - title: Pattern
      content: |-
        <pre>1. Loop through indices 0 to len-2
        2. Compare each element with the next
        3. If nums[i] == nums[i+1] → return true
        4. Return false (no adjacent duplicates)</pre>
    solution: |-
      func hasAdjacentDups(nums []int) bool {
          for i := 0; i < len(nums)-1; i++ {
              if nums[i] == nums[i+1] { return true }
          }
          return false
      }
    difficulty: 2
  - id: v5
    title: All Increasing
    description: |-
      Write <code>func allIncreasing(nums []int) bool</code> - true if strictly increasing (each element < next).
    functionSignature: func allIncreasing(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: 'true'
    - input: '[]int{1, 2, 2, 3}'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        Strictly increasing means each element must be LESS than (not equal to) the next.
    - title: Hint
      content: Compare adjacent pairs. If nums[i] >= nums[i+1], it's not strictly
        increasing.
    - title: Pattern
      content: |-
        <pre>1. Loop through indices 0 to len-2
        2. Compare each element with the next
        3. If nums[i] >= nums[i+1] → return false
        4. Return true (all strictly increasing)</pre>
    solution: |-
      func allIncreasing(nums []int) bool {
          for i := 0; i < len(nums)-1; i++ {
              if nums[i] >= nums[i+1] { return false }
          }
          return true
      }
    difficulty: 2
  - id: v6
    title: Starts And Ends Same
    description: |-
      Write <code>func startsEndsSame(nums []int, k int) bool</code> - true if first k elements match last k elements.
    functionSignature: func startsEndsSame(nums []int, k int) bool
    testCases:
    - input: '[]int{1, 2, 3, 1, 2}, 2'
      output: 'true'
    - input: '[]int{1, 2, 3, 4, 5}, 2'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        You need to compare the first k elements with the last k elements. What are the corresponding indices?
    - title: Hint
      content: Element at index i should match element at index len-k+i. Check all
        k pairs.
    - title: Pattern
      content: |-
        <pre>1. Loop i from 0 to k-1
        2. Compare nums[i] with nums[len-k+i]
        3. If mismatch → return false
        4. Return true (all pairs match)</pre>
    solution: |-
      func startsEndsSame(nums []int, k int) bool {
          n := len(nums)
          for i := 0; i < k; i++ {
              if nums[i] != nums[n-k+i] { return false }
          }
          return true
      }
    difficulty: 1
  - id: v7
    title: Mirror Halves
    description: |-
      Write <code>func mirrorHalves(nums []int) bool</code> - true if first half mirrors second half. Assume even length.
    functionSignature: func mirrorHalves(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 2, 1}'
      output: 'true'
    - input: '[]int{5, 3, 3, 5}'
      output: 'true'
    - input: '[]int{1, 2, 3, 4}'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        Compare first half with second half in reverse. Element at index i should match element at index n-1-i.
    - title: Hint
      content: |-
        Use two pointers starting at both ends, moving inward. Compare only the first n/2 pairs.
    - title: Pattern
      content: |-
        <pre>1. left = 0, right = len-1
        2. While left < right:
           - nums[left] != nums[right]? → return false
           - left++, right--
        3. Return true</pre>
    solution: |-
      func mirrorHalves(nums []int) bool {
          for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
              if nums[i] != nums[j] { return false }
          }
          return true
      }
    difficulty: 2
  - id: v8
    title: Valid Score Sequence
    description: |-
      Write <code>func validScoreSeq(scores []int) bool</code> - true if scores never decrease by more than 10 points between adjacent rounds.
    functionSignature: func validScoreSeq(scores []int) bool
    testCases:
    - input: '[]int{100, 95, 98, 90}'
      output: 'true'
    - input: '[]int{100, 85, 90}'
      output: 'false'
      note: 100 to 85 is -15
    hints:
    - title: Think about it
      content: Compare adjacent scores. If any drop is more than 10, return false.
    - title: Hint
      content: |-
        Loop through indices, compare scores[i] with scores[i+1]. Check if scores[i] - scores[i+1] > 10.
    - title: Pattern
      content: |-
        <pre>1. For i from 0 to len-2:
           - scores[i] - scores[i+1] > 10?
             → return false
        2. Return true</pre>
    solution: |-
      func validScoreSeq(scores []int) bool {
          for i := 0; i < len(scores)-1; i++ {
              if scores[i] - scores[i+1] > 10 { return false }
          }
          return true
      }
    difficulty: 2
  - id: v9
    title: Balanced Brackets
    description: |-
      Write <code>func balancedBrackets(s string) bool</code> - true if string has equal '[' and ']' counts AND they're balanced left-to-right.
    functionSignature: func balancedBrackets(s string) bool
    testCases:
    - input: '"[[][]]"'
      output: 'true'
    - input: '"[[]"'
      output: 'false'
    - input: '"][["'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        Track a running count: +1 for '[', -1 for ']'. Count should never go negative, and should be 0 at end.
    - title: Hint
      content: |-
        Use a counter variable. If it ever goes negative, we have ']' before matching '['. Must end at 0.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each char:
           - '[' → count++
           - ']' → count--
           - count < 0? → return false
        3. Return count == 0</pre>
    solution: |-
      func balancedBrackets(s string) bool {
          count := 0
          for _, c := range s {
              if c == '[' { count++ }
              if c == ']' { count-- }
              if count < 0 { return false }
          }
          return count == 0
      }
    difficulty: 3
  - id: v10
    title: First Last Equal
    description: |-
      Write <code>func firstLastEqual(nums []int) bool</code> - true if first element equals last element.
    functionSignature: func firstLastEqual(nums []int) bool
    testCases:
    - input: '[]int{5, 2, 3, 5}'
      output: 'true'
    - input: '[]int{1, 2, 3}'
      output: 'false'
    hints:
    - title: Think about it
      content: You need to compare the first and last elements. What are their indices?
    - title: Hint
      content: |-
        First element is at index 0, last is at index len(nums)-1. Just compare them directly.
    - title: Pattern
      content: |-
        <pre>1. Get first element: nums[0]
        2. Get last element: nums[len(nums)-1]
        3. Return whether they're equal</pre>
    solution: |-
      func firstLastEqual(nums []int) bool {
          if len(nums) == 0 { return true }
          return nums[0] == nums[len(nums)-1]
      }
    difficulty: 1
  - id: v11
    title: No Decreases
    description: |-
      Write <code>func noDecreases(nums []int) bool</code> - true if array never decreases (each element >= previous). Adjacent pair comparison.
    functionSignature: func noDecreases(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 2, 3}'
      output: 'true'
    - input: '[]int{1, 3, 2, 4}'
      output: 'false'
      note: 3→2 is a decrease
    hints:
    - title: Think about it
      content: 'Check adjacent pairs: each element should be >= the one before it.'
    - title: Hint
      content: |-
        Loop from index 1 onwards. Compare nums[i] with nums[i-1]. If nums[i] < nums[i-1], return false.
    - title: Pattern
      content: |-
        <pre>1. For i from 1 to len:
           - If nums[i] < nums[i-1] → return false
        2. Return true</pre>
    solution: |-
      func noDecreases(nums []int) bool {
          for i := 1; i < len(nums); i++ {
              if nums[i] < nums[i-1] { return false }
          }
          return true
      }
    difficulty: 1
  - id: v12
    title: Sum Symmetry
    description: |-
      Write <code>func sumSymmetry(nums []int) bool</code> - true if sum of first half equals sum of second half. Assume even length. Two-pointer to compare halves.
    functionSignature: func sumSymmetry(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 3, 3, 2, 1}'
      output: 'true'
      note: 1+2+3 = 3+2+1
    - input: '[]int{1, 2, 3, 4}'
      output: 'false'
      note: "1+2 â\x89  3+4"
    hints:
    - title: Think about it
      content: Calculate sum of first half, then sum of second half, then compare.
    - title: Hint
      content: |-
        Loop from 0 to mid to get first sum. Loop from mid to end to get second sum. Compare them.
    - title: Pattern
      content: |-
        <pre>1. mid := len/2
        2. sum1 := sum of nums[0:mid]
        3. sum2 := sum of nums[mid:]
        4. Return sum1 == sum2</pre>
    solution: |-
      func sumSymmetry(nums []int) bool {
          mid := len(nums) / 2
          sum1, sum2 := 0, 0
          for i := 0; i < mid; i++ {
              sum1 += nums[i]
          }
          for i := mid; i < len(nums); i++ {
              sum2 += nums[i]
          }
          return sum1 == sum2
      }
    difficulty: 1
  - id: v13
    title: Distance Increasing
    description: |-
      Write <code>func distanceIncreasing(nums []int) bool</code> - true if distance between adjacent elements is always increasing. Distance = abs(nums[i] - nums[i-1]).
    functionSignature: func distanceIncreasing(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 5, 10}'
      output: 'true'
      note: 'Distances: 1, 3, 5 (increasing)'
    - input: '[]int{1, 3, 4, 8}'
      output: 'false'
      note: 'Distances: 2, 1, 4 (not increasing)'
    hints:
    - title: Think about it
      content: |-
        Calculate distance between each adjacent pair. Check if distances form an increasing sequence.
    - title: Hint
      content: |-
        Track previous distance. For each pair, calculate current distance, compare with previous, update previous.
    - title: Pattern
      content: |-
        <pre>1. prevDist := first pair distance
        2. For each subsequent pair:
           - Calculate currDist
           - If currDist <= prevDist → return false
           - prevDist = currDist
        3. Return true</pre>
    solution: |-
      func distanceIncreasing(nums []int) bool {
          if len(nums) < 3 { return true }
          abs := func(x int) int {
              if x < 0 { return -x }
              return x
          }
          prevDist := abs(nums[1] - nums[0])
          for i := 2; i < len(nums); i++ {
              currDist := abs(nums[i] - nums[i-1])
              if currDist <= prevDist { return false }
              prevDist = currDist
          }
          return true
      }
    difficulty: 1
  - id: v1
    title: Maximum Sum Subarray of Size K
    description: |-
      Given an array of integers and a number k, find the maximum sum of any contiguous subarray of size k. <code>func maxSumSubarray(nums []int, k int) int</code>
    functionSignature: func maxSumSubarray(nums []int, k int) int
    testCases:
    - input: '[]int{2, 1, 5, 1, 3, 2}, 3'
      output: '9'
      note: subarray [5,1,3]
    - input: '[]int{2, 3, 4, 1, 5}, 2'
      output: '7'
      note: subarray [3,4]
    - input: '[]int{1, 1, 1, 1}, 2'
      output: '2'
    solution: "func maxSumSubarray(nums []int, k int) int {\n    if len(nums) < k\
      \ {\n        return 0\n    }\n    windowSum := 0\n    for i := 0; i < k; i++\
      \ {\n        windowSum += nums[i]\n    }\n    maxSum := windowSum\n    \n  \
      \  for i := k; i < len(nums); i++ {\n        windowSum += nums[i] - nums[i-k]\n\
      \        if windowSum > maxSum {\n            maxSum = windowSum\n        }\n\
      \    }\n    return maxSum\n}"
    solutionNotes: |-
      Fixed-size window: calculate first window sum, then slide by adding new element and subtracting leaving element. O(n) time, O(1) space.
    difficulty: 4
  - id: v2
    title: Longest Substring Without Repeating
    description: |-
      Find the length of the longest substring without repeating characters. <code>func lengthOfLongestSubstring(s string) int</code>
    functionSignature: func lengthOfLongestSubstring(s string) int
    testCases:
    - input: '"abcabcbb"'
      output: '3'
      note: '"abc"'
    - input: '"bbbbb"'
      output: '1'
      note: '"b"'
    - input: '"pwwkew"'
      output: '3'
      note: '"wke"'
    solution: "func lengthOfLongestSubstring(s string) int {\n    seen := make(map[byte]int)\n\
      \    maxLen := 0\n    left := 0\n    \n    for right := 0; right < len(s); right++\
      \ {\n        char := s[right]\n        if lastIdx, ok := seen[char]; ok && lastIdx\
      \ >= left {\n            left = lastIdx + 1\n        }\n        seen[char] =\
      \ right\n        if right - left + 1 > maxLen {\n            maxLen = right\
      \ - left + 1\n        }\n    }\n    return maxLen\n}"
    solutionNotes: |-
      Variable-size window: expand right, shrink left when duplicate found. Track last seen index of each character to know where to shrink to.
    difficulty: 4
  - id: v3
    title: Minimum Size Subarray Sum
    description: |-
      Find the minimal length of a contiguous subarray whose sum is >= target. Return 0 if no such subarray. <code>func minSubarrayLen(target int, nums []int) int</code>
    functionSignature: func minSubarrayLen(target int, nums []int) int
    testCases:
    - input: 7, []int{2, 3, 1, 2, 4, 3}
      output: '2'
      note: '[4,3] sums to 7'
    - input: 4, []int{1, 4, 4}
      output: '1'
      note: '[4] alone >= 4'
    - input: 11, []int{1, 1, 1, 1}
      output: '0'
      note: can't reach 11
    solution: "func minSubarrayLen(target int, nums []int) int {\n    minLen := len(nums)\
      \ + 1\n    left := 0\n    sum := 0\n    \n    for right := 0; right < len(nums);\
      \ right++ {\n        sum += nums[right]\n        \n        for sum >= target\
      \ {\n            if right - left + 1 < minLen {\n                minLen = right\
      \ - left + 1\n            }\n            sum -= nums[left]\n            left++\n\
      \        }\n    }\n    \n    if minLen == len(nums) + 1 {\n        return 0\n\
      \    }\n    return minLen\n}"
    solutionNotes: |-
      Variable-size window with condition: expand to increase sum, shrink while condition met to find minimum. Classic 'minimum window' pattern.
    difficulty: 4
  - id: v4
    title: Average of Subarrays of Size K
    description: |-
      Given an array, find the average of all contiguous subarrays of size k. <code>func averageOfSubarrays(nums []int, k int) []float64</code>
    functionSignature: func averageOfSubarrays(nums []int, k int) []float64
    testCases:
    - input: '[]int{1, 3, 2, 6, -1, 4, 1, 8, 2}, 5'
      output: '[2.2, 2.8, 2.4, 3.6, 2.8]'
    - input: '[]int{1, 2, 3, 4}, 2'
      output: '[1.5, 2.5, 3.5]'
    solution: "func averageOfSubarrays(nums []int, k int) []float64 {\n    result\
      \ := []float64{}\n    windowSum := 0\n    \n    for i := 0; i < len(nums); i++\
      \ {\n        windowSum += nums[i]\n        \n        if i >= k-1 {\n       \
      \     result = append(result, float64(windowSum)/float64(k))\n            windowSum\
      \ -= nums[i-k+1]\n        }\n    }\n    return result\n}"
    solutionNotes: |-
      Basic fixed-window pattern. Build up sum for first k elements, then slide and track averages.
    difficulty: 4
  - id: v5
    title: Contains Duplicate Within K Distance
    description: |-
      Return true if there are two distinct indices i and j where nums[i] == nums[j] and abs(i - j) <= k. <code>func containsNearbyDuplicate(nums []int, k int) bool</code>
    functionSignature: func containsNearbyDuplicate(nums []int, k int) bool
    testCases:
    - input: '[]int{1, 2, 3, 1}, 3'
      output: 'true'
    - input: '[]int{1, 0, 1, 1}, 1'
      output: 'true'
    - input: '[]int{1, 2, 3, 1, 2, 3}, 2'
      output: 'false'
    solution: "func containsNearbyDuplicate(nums []int, k int) bool {\n    seen :=\
      \ make(map[int]bool)\n    \n    for i, num := range nums {\n        if seen[num]\
      \ {\n            return true\n        }\n        seen[num] = true\n        \n\
      \        if i >= k {\n            delete(seen, nums[i-k])\n        }\n    }\n\
      \    return false\n}"
    solutionNotes: |-
      Maintain a sliding window of size k as a set. If we see a duplicate within the window, return true. Remove elements that leave the window.
    difficulty: 4
  - id: v6
    title: Max Consecutive Ones III
    description: |-
      Given a binary array and integer k, return the maximum number of consecutive 1's if you can flip at most k 0's. <code>func longestOnes(nums []int, k int) int</code>
    functionSignature: func longestOnes(nums []int, k int) int
    testCases:
    - input: '[]int{1,1,1,0,0,0,1,1,1,1,0}, 2'
      output: '6'
      note: flip 0's at indices 5 and 10
    - input: '[]int{0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1}, 3'
      output: '10'
    solution: "func longestOnes(nums []int, k int) int {\n    left := 0\n    zeros\
      \ := 0\n    maxLen := 0\n    \n    for right := 0; right < len(nums); right++\
      \ {\n        if nums[right] == 0 {\n            zeros++\n        }\n       \
      \ \n        for zeros > k {\n            if nums[left] == 0 {\n            \
      \    zeros--\n            }\n            left++\n        }\n        \n     \
      \   if right - left + 1 > maxLen {\n            maxLen = right - left + 1\n\
      \        }\n    }\n    return maxLen\n}"
    solutionNotes: |-
      Variable window: expand right, count zeros. When zeros > k, shrink from left. Track maximum valid window size.
    difficulty: 4
- id: challenge_10
  block: 4
  difficulty: 4
  concept: Two-Pointer Swap
  docLinks:
  - url: https://go.dev/ref/spec#Assignments
    title: 'Go Spec: Assignments'
    note: simultaneous swap (a, b = b, a)
  - url: https://go.dev/blog/slices
    title: 'Go Blog: Slices'
    note: in-place modifications
  patternPrimer:
    bruteForce: Create a new array and build it by iterating backwards through the
      original.
    bestApproach: |-
      Start pointers at both ends, swap elements in place, move pointers inward until they meet.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Reverse Slice
    description: Write <code>func reverse(nums []int) []int</code> that reverses in
      place.
    functionSignature: func reverse(nums []int) []int
    testCases:
    - input: '[]int{1,2,3,4,5}'
      output: '[5,4,3,2,1]'
    hints:
    - title: Think about it
      content: |-
        To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?
    - title: Hint
      content: |-
        Use the same two-pointer loop as palindrome check, but swap the elements instead of comparing them. Stop when the pointers meet or cross.
    - title: Pattern
      content: |-
        <pre>1. left pointer at start, right pointer at end
        2. While left < right:
           - Swap elements at left and right
           - Move both pointers inward
        3. Done (reversed in place)</pre>
    solution: |-
      func reverse(nums []int) []int {
          for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
              nums[i], nums[j] = nums[j], nums[i]
          }
          return nums
      }
    difficulty: 3
  - id: v2
    title: Reverse String
    description: Write <code>func reverseString(s string) string</code> that reverses
      a string.
    functionSignature: func reverseString(s string) string
    testCases:
    - input: '"hello"'
      output: '"olleh"'
    - input: '"Go"'
      output: '"oG"'
    hints:
    - title: Think about it
      content: |-
        To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?
    - title: Hint
      content: |-
        Convert to []rune first (strings are immutable). Then use the same two-pointer swap as with slices.
    - title: Pattern
      content: |-
        <pre>1. Convert string to []rune
        2. left pointer at start, right pointer at end
        3. While left < right:
           - Swap runes at left and right
           - Move both pointers inward
        4. Convert back to string</pre>
    solution: |-
      func reverseString(s string) string {
          r := []rune(s)
          for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
              r[i], r[j] = r[j], r[i]
          }
          return string(r)
      }
    difficulty: 3
  - id: v3
    title: Reverse Segment
    description: |-
      Write <code>func reverseSegment(nums []int, start, end int)</code> that reverses elements from index start to end (inclusive).
    functionSignature: func reverseSegment(nums []int, start, end int)
    testCases:
    - input: '[]int{1,2,3,4,5}, 1, 3'
      output: '[1,4,3,2,5]'
    hints:
    - title: Think about it
      content: |-
        To reverse in-place, you swap elements from both ends working toward the middle. What pattern lets you walk two pointers toward each other?
    - title: Hint
      content: |-
        Same two-pointer pattern, but start at 'start' instead of 0, and end at 'end' instead of len-1.
    - title: Pattern
      content: |-
        <pre>1. left pointer at start, right pointer at end
        2. While left < right:
           - Swap elements at left and right
           - Move both pointers inward
        3. Done (segment reversed in place)</pre>
    solution: |-
      func reverseSegment(nums []int, start, end int) {
          for i, j := start, end; i < j; i, j = i+1, j-1 {
              nums[i], nums[j] = nums[j], nums[i]
          }
      }
    difficulty: 3
  - id: v4
    title: Swap First and Last
    description: |-
      Write <code>func swapEnds(nums []int) []int</code> that swaps the first and last elements.
    functionSignature: func swapEnds(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '[5, 2, 3, 4, 1]'
    hints:
    - title: Think about it
      content: You only need to swap two specific elements. What are their indices?
    - title: Hint
      content: |-
        First element is at index 0, last is at index len-1. Use Go's simultaneous assignment to swap.
    - title: Pattern
      content: |-
        <pre>1. Identify indices: first = 0, last = len-1
        2. Swap: nums[0], nums[last] = nums[last], nums[0]
        3. Return the modified slice</pre>
    solution: |-
      func swapEnds(nums []int) []int {
          n := len(nums)
          nums[0], nums[n-1] = nums[n-1], nums[0]
          return nums
      }
    difficulty: 2
  - id: v5
    title: Rotate Right by One
    description: |-
      Write <code>func rotateRight(nums []int) []int</code> that moves the last element to the front.
    functionSignature: func rotateRight(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '[5, 1, 2, 3, 4]'
    hints:
    - title: Think about it
      content: |-
        The last element goes to index 0, and all other elements shift right by one position.
    - title: Hint
      content: |-
        Save the last element. Then loop backwards, shifting each element to the right. Finally place the saved element at index 0.
    - title: Pattern
      content: |-
        <pre>1. Save last element: temp = nums[len-1]
        2. Shift all elements right: nums[i] = nums[i-1]
        3. Place saved element at front: nums[0] = temp</pre>
    solution: |-
      func rotateRight(nums []int) []int {
          n := len(nums)
          last := nums[n-1]
          for i := n-1; i > 0; i-- {
              nums[i] = nums[i-1]
          }
          nums[0] = last
          return nums
      }
    difficulty: 2
  - id: v6
    title: Mirror Slice
    description: |-
      Write <code>func mirror(nums []int) []int</code> that makes the second half mirror the first half. For [1,2,3,4] → [1,2,2,1].
    functionSignature: func mirror(nums []int) []int
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: '[1, 2, 2, 1]'
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '[1, 2, 3, 2, 1]'
    hints:
    - title: Think about it
      content: |-
        You need to copy elements from the first half to matching positions in the second half.
    - title: Hint
      content: |-
        Use two pointers: one from start, one from end. Copy nums[i] to nums[j] as long as i < j.
    - title: Pattern
      content: |-
        <pre>1. left pointer at 0, right pointer at len-1
        2. While left < right:
           - Copy nums[left] to nums[right]
           - Move both pointers inward
        3. Return modified slice</pre>
    solution: |-
      func mirror(nums []int) []int {
          for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
              nums[j] = nums[i]
          }
          return nums
      }
    difficulty: 3
  - id: v7
    title: Swap Ends Only
    difficulty: 1
    description: |-
      Write <code>func swapEnds(nums []int)</code> that swaps ONLY the first and last elements. Modify the slice in place.
    functionSignature: func swapEnds(nums []int)
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}'
      output: '[5, 2, 3, 4, 1]'
      note: Only first and last swapped
    - input: '[]int{10, 20}'
      output: '[20, 10]'
    hints:
    - title: Think about it
      content: This is just a single swap operation - no loop needed!
    - title: Hint
      content: Swap nums[0] and nums[len(nums)-1] using Go's simultaneous assignment.
    - title: Pattern
      content: <pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>
    solution: |-
      func swapEnds(nums []int) {
          if len(nums) > 1 {
              nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]
          }
      }
  - id: v8
    title: Reverse First N
    difficulty: 1
    description: |-
      Write <code>func reverseFirstN(nums []int, n int)</code> that reverses only the first n elements using two pointers.
    functionSignature: func reverseFirstN(nums []int, n int)
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}, 3'
      output: '[3, 2, 1, 4, 5]'
      note: Only first 3 elements reversed
    - input: '[]int{10, 20, 30, 40}, 2'
      output: '[20, 10, 30, 40]'
    hints:
    - title: Think about it
      content: |-
        This is like reversing a slice, but you only go up to position n instead of the end.
    - title: Hint
      content: |-
        Use two pointers: left starts at 0, right starts at n-1 (not len-1!). Swap and move inward until they meet.
    - title: Pattern
      content: |-
        <pre>1. left := 0, right := n-1
        2. While left < right:
           - Swap nums[left] and nums[right]
           - left++, right--</pre>
    solution: |-
      func reverseFirstN(nums []int, n int) {
          if n > len(nums) {
              n = len(nums)
          }
          left, right := 0, n-1
          for left < right {
              nums[left], nums[right] = nums[right], nums[left]
              left++
              right--
          }
      }
  - id: v9
    title: Move Zeros to End
    description: |-
      Write <code>func moveZeros(nums []int) []int</code> that moves all zeros to the end, preserving order of non-zeros.
    functionSignature: func moveZeros(nums []int) []int
    testCases:
    - input: '[]int{0, 1, 0, 3, 12}'
      output: '[]int{1, 3, 12, 0, 0}'
    - input: '[]int{0, 0, 1}'
      output: '[]int{1, 0, 0}'
    hints:
    - title: Think about it
      content: Collect all non-zero elements first, then append zeros to fill the
        rest.
    - title: Hint
      content: Filter non-zeros into result, then append len(nums) - len(result) zeros.
    - title: Pattern
      content: |-
        <pre>1. result := []int{}
        2. For each num:
           - num != 0? → append to result
        3. While len(result) < len(nums):
           - append 0
        4. Return result</pre>
    solution: |-
      func moveZeros(nums []int) []int {
          result := []int{}
          for _, num := range nums {
              if num != 0 {
                  result = append(result, num)
              }
          }
          for len(result) < len(nums) {
              result = append(result, 0)
          }
          return result
      }
    difficulty: 2
  - id: v10
    title: Reverse Words in Place
    description: |-
      Write <code>func reverseWords(words []string)</code> that reverses the order of words in the slice in-place.
    functionSignature: func reverseWords(words []string)
    testCases:
    - input: '[]string{"hello", "world", "go"}'
      output: '["go", "world", "hello"]'
    - input: '[]string{"a", "b"}'
      output: '["b", "a"]'
    hints:
    - title: Think about it
      content: 'Two-pointer swap pattern: swap from both ends moving toward center.'
    - title: Hint
      content: left starts at 0, right at len-1. Swap and move inward until they meet.
    - title: Pattern
      content: "<pre>1. left = 0, right = len-1\n2. While left < right:\n   - Swap\
        \ words[left] â\x86\x94 words[right]\n   - left++, right--</pre>"
    solution: |-
      func reverseWords(words []string) {
          for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
              words[i], words[j] = words[j], words[i]
          }
      }
    difficulty: 2
  - id: v11
    title: Reverse Outer Pairs
    difficulty: 1
    description: "Write <code>func reverseOuterPairs(nums []int, k int)</code> that\
      \ swaps k pairs from both ends: swap nums[0]â\x86\x94nums[len-1], nums[1]â\x86\
      \x94nums[len-2], ..., k times. Two-pointer inward movement."
    functionSignature: func reverseOuterPairs(nums []int, k int)
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6}, 2'
      output: '[6, 5, 3, 4, 2, 1]'
      note: Swap 2 pairs from ends
    - input: '[]int{1, 2, 3, 4}, 1'
      output: '[4, 2, 3, 1]'
    hints:
    - title: Think about it
      content: Start with pointers at both ends. Swap, move both inward, repeat k
        times.
    - title: Hint
      content: |-
        left = 0, right = len-1. Loop k times: swap nums[left] with nums[right], then left++, right--.
    - title: Pattern
      content: "<pre>1. left := 0, right := len-1\n2. For i from 0 to k:\n   - Swap\
        \ nums[left] â\x86\x94 nums[right]\n   - left++, right--</pre>"
    solution: |-
      func reverseOuterPairs(nums []int, k int) {
          left, right := 0, len(nums)-1
          for i := 0; i < k && left < right; i++ {
              nums[left], nums[right] = nums[right], nums[left]
              left++
              right--
          }
      }
  - id: v12
    title: Outer to Inner Copy
    difficulty: 1
    description: |-
      Write <code>func outerToInner(nums []int)</code> that copies outer elements to inner positions moving inward: [1,2,3,4,5,6] → [1,1,6,6,5,6]. Two pointers copy inward.
    functionSignature: func outerToInner(nums []int)
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6}'
      output: '[1, 1, 6, 6, 5, 6]'
      note: Outer values copy toward center
    - input: '[]int{10, 20, 30, 40}'
      output: '[10, 10, 40, 40]'
    hints:
    - title: Think about it
      content: |-
        Start pointers at ends. Copy the outer values to the next inner positions, move inward.
    - title: Hint
      content: |-
        left = 0, right = len-1. While left < right-1: save outer values, move pointers inward, write saved values.
    - title: Pattern
      content: |-
        <pre>1. left := 0, right := len-1
        2. While left < right-1:
           - Copy nums[left] to nums[left+1]
           - Copy nums[right] to nums[right-1]
           - left++, right--</pre>
    solution: |-
      func outerToInner(nums []int) {
          left, right := 0, len(nums)-1
          for left < right-1 {
              leftVal, rightVal := nums[left], nums[right]
              left++
              right--
              nums[left] = leftVal
              nums[right] = rightVal
          }
      }
  - id: v13
    title: Reverse Alternating Pairs
    difficulty: 1
    description: "Write <code>func reverseAlternating(nums []int)</code> that reverses\
      \ every other pair from outside in: swap positions 0â\x86\x94last, skip next\
      \ pair, swap 2â\x86\x94(last-2), etc. Two pointers with conditional swapping."
    functionSignature: func reverseAlternating(nums []int)
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6, 7, 8}'
      output: '[8, 2, 7, 4, 5, 6, 3, 1]'
      note: Swap pairs at positions (0,7) and (2,5), skip (1,6) and (3,4)
    - input: '[]int{1, 2, 3, 4}'
      output: '[4, 2, 3, 1]'
      note: Swap (0,3), skip (1,2)
    hints:
    - title: Think about it
      content: |-
        Start pointers at ends. Swap, move inward by 2 (skip next pair), swap again, repeat.
    - title: Hint
      content: |-
        left = 0, right = len-1. While left < right: swap them, then left += 2, right -= 2 (to skip next pair).
    - title: Pattern
      content: "<pre>1. left := 0, right := len-1\n2. While left < right:\n   - Swap\
        \ nums[left] â\x86\x94 nums[right]\n   - left += 2, right -= 2</pre>"
    solution: |-
      func reverseAlternating(nums []int) {
          left, right := 0, len(nums)-1
          for left < right {
              nums[left], nums[right] = nums[right], nums[left]
              left += 2
              right -= 2
          }
      }
  - id: v1
    title: Remove Duplicates from Sorted Array
    description: |-
      Write a function <code>func removeDuplicates(nums []int) int</code> that removes duplicates from a sorted slice <strong>in-place</strong>. Return the number of unique elements. The first k elements should contain the unique values.
    functionSignature: func removeDuplicates(nums []int) int
    testCases:
    - input: '[]int{1, 1, 2}'
      output: '2'
      note: array becomes [1, 2, _]
    - input: '[]int{0, 0, 1, 1, 2, 2, 3}'
      output: '4'
      note: array becomes [0, 1, 2, 3, _, _, _]
    - input: '[]int{1, 2, 3}'
      output: '3'
    solution: |-
      func removeDuplicates(nums []int) int {
          if len(nums) == 0 {
              return 0
          }
          slow := 0
          for fast := 1; fast < len(nums); fast++ {
              if nums[fast] != nums[slow] {
                  slow++
                  nums[slow] = nums[fast]
              }
          }
          return slow + 1
      }
    difficulty: 4
  - id: v2
    title: Remove Element
    description: |-
      Write a function <code>func removeElement(nums []int, val int) int</code> that removes all occurrences of <code>val</code> <strong>in-place</strong>. Return the number of elements remaining. Order doesn't need to be preserved.
    functionSignature: func removeElement(nums []int, val int) int
    testCases:
    - input: '[]int{3, 2, 2, 3}, 3'
      output: '2'
      note: array becomes [2, 2, _, _]
    - input: '[]int{0, 1, 2, 2, 3, 0, 4, 2}, 2'
      output: '5'
    - input: '[]int{1}, 1'
      output: '0'
    solution: |-
      func removeElement(nums []int, val int) int {
          slow := 0
          for fast := 0; fast < len(nums); fast++ {
              if nums[fast] != val {
                  nums[slow] = nums[fast]
                  slow++
              }
          }
          return slow
      }
    solutionNotes: |-
      Unlike Remove Duplicates, here we compare against a fixed value, not the previous element. And both pointers start at 0.
    difficulty: 4
  - id: v3
    title: Move Zeroes
    description: |-
      Write a function <code>func moveZeroes(nums []int)</code> that moves all <code>0</code>s to the end of the slice while maintaining the relative order of non-zero elements. Modify in-place.
    functionSignature: func moveZeroes(nums []int)
    testCases:
    - input: '[]int{0, 1, 0, 3, 12}'
      output: '[1, 3, 12, 0, 0]'
    - input: '[]int{0, 0, 1}'
      output: '[1, 0, 0]'
    - input: '[]int{1, 2, 3}'
      output: '[1, 2, 3]'
      note: no zeroes
    solution: "func moveZeroes(nums []int) {\n    slow := 0\n    \n    for fast :=\
      \ 0; fast < len(nums); fast++ {\n        if nums[fast] != 0 {\n            nums[slow]\
      \ = nums[fast]\n            slow++\n        }\n    }\n    \n    for i := slow;\
      \ i < len(nums); i++ {\n        nums[i] = 0\n    }\n}"
    solutionNotes: |-
      This is a two-pass solution. First pass moves non-zeroes forward, second pass fills remaining positions with zeroes. Can also be done in one pass with swapping!
    difficulty: 4
  - id: v4
    title: Remove Duplicates II (Allow 2)
    description: |-
      Write a function <code>func removeDuplicatesII(nums []int) int</code> that removes duplicates from a sorted array such that each element appears <strong>at most twice</strong>. Return the new length.
    functionSignature: func removeDuplicatesII(nums []int) int
    testCases:
    - input: '[]int{1, 1, 1, 2, 2, 3}'
      output: '5'
      note: becomes [1, 1, 2, 2, 3, _]
    - input: '[]int{0, 0, 1, 1, 1, 1, 2, 3, 3}'
      output: '7'
    - input: '[]int{1, 1}'
      output: '2'
    solution: "func removeDuplicatesII(nums []int) int {\n    if len(nums) <= 2 {\n\
      \        return len(nums)\n    }\n    \n    slow := 2\n    for fast := 2; fast\
      \ < len(nums); fast++ {\n        if nums[fast] != nums[slow-2] {\n         \
      \   nums[slow] = nums[fast]\n            slow++\n        }\n    }\n    return\
      \ slow\n}"
    solutionNotes: |-
      The key insight: compare with nums[slow-2], not nums[slow-1]. This ensures at most 2 of each value. Start both pointers at index 2.
    difficulty: 4
  - id: v5
    title: Sorted Squares
    description: |-
      Write a function <code>func sortedSquares(nums []int) []int</code> that returns an array of the squares of each number, sorted in ascending order. Input is sorted but may contain negatives.
    functionSignature: func sortedSquares(nums []int) []int
    testCases:
    - input: '[]int{-4, -1, 0, 3, 10}'
      output: '[0, 1, 9, 16, 100]'
    - input: '[]int{-7, -3, 2, 3, 11}'
      output: '[4, 9, 9, 49, 121]'
    - input: '[]int{1, 2, 3}'
      output: '[1, 4, 9]'
    solution: "func sortedSquares(nums []int) []int {\n    n := len(nums)\n    result\
      \ := make([]int, n)\n    left, right := 0, n-1\n    pos := n - 1\n    \n   \
      \ for left <= right {\n        leftSq := nums[left] * nums[left]\n        rightSq\
      \ := nums[right] * nums[right]\n        \n        if leftSq > rightSq {\n  \
      \          result[pos] = leftSq\n            left++\n        } else {\n    \
      \        result[pos] = rightSq\n            right--\n        }\n        pos--\n\
      \    }\n    return result\n}"
    solutionNotes: |-
      This uses two pointers from OPPOSITE ENDS (not slow/fast). The largest squares are at the edges (most negative or most positive). Fill result array from the back.
    difficulty: 4
  - id: v6
    title: Merge Sorted Array
    description: |-
      Write a function <code>func merge(nums1 []int, m int, nums2 []int, n int)</code> that merges nums2 into nums1 <strong>in-place</strong>. nums1 has length m+n, with the last n elements being 0 (placeholders).
    functionSignature: func merge(nums1 []int, m int, nums2 []int, n int)
    testCases:
    - input: '[]int{1, 2, 3, 0, 0, 0}, 3, []int{2, 5, 6}, 3'
      output: '[1, 2, 2, 3, 5, 6]'
    - input: '[]int{1}, 1, []int{}, 0'
      output: '[1]'
    - input: '[]int{0}, 0, []int{1}, 1'
      output: '[1]'
    solution: "func merge(nums1 []int, m int, nums2 []int, n int) {\n    p1 := m -\
      \ 1\n    p2 := n - 1\n    pos := m + n - 1\n    \n    for p2 >= 0 {\n      \
      \  if p1 >= 0 && nums1[p1] > nums2[p2] {\n            nums1[pos] = nums1[p1]\n\
      \            p1--\n        } else {\n            nums1[pos] = nums2[p2]\n  \
      \          p2--\n        }\n        pos--\n    }\n}"
    solutionNotes: |-
      Work BACKWARDS to avoid overwriting elements we haven't processed. The loop continues until all of nums2 is merged. If nums1 elements remain, they're already in place.
    difficulty: 4
- id: challenge_11
  block: 4
  difficulty: 4
  concept: Map Lookup + Early Return
  docLinks:
  - url: https://go.dev/blog/maps
    title: 'Go Blog: Go maps in action'
    note: map as a set pattern
  - url: https://go.dev/ref/spec#Index_expressions
    title: 'Go Spec: Index expressions'
    note: checking if key exists
  patternPrimer:
    bruteForce: |-
      Nested loops: for each element, scan all previous elements to check if it appeared before.
    bestApproach: |-
      Track seen elements in a map; check map in O(1) time, return immediately when found.
    typical: Typically O(n) time, O(n) extra space
  variants:
  - id: v1
    title: First Duplicate Index
    description: |-
      Write <code>func firstDupIdx(nums []int) int</code> - index of first repeat, or -1.
    functionSignature: func firstDupIdx(nums []int) int
    testCases:
    - input: '[]int{1,2,3,2}'
      output: '3'
    hints:
    - title: Think about it
      content: |-
        You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?
    - title: Hint
      content: |-
        Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue.
    - title: Pattern
      content: |-
        <pre>1. Create empty "seen" tracker
        2. For each element:
           - Already seen? → return (found duplicate!)
           - Not seen? → add to tracker
        3. Loop finished? → return not found</pre>
    solution: |-
      func firstDupIdx(nums []int) int {
          seen := make(map[int]bool)
          for i, n := range nums {
              if seen[n] { return i }
              seen[n] = true
          }
          return -1
      }
    difficulty: 2
  - id: v2
    title: First Repeat Char
    description: Write <code>func firstRepeat(s string) rune</code> - first repeated
      char, or 0.
    functionSignature: func firstRepeat(s string) rune
    testCases:
    - input: '"abcab"'
      output: '''a'''
    hints:
    - title: Think about it
      content: |-
        You want to find the first element that appears twice. As you go through, how do you know if you've seen something before?
    - title: Hint
      content: |-
        Use a map as a 'seen' set. For each element, first check if it's in the map - if yes, you found a duplicate! If no, add it to the map and continue.
    - title: Pattern
      content: |-
        <pre>1. Create empty "seen" tracker
        2. For each element:
           - Already seen? → return (found duplicate!)
           - Not seen? → add to tracker
        3. Loop finished? → return not found</pre>
    solution: |-
      func firstRepeat(s string) rune {
          seen := make(map[rune]bool)
          for _, r := range s {
              if seen[r] { return r }
              seen[r] = true
          }
          return 0
      }
    difficulty: 2
  - id: v3
    title: Find Missing in Sequence
    description: |-
      Write <code>func findMissing(nums []int, n int) int</code> - given numbers 1 to n with one missing, find it.
    functionSignature: func findMissing(nums []int, n int) int
    testCases:
    - input: '[]int{1,2,4,5}, 5'
      output: '3'
      note: 3 is missing from 1-5
    - input: '[]int{2,3,4}, 4'
      output: '1'
    hints:
    - title: Think about it
      content: |-
        Put all the numbers you have into a set. Then check which number from 1 to n is not in the set.
    - title: Hint
      content: |-
        First loop: add all nums to a map. Second loop: check 1 to n, return the one not in the map.
    - title: Pattern
      content: |-
        <pre>1. Add all nums to a 'have' map
        2. For i from 1 to n:
           - If !have[i] → return i (found missing!)
        3. Return 0 (shouldn't happen)</pre>
    solution: |-
      func findMissing(nums []int, n int) int {
          have := make(map[int]bool)
          for _, num := range nums { have[num] = true }
          for i := 1; i <= n; i++ {
              if !have[i] { return i }
          }
          return 0
      }
    difficulty: 3
  - id: v4
    title: Two Sum Exists
    description: |-
      Write <code>func twoSumExists(nums []int, target int) bool</code> - true if any two numbers add to target.
    functionSignature: func twoSumExists(nums []int, target int) bool
    testCases:
    - input: '[]int{2, 7, 11, 15}, 9'
      output: 'true'
    - input: '[]int{2, 7, 11, 15}, 10'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        For each number, what complement would you need to see to make the target sum? How can you check if you've seen that complement?
    - title: Hint
      content: |-
        For each num, check if (target - num) is in your 'seen' set. If yes, you found a pair! If no, add num to seen and continue.
    - title: Pattern
      content: |-
        <pre>1. Create empty "seen" map
        2. For each num:
           - complement = target - num
           - seen[complement]? → return true
           - Add num to seen
        3. Return false</pre>
    solution: |-
      func twoSumExists(nums []int, target int) bool {
          seen := make(map[int]bool)
          for _, n := range nums {
              if seen[target-n] { return true }
              seen[n] = true
          }
          return false
      }
    difficulty: 3
  - id: v5
    title: All Unique Words
    description: |-
      Write <code>func allUnique(words []string) bool</code> - true if no word appears twice.
    functionSignature: func allUnique(words []string) bool
    testCases:
    - input: '[]string{"go", "rust", "python"}'
      output: 'true'
    - input: '[]string{"go", "rust", "go"}'
      output: 'false'
    hints:
    - title: Think about it
      content: This is the inverse of 'has duplicate'. When should you return false?
    - title: Hint
      content: |-
        Use a map to track seen words. If you ever encounter a word you've already seen, return false. If you finish the loop, return true.
    - title: Pattern
      content: |-
        <pre>1. Create empty "seen" map
        2. For each word:
           - Already seen? → return false
           - Add to seen
        3. Return true (all unique)</pre>
    solution: |-
      func allUnique(words []string) bool {
          seen := make(map[string]bool)
          for _, w := range words {
              if seen[w] { return false }
              seen[w] = true
          }
          return true
      }
    difficulty: 2
  - id: v6
    title: First Non-Repeating
    description: |-
      Write <code>func firstNonRepeating(s string) rune</code> - first character that appears exactly once, or 0 if all repeat.
    functionSignature: func firstNonRepeating(s string) rune
    testCases:
    - input: '"aabbccd"'
      output: '''d'''
    - input: '"aabbcc"'
      output: '0'
    hints:
    - title: Think about it
      content: |-
        You need TWO passes: first count all characters, then find the first one with count == 1.
    - title: Hint
      content: |-
        First pass: build a frequency map. Second pass: iterate through string again and return the first char with count == 1.
    - title: Pattern
      content: |-
        <pre>1. First pass: count each character
        2. Second pass: for each character
           - Count == 1? → return it
        3. Return 0 (none found)</pre>
    solution: |-
      func firstNonRepeating(s string) rune {
          counts := make(map[rune]int)
          for _, r := range s { counts[r]++ }
          for _, r := range s {
              if counts[r] == 1 { return r }
          }
          return 0
      }
    difficulty: 3
  - id: v7
    title: Contains Value
    difficulty: 1
    description: |-
      Write <code>func containsValue(nums []int, target int) bool</code> that returns true if target exists in the slice. Use a map for O(n) solution.
    functionSignature: func containsValue(nums []int, target int) bool
    testCases:
    - input: '[]int{1, 2, 3, 4, 5}, 3'
      output: 'true'
    - input: '[]int{1, 2, 3, 4, 5}, 6'
      output: 'false'
    hints:
    - title: Think about it
      content: |-
        You could use linear search, but this pattern is about using maps. How can a map help you check membership quickly?
    - title: Hint
      content: |-
        Build a map[int]bool to track which numbers exist. Then check if target is in the map using the comma-ok pattern.
    - title: Pattern
      content: |-
        <pre>1. Create set map[int]bool
        2. For each num: set[num] = true
        3. Return set[target] exists</pre>
    solution: |-
      func containsValue(nums []int, target int) bool {
          seen := make(map[int]bool)
          for _, n := range nums {
              seen[n] = true
          }
          return seen[target]
      }
  - id: v8
    title: Count Unique
    difficulty: 1
    description: |-
      Write <code>func countUnique(nums []int) int</code> that returns how many unique/distinct numbers exist in the slice.
    functionSignature: func countUnique(nums []int) int
    testCases:
    - input: '[]int{1, 2, 2, 3, 3, 3}'
      output: '3'
      note: 'Three unique values: 1, 2, 3'
    - input: '[]int{5, 5, 5}'
      output: '1'
    hints:
    - title: Think about it
      content: |-
        Maps automatically deduplicate! What property of a map tells you how many unique keys it has?
    - title: Hint
      content: |-
        Add all numbers to a map[int]bool as keys. The map will only keep unique keys. Return len(map).
    - title: Pattern
      content: |-
        <pre>1. Create set map[int]bool
        2. For each num: set[num] = true
        3. Return len(set)</pre>
    solution: |-
      func countUnique(nums []int) int {
          seen := make(map[int]bool)
          for _, n := range nums {
              seen[n] = true
          }
          return len(seen)
      }
  - id: v9
    title: Employee ID Lookup
    description: |-
      Write <code>func employeeName(ids map[int]string, id int) string</code> that returns employee name or "Unknown".
    functionSignature: func employeeName(ids map[int]string, id int) string
    testCases:
    - input: 'map[int]string{101: "Alice", 102: "Bob"}, 101'
      output: '"Alice"'
    - input: 'map[int]string{101: "Alice"}, 999'
      output: '"Unknown"'
    hints:
    - title: Think about it
      content: Use comma-ok idiom to check if ID exists in map.
    - title: Hint
      content: name, exists := ids[id]; if exists return name, else return "Unknown"
    - title: Pattern
      content: |-
        <pre>1. name, exists := ids[id]
        2. If exists → return name
        3. Return "Unknown"</pre>
    solution: |-
      func employeeName(ids map[int]string, id int) string {
          if name, exists := ids[id]; exists {
              return name
          }
          return "Unknown"
      }
    difficulty: 2
  - id: v10
    title: Country Capital
    description: |-
      Write <code>func getCapital(capitals map[string]string, country string) (string, bool)</code> that returns capital and whether found.
    functionSignature: func getCapital(capitals map[string]string, country string)
      (string, bool)
    testCases:
    - input: 'map[string]string{"USA": "Washington DC", "France": "Paris"}, "France"'
      output: '"Paris", true'
    - input: 'map[string]string{"USA": "Washington DC"}, "Spain"'
      output: '"", false'
    hints:
    - title: Think about it
      content: |-
        This is a direct map lookup with comma-ok pattern - return both value and existence.
    - title: Hint
      content: capital, exists := capitals[country]; return capital, exists
    - title: Pattern
      content: |-
        <pre>capital, exists := capitals[country]
        return capital, exists</pre>
    solution: |-
      func getCapital(capitals map[string]string, country string) (string, bool) {
          capital, exists := capitals[country]
          return capital, exists
      }
    difficulty: 1
  - id: v1
    title: Two Sum
    description: |-
      Given a slice of ints and a target, return indices of two numbers that add up to the target. <code>func twoSum(nums []int, target int) []int</code>
    functionSignature: func twoSum(nums []int, target int) []int
    testCases:
    - input: '[]int{2, 7, 11, 15}, 9'
      output: '[0, 1]'
    - input: '[]int{3, 2, 4}, 6'
      output: '[1, 2]'
    - input: '[]int{3, 3}, 6'
      output: '[0, 1]'
    solution: |-
      func twoSum(nums []int, target int) []int {
          seen := make(map[int]int)
          for i, num := range nums {
              complement := target - num
              if j, ok := seen[complement]; ok {
                  return []int{j, i}
              }
              seen[num] = i
          }
          return nil
      }
    difficulty: 4
  - id: v2
    title: Two Sum II (Sorted Input)
    description: |-
      Given a <strong>sorted</strong> array and target, return indices (1-indexed) of two numbers that add to target. Use two pointers instead of a hash map. <code>func twoSumSorted(nums []int, target int) []int</code>
    functionSignature: func twoSumSorted(nums []int, target int) []int
    testCases:
    - input: '[]int{2, 7, 11, 15}, 9'
      output: '[1, 2]'
      note: 1-indexed!
    - input: '[]int{2, 3, 4}, 6'
      output: '[1, 3]'
    - input: '[]int{-1, 0}, -1'
      output: '[1, 2]'
    solution: "func twoSumSorted(nums []int, target int) []int {\n    left, right\
      \ := 0, len(nums)-1\n    \n    for left < right {\n        sum := nums[left]\
      \ + nums[right]\n        if sum == target {\n            return []int{left +\
      \ 1, right + 1}\n        } else if sum < target {\n            left++\n    \
      \    } else {\n            right--\n        }\n    }\n    return nil\n}"
    solutionNotes: |-
      When input is sorted, two pointers is O(1) space vs O(n) for hash map. Move left pointer right for larger sum, right pointer left for smaller sum.
    difficulty: 4
  - id: v3
    title: Pair with Difference
    description: |-
      Find two numbers whose <strong>difference</strong> equals the target. Return their indices (smaller index first). <code>func pairWithDiff(nums []int, target int) []int</code>
    functionSignature: func pairWithDiff(nums []int, target int) []int
    testCases:
    - input: '[]int{5, 20, 3, 2, 50, 80}, 78'
      output: '[1, 5]'
      note: 80 - 2 = 78... wait
    - input: '[]int{1, 5, 3}, 2'
      output: '[0, 2]'
      note: 3 - 1 = 2
    - input: '[]int{1, 2, 3}, 10'
      output: nil
    solution: "func pairWithDiff(nums []int, target int) []int {\n    seen := make(map[int]int)\n\
      \    \n    for i, num := range nums {\n        if j, ok := seen[num-target];\
      \ ok {\n            return []int{j, i}\n        }\n        if j, ok := seen[num+target];\
      \ ok {\n            return []int{j, i}\n        }\n        seen[num] = i\n \
      \   }\n    return nil\n}"
    solutionNotes: |-
      Unlike Two Sum where we look for target-num, here we look for BOTH num-target AND num+target because either could be the pair (a-b=k or b-a=k).
    difficulty: 4
  - id: v4
    title: Count Pairs with Sum
    description: |-
      Count how many pairs of numbers add up to exactly the target. Each element can only be used once. <code>func countPairs(nums []int, target int) int</code>
    functionSignature: func countPairs(nums []int, target int) int
    testCases:
    - input: '[]int{1, 5, 7, 1}, 6'
      output: '2'
      note: (1,5) and (1,5)
    - input: '[]int{1, 1, 1, 1}, 2'
      output: '2'
      note: two pairs of 1+1
    - input: '[]int{1, 2, 3}, 10'
      output: '0'
    solution: "func countPairs(nums []int, target int) int {\n    counts := make(map[int]int)\n\
      \    for _, num := range nums {\n        counts[num]++\n    }\n    \n    pairs\
      \ := 0\n    for num, count := range counts {\n        complement := target -\
      \ num\n        if complement == num {\n            pairs += count * (count -\
      \ 1) / 2\n        } else if compCount, ok := counts[complement]; ok && complement\
      \ > num {\n            pairs += count * compCount\n        }\n    }\n    return\
      \ pairs\n}"
    solutionNotes: |-
      This is trickier! We count occurrences first, then for each unique number, find pairs. Handle same-number pairs specially (n choose 2). Use complement > num to avoid double counting.
    difficulty: 4
  - id: v5
    title: Three Sum Exists
    description: |-
      Return <code>true</code> if any three numbers in the array sum to zero. <code>func threeSumExists(nums []int) bool</code>
    functionSignature: func threeSumExists(nums []int) bool
    testCases:
    - input: '[]int{-1, 0, 1, 2}'
      output: 'true'
      note: -1 + 0 + 1 = 0
    - input: '[]int{1, 2, 3}'
      output: 'false'
    - input: '[]int{0, 0, 0}'
      output: 'true'
    solution: "import \"sort\"\n\nfunc threeSumExists(nums []int) bool {\n    sort.Ints(nums)\n\
      \    n := len(nums)\n    \n    for i := 0; i < n-2; i++ {\n        if i > 0\
      \ && nums[i] == nums[i-1] {\n            continue\n        }\n        \n   \
      \     left, right := i+1, n-1\n        target := -nums[i]\n        \n      \
      \  for left < right {\n            sum := nums[left] + nums[right]\n       \
      \     if sum == target {\n                return true\n            } else if\
      \ sum < target {\n                left++\n            } else {\n           \
      \     right--\n            }\n        }\n    }\n    return false\n}"
    solutionNotes: |-
      Fix one number, then use Two Sum II (sorted) for the other two. Sorting first enables the two-pointer approach. O(n²) total.
    difficulty: 4
  - id: v6
    title: Subarray Sum Equals K
    description: |-
      Count the number of continuous subarrays whose elements sum to k. <code>func subarraySum(nums []int, k int) int</code>
    functionSignature: func subarraySum(nums []int, k int) int
    testCases:
    - input: '[]int{1, 1, 1}, 2'
      output: '2'
      note: '[1,1] at positions 0-1 and 1-2'
    - input: '[]int{1, 2, 3}, 3'
      output: '2'
      note: '[1,2] and [3]'
    - input: '[]int{1, -1, 0}, 0'
      output: '3'
    solution: "func subarraySum(nums []int, k int) int {\n    count := 0\n    prefixSum\
      \ := 0\n    seen := make(map[int]int)\n    seen[0] = 1\n    \n    for _, num\
      \ := range nums {\n        prefixSum += num\n        if c, ok := seen[prefixSum-k];\
      \ ok {\n            count += c\n        }\n        seen[prefixSum]++\n    }\n\
      \    return count\n}"
    solutionNotes: |-
      This uses the prefix sum technique with a hash map. If prefix[j] - prefix[i] = k, then subarray [i+1...j] sums to k. We track how many times each prefix sum has occurred.
    difficulty: 4
- id: challenge_12
  block: 1
  difficulty: 1
  concept: Simple Tallying
  docLinks:
  - url: https://go.dev/blog/maps
    title: 'Go Blog: Go maps in action'
    note: intro to maps
  patternPrimer:
    bruteForce: Loop through and increment a counter when condition matches.
    bestApproach: Same approach - single pass counting is already optimal.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Count Specific Value
    description: |-
      Write <code>func countValue(nums []int, target int) int</code> that counts how many times target appears.
    functionSignature: func countValue(nums []int, target int) int
    testCases:
    - input: '[]int{1, 2, 2, 3, 2}, 2'
      output: '3'
    - input: '[]int{5, 5, 5}, 5'
      output: '3'
    hints:
    - title: Think about it
      content: Start with count = 0. Each time you see the target, increment count.
    - title: Hint
      content: Loop through the slice. If element == target, do count++.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each element:
           - element == target? → count++
        3. Return count</pre>
    solution: |-
      func countValue(nums []int, target int) int {
          count := 0
          for _, n := range nums {
              if n == target { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v2
    title: Track Seen Values
    description: |-
      Write <code>func trackSeen(nums []int) map[int]bool</code> that returns a map marking which values were seen.
    functionSignature: func trackSeen(nums []int) map[int]bool
    testCases:
    - input: '[]int{1, 2, 2, 3}'
      output: map[1:true 2:true 3:true]
    - input: '[]int{5, 5}'
      output: map[5:true]
    hints:
    - title: Think about it
      content: Create a map, then mark each number as seen (true).
    - title: Hint
      content: For each number, set seen[num] = true. Maps automatically handle duplicates.
    - title: Pattern
      content: |-
        <pre>1. Create map[int]bool
        2. For each num:
           - seen[num] = true
        3. Return map</pre>
    solution: |-
      func trackSeen(nums []int) map[int]bool {
          seen := make(map[int]bool)
          for _, n := range nums { seen[n] = true }
          return seen
      }
    difficulty: 2
  - id: v3
    title: Count True Values
    description: |-
      Write <code>func countTrue(flags []bool) int</code> that counts how many true values are in the slice.
    functionSignature: func countTrue(flags []bool) int
    testCases:
    - input: '[]bool{true, false, true, true}'
      output: '3'
    - input: '[]bool{false, false}'
      output: '0'
    hints:
    - title: Think about it
      content: Same as counting any specific value - count when you see true.
    - title: Hint
      content: if flag { count++ }
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each flag:
           - flag == true? → count++
        3. Return count</pre>
    solution: |-
      func countTrue(flags []bool) int {
          count := 0
          for _, f := range flags {
              if f { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v4
    title: Tally by Type
    description: |-
      Write <code>func tallyTypes(words []string) map[string]int</code> that counts how many of each word type. Simple tallying intro!
    functionSignature: func tallyTypes(words []string) map[string]int
    testCases:
    - input: '[]string{"cat", "dog", "cat", "bird"}'
      output: map[cat:2 dog:1 bird:1]
    hints:
    - title: Think about it
      content: |-
        For each word, increment its count in the map. Maps default to 0 when accessing non-existent keys.
    - title: Hint
      content: counts[word]++ works even if word isn't in the map yet (starts at 0).
    - title: Pattern
      content: |-
        <pre>1. Create map[string]int
        2. For each word:
           - counts[word]++
        3. Return map</pre>
    solution: |-
      func tallyTypes(words []string) map[string]int {
          counts := make(map[string]int)
          for _, w := range words { counts[w]++ }
          return counts
      }
    difficulty: 2
  - id: v5
    title: Count Vowels and Consonants
    description: |-
      Write <code>func countVowelsConsonants(s string) (int, int)</code> that returns vowel count and consonant count.
    functionSignature: func countVowelsConsonants(s string) (int, int)
    testCases:
    - input: '"hello"'
      output: 2, 3
      note: e,o are vowels; h,l,l are consonants
    - input: '"aaa"'
      output: 3, 0
    hints:
    - title: Think about it
      content: Check if each character is a vowel (a,e,i,o,u). Count separately.
    - title: Hint
      content: 'Create a helper check: isVowel := char == ''a'' || char == ''e'' ||
        ...'
    - title: Pattern
      content: |-
        <pre>1. vowels, consonants := 0, 0
        2. For each char:
           - Is vowel? → vowels++
           - Else → consonants++
        3. Return both</pre>
    solution: |-
      func countVowelsConsonants(s string) (int, int) {
          vowels, consonants := 0, 0
          for _, r := range s {
              lower := strings.ToLower(string(r))
              if lower == "a" || lower == "e" || lower == "i" || lower == "o" || lower == "u" {
                  vowels++
              } else {
                  consonants++
              }
          }
          return vowels, consonants
      }
    difficulty: 2
  - id: v6
    title: Has Value
    description: |-
      Write <code>func hasValue(nums []int, target int) bool</code> that returns true if target is in the slice.
    functionSignature: func hasValue(nums []int, target int) bool
    testCases:
    - input: '[]int{1, 2, 3}, 2'
      output: 'true'
    - input: '[]int{1, 2, 3}, 5'
      output: 'false'
    hints:
    - title: Think about it
      content: As soon as you find target, return true. If loop finishes, return false.
    - title: Hint
      content: This is early return pattern - return as soon as found.
    - title: Pattern
      content: |-
        <pre>1. For each num:
           - num == target? → return true
        2. Return false (not found)</pre>
    solution: |-
      func hasValue(nums []int, target int) bool {
          for _, n := range nums {
              if n == target { return true }
          }
          return false
      }
    difficulty: 1
  - id: v7
    title: Count Even Numbers
    description: |-
      Write <code>func countEvens(nums []int) int</code> that counts how many even numbers are in the slice.
    functionSignature: func countEvens(nums []int) int
    testCases:
    - input: '[]int{1, 2, 3, 4, 5, 6}'
      output: '3'
    - input: '[]int{1, 3, 5}'
      output: '0'
    hints:
    - title: Think about it
      content: A number is even if num % 2 == 0. Count how many satisfy this condition.
    - title: Hint
      content: Loop through, increment counter when num % 2 == 0.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each num:
           - num % 2 == 0? → count++
        3. Return count</pre>
    solution: |-
      func countEvens(nums []int) int {
          count := 0
          for _, n := range nums {
              if n % 2 == 0 { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v8
    title: Passing Grades
    description: |-
      Write <code>func passingGrades(grades []int) int</code> that counts how many grades are 60 or above.
    functionSignature: func passingGrades(grades []int) int
    testCases:
    - input: '[]int{85, 55, 90, 45, 70}'
      output: '3'
    - input: '[]int{30, 40, 50}'
      output: '0'
    hints:
    - title: Think about it
      content: Count grades that are >= 60.
    - title: Hint
      content: 'Simple counter: if grade >= 60, increment count.'
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For each grade:
           - grade >= 60? → count++
        3. Return count</pre>
    solution: |-
      func passingGrades(grades []int) int {
          count := 0
          for _, g := range grades {
              if g >= 60 { count++ }
          }
          return count
      }
    difficulty: 1
  - id: v9
    title: Inventory Below Threshold
    description: |-
      Write <code>func lowStock(inventory map[string]int, threshold int) []string</code> that returns item names with stock below threshold.
    functionSignature: func lowStock(inventory map[string]int, threshold int) []string
    testCases:
    - input: 'map[string]int{"apples": 5, "oranges": 15, "bananas": 3}, 10'
      output: '["apples", "bananas"]'
    - input: 'map[string]int{"pens": 100, "paper": 200}, 50'
      output: '[]'
    hints:
    - title: Think about it
      content: Loop through the map, collect items where count < threshold.
    - title: Hint
      content: For each key-value pair, if value < threshold, append key to result
        slice.
    - title: Pattern
      content: |-
        <pre>1. result := []string{}
        2. For item, count in inventory:
           - count < threshold?
             → append item to result
        3. Return result</pre>
    solution: |-
      func lowStock(inventory map[string]int, threshold int) []string {
          result := []string{}
          for item, count := range inventory {
              if count < threshold {
                  result = append(result, item)
              }
          }
          return result
      }
    difficulty: 2
  - id: v10
    title: Group By First Letter
    description: |-
      Write <code>func groupByFirstLetter(words []string) map[rune][]string</code> that groups words by their first letter. Returns a map where keys are first letters and values are slices of all words starting with that letter.
    functionSignature: func groupByFirstLetter(words []string) map[rune][]string
    testCases:
    - input: '["go", "rust", "ruby", "python", "perl"]'
      output: map['g':["go"] 'r':["rust", "ruby"] 'p':["python", "perl"]]
    - input: '["apple", "ant", "bat", "bear"]'
      output: map['a':["apple", "ant"] 'b':["bat", "bear"]]
    hints:
    - title: Think about it
      content: |-
        You need to build a map where each key points to a slice. For each word, get its first letter and append the word to that letter's slice.
    - title: Hint
      content: |-
        Create map[rune][]string. For each word, get first letter with rune(word[0]). Append word to groups[firstLetter]. If the slice doesn't exist yet, append creates it.
    - title: Pattern
      content: |-
        <pre>1. Create map[rune][]string
        2. For each word:
           - Get first letter: rune(word[0])
           - Append word to map[firstLetter]
        3. Return map</pre>
    solution: |-
      func groupByFirstLetter(words []string) map[rune][]string {
          groups := make(map[rune][]string)
          for _, word := range words {
              if len(word) > 0 {
                  firstLetter := rune(word[0])
                  groups[firstLetter] = append(groups[firstLetter], word)
              }
          }
          return groups
      }
    difficulty: 3
  - id: v11
    title: Frequency Sorted Keys
    description: |-
      Write <code>func frequencySortedKeys(items []string) []string</code> that returns unique items sorted by frequency (most common first). If frequencies are tied, maintain the order items were first seen.
    functionSignature: func frequencySortedKeys(items []string) []string
    testCases:
    - input: '["cat", "dog", "cat", "bird", "cat", "dog"]'
      output: '["cat", "dog", "bird"]'
      note: cat appears 3x, dog 2x, bird 1x
    - input: '["a", "b", "a", "c", "a", "b"]'
      output: '["a", "b", "c"]'
    hints:
    - title: Think about it
      content: |-
        First build a frequency map to count occurrences. Then you need to create a result by iterating through unique items and sorting by their frequency. Track the order items first appeared.
    - title: Hint
      content: |-
        Build two things: a frequency map and a list of unique items in order seen. Then sort the unique list by looking up frequencies. Use a simple comparison to sort.
    - title: Pattern
      content: |-
        <pre>1. Build frequency map
        2. Track unique items in order
        3. Sort unique items by frequency
           (most frequent first)
        4. Return sorted list</pre>
    solution: "func frequencySortedKeys(items []string) []string {\n    freq := make(map[string]int)\n\
      \    var order []string\n    seen := make(map[string]bool)\n    \n    for _,\
      \ item := range items {\n        freq[item]++\n        if !seen[item] {\n  \
      \          order = append(order, item)\n            seen[item] = true\n    \
      \    }\n    }\n    \n    // Simple bubble sort by frequency\n    for i := 0;\
      \ i < len(order); i++ {\n        for j := i + 1; j < len(order); j++ {\n   \
      \         if freq[order[j]] > freq[order[i]] {\n                order[i], order[j]\
      \ = order[j], order[i]\n            }\n        }\n    }\n    \n    return order\n\
      }"
    difficulty: 3
  - id: v12
    title: Count Multi-Condition
    description: |-
      Write <code>func countMultiCondition(nums []int, min, max, divisor int) map[string]int</code> that categorizes numbers into four groups: "in_range" (min <= n <= max), "divisible" (n % divisor == 0), "both" (satisfies both conditions), and "neither".
    functionSignature: func countMultiCondition(nums []int, min, max, divisor int)
      map[string]int
    testCases:
    - input: '[]int{5, 10, 15, 20}, 10, 20, 5'
      output: map["in_range":3 "divisible":4 "both":3 "neither":0]
      note: |-
        10,15,20 in range; all divisible by 5; 10,15,20 satisfy both; 5 satisfies neither
    - input: '[]int{1, 2, 3}, 5, 10, 2'
      output: map["in_range":0 "divisible":1 "both":0 "neither":2]
    hints:
    - title: Think about it
      content: |-
        For each number, check both conditions independently. Count how many satisfy: just range, just divisible, both, or neither. All four counts are independent.
    - title: Hint
      content: |-
        Create a map with 4 keys initialized to 0. For each number, check inRange := (n >= min && n <= max) and isDivisible := (n % divisor == 0). Then increment the appropriate counters.
    - title: Pattern
      content: |-
        <pre>1. Create map with 4 categories = 0
        2. For each num:
           - Check if in range
           - Check if divisible
           - Increment all matching categories
        3. Return map</pre>
    solution: "func countMultiCondition(nums []int, min, max, divisor int) map[string]int\
      \ {\n    counts := map[string]int{\"in_range\": 0, \"divisible\": 0, \"both\"\
      : 0, \"neither\": 0}\n    \n    for _, n := range nums {\n        inRange :=\
      \ n >= min && n <= max\n        isDivisible := n % divisor == 0\n        \n\
      \        if inRange {\n            counts[\"in_range\"]++\n        }\n     \
      \   if isDivisible {\n            counts[\"divisible\"]++\n        }\n     \
      \   if inRange && isDivisible {\n            counts[\"both\"]++\n        }\n\
      \        if !inRange && !isDivisible {\n            counts[\"neither\"]++\n\
      \        }\n    }\n    \n    return counts\n}"
    difficulty: 3
  - id: v13
    title: Tally By Category
    description: |-
      Write <code>func tallyByCategory(items []string, categories map[string]string) map[string]int</code> that counts items per category. Given items and a map of item→category, return count of items per category.
    functionSignature: |-
      func tallyByCategory(items []string, categories map[string]string) map[string]int
    testCases:
    - input: |-
        ["apple", "banana", "carrot", "broccoli"], map["apple":"fruit", "banana":"fruit", "carrot":"veggie", "broccoli":"veggie"]
      output: map["fruit":2 "veggie":2]
    - input: '["a", "b", "c"], map["a":"x", "b":"x", "c":"y"]'
      output: map["x":2 "y":1]
    hints:
    - title: Think about it
      content: |-
        For each item, look up its category in the categories map, then increment that category's count in your result map.
    - title: Hint
      content: |-
        Create a result map for counting. For each item, get category := categories[item], then do counts[category]++. The map lookup gives you the indirect key to increment.
    - title: Pattern
      content: |-
        <pre>1. Create counts map[string]int
        2. For each item:
           - Look up category from categories map
           - Increment counts[category]
        3. Return counts</pre>
    solution: |-
      func tallyByCategory(items []string, categories map[string]string) map[string]int {
          counts := make(map[string]int)
          for _, item := range items {
              category := categories[item]
              counts[category]++
          }
          return counts
      }
    difficulty: 3
- id: challenge_13
  block: 1
  difficulty: 1
  concept: Basic Swap Operations
  docLinks:
  - url: https://go.dev/ref/spec#Assignments
    title: 'Go Spec: Assignments'
    note: simultaneous assignment
  patternPrimer:
    bruteForce: 'Use a temp variable: temp = a, a = b, b = temp (works but verbose).'
    bestApproach: 'Go''s simultaneous assignment: a, b = b, a (cleaner, evaluates
      right side first).'
    typical: Typically O(1) time, O(1) extra space
  variants:
  - id: v1
    title: Swap Two Variables
    description: |-
      Write <code>func swapVars(a, b int) (int, int)</code> that returns the values swapped.
    functionSignature: func swapVars(a, b int) (int, int)
    testCases:
    - input: 3, 7
      output: 7, 3
    - input: 10, 20
      output: 20, 10
    hints:
    - title: Think about it
      content: Go's simultaneous assignment makes this trivial.
    - title: Hint
      content: return b, a - just return them in opposite order!
    - title: Pattern
      content: <pre>return b, a</pre>
    solution: |-
      func swapVars(a, b int) (int, int) {
          return b, a
      }
    difficulty: 1
  - id: v2
    title: Swap First Two Elements
    description: |-
      Write <code>func swapFirstTwo(nums []int)</code> that swaps the first two elements in place. Assume at least 2 elements.
    functionSignature: func swapFirstTwo(nums []int)
    testCases:
    - input: '[]int{1, 2, 3}'
      output: '[2, 1, 3]'
    - input: '[]int{5, 10}'
      output: '[10, 5]'
    hints:
    - title: Think about it
      content: Use simultaneous assignment on slice indices.
    - title: Hint
      content: nums[0], nums[1] = nums[1], nums[0]
    - title: Pattern
      content: <pre>nums[0], nums[1] = nums[1], nums[0]</pre>
    solution: |-
      func swapFirstTwo(nums []int) {
          nums[0], nums[1] = nums[1], nums[0]
      }
    difficulty: 1
  - id: v3
    title: Swap Ends
    description: Write <code>func swapEnds(nums []int)</code> that swaps first and
      last elements.
    functionSignature: func swapEnds(nums []int)
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: '[4, 2, 3, 1]'
    - input: '[]int{5, 10}'
      output: '[10, 5]'
    hints:
    - title: Think about it
      content: Last element is at index len(nums)-1.
    - title: Hint
      content: Swap nums[0] with nums[len(nums)-1].
    - title: Pattern
      content: <pre>nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]</pre>
    solution: |-
      func swapEnds(nums []int) {
          nums[0], nums[len(nums)-1] = nums[len(nums)-1], nums[0]
      }
    difficulty: 1
  - id: v4
    title: Swap at Indices
    description: |-
      Write <code>func swapAt(nums []int, i, j int)</code> that swaps elements at positions i and j.
    functionSignature: func swapAt(nums []int, i, j int)
    testCases:
    - input: '[]int{1, 2, 3, 4}, 0, 2'
      output: '[3, 2, 1, 4]'
    - input: '[]int{5, 10, 15}, 1, 2'
      output: '[5, 15, 10]'
    hints:
    - title: Think about it
      content: Just swap the elements at the given indices.
    - title: Hint
      content: nums[i], nums[j] = nums[j], nums[i]
    - title: Pattern
      content: <pre>nums[i], nums[j] = nums[j], nums[i]</pre>
    solution: |-
      func swapAt(nums []int, i, j int) {
          nums[i], nums[j] = nums[j], nums[i]
      }
    difficulty: 1
  - id: v5
    title: Swap String Parts
    description: |-
      Write <code>func swapStrings(a, b string) (string, string)</code> that swaps two strings.
    functionSignature: func swapStrings(a, b string) (string, string)
    testCases:
    - input: '"hello", "world"'
      output: '"world", "hello"'
    - input: '"go", "rust"'
      output: '"rust", "go"'
    hints:
    - title: Think about it
      content: Same as swapping ints - just return in opposite order.
    - title: Hint
      content: return b, a
    - title: Pattern
      content: <pre>return b, a</pre>
    solution: |-
      func swapStrings(a, b string) (string, string) {
          return b, a
      }
    difficulty: 2
  - id: v6
    title: Conditional Swap
    description: |-
      Write <code>func swapIfGreater(a, b int) (int, int)</code> that swaps only if a > b, ensuring smaller comes first.
    functionSignature: func swapIfGreater(a, b int) (int, int)
    testCases:
    - input: 5, 2
      output: 2, 5
      note: 5 > 2, so swap
    - input: 3, 7
      output: 3, 7
      note: 3 < 7, no swap
    hints:
    - title: Think about it
      content: Check if a > b. If so, swap. Else, leave as-is.
    - title: Hint
      content: if a > b { return b, a } else { return a, b }
    - title: Pattern
      content: |-
        <pre>if a > b {
            return b, a
        }
        return a, b</pre>
    solution: |-
      func swapIfGreater(a, b int) (int, int) {
          if a > b {
              return b, a
          }
          return a, b
      }
    difficulty: 2
  - id: v7
    title: Swap Pairs
    description: "Write <code>func swapPairs(nums []int)</code> that swaps adjacent\
      \ pairs (0â\x86\x941, 2â\x86\x943, etc). Assume even length."
    functionSignature: func swapPairs(nums []int)
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: '[2, 1, 4, 3]'
    - input: '[]int{5, 10, 15, 20}'
      output: '[10, 5, 20, 15]'
    hints:
    - title: Think about it
      content: Loop with step size 2, swapping nums[i] with nums[i+1].
    - title: Hint
      content: for i := 0; i < len(nums); i += 2 { swap nums[i] and nums[i+1] }
    - title: Pattern
      content: "<pre>1. For i = 0, 2, 4, ... (step 2):\n   - Swap nums[i] â\x86\x94\
        \ nums[i+1]\n2. Done</pre>"
    solution: |-
      func swapPairs(nums []int) {
          for i := 0; i < len(nums); i += 2 {
              nums[i], nums[i+1] = nums[i+1], nums[i]
          }
      }
    difficulty: 2
  - id: v8
    title: Rotate Three
    description: |-
      Write <code>func rotateThree(a, b, c int) (int, int, int)</code> that rotates values: a→b, b→c, c→a.
    functionSignature: func rotateThree(a, b, c int) (int, int, int)
    testCases:
    - input: 1, 2, 3
      output: 3, 1, 2
    - input: 10, 20, 30
      output: 30, 10, 20
    hints:
    - title: Think about it
      content: This is a circular rotation. Use simultaneous assignment.
    - title: Hint
      content: 'The pattern is: return c, a, b'
    - title: Pattern
      content: <pre>return c, a, b</pre>
    solution: |-
      func rotateThree(a, b, c int) (int, int, int) {
          return c, a, b
      }
    difficulty: 2
  - id: v9
    title: Swap Min and Max
    description: |-
      Write <code>func swapMinMax(nums []int)</code> that swaps the positions of minimum and maximum values.
    functionSignature: func swapMinMax(nums []int)
    testCases:
    - input: '[]int{3, 1, 4, 9, 2}'
      output: '[3, 9, 4, 1, 2]'
      note: min=1 at idx 1, max=9 at idx 3
    - input: '[]int{5, 2, 8, 2}'
      output: '[5, 8, 2, 2]'
      note: first occurrence of min
    hints:
    - title: Think about it
      content: First find indices of min and max values, then swap elements at those
        indices.
    - title: Hint
      content: |-
        Loop twice: once to find minIdx and maxIdx, then swap nums[minIdx] with nums[maxIdx].
    - title: Pattern
      content: "<pre>1. Find minIdx and maxIdx\n2. Swap nums[minIdx] â\x86\x94 nums[maxIdx]\n\
        3. Done</pre>"
    solution: |-
      func swapMinMax(nums []int) {
          minIdx, maxIdx := 0, 0
          for i := range nums {
              if nums[i] < nums[minIdx] { minIdx = i }
              if nums[i] > nums[maxIdx] { maxIdx = i }
          }
          nums[minIdx], nums[maxIdx] = nums[maxIdx], nums[minIdx]
      }
    difficulty: 3
  - id: v10
    title: Rotate Slice Left
    description: |-
      Write <code>func rotateLeft(nums []int, k int) []int</code> that rotates the slice left by k positions. For example, [1,2,3,4,5] rotated left by 2 becomes [3,4,5,1,2].
    functionSignature: func rotateLeft(nums []int, k int) []int
    testCases:
    - input: '[]int{10, 20, 30, 40}, 1'
      output: '[20, 30, 40, 10]'
    - input: '[]int{1, 2, 3, 4, 5}, 2'
      output: '[3, 4, 5, 1, 2]'
    hints:
    - title: Think about it
      content: |-
        Rotating left by k means taking the first k elements and moving them to the end. You can use slice operations to split and recombine.
    - title: Hint
      content: |-
        Split the slice at position k: first part is nums[:k], second part is nums[k:]. Concatenate them in reverse order: append(nums[k:], nums[:k]...).
    - title: Pattern
      content: |-
        <pre>1. Split at k: left = nums[:k], right = nums[k:]
        2. Concatenate: result = append(right, left...)
        3. Return result</pre>
    solution: |-
      func rotateLeft(nums []int, k int) []int {
          k = k % len(nums)
          return append(nums[k:], nums[:k]...)
      }
    difficulty: 3
  - id: v11
    title: Swap All Pairs
    description: |-
      Write <code>func swapAllPairs(nums []int) []int</code> that swaps every pair of adjacent elements. If the slice has odd length, the last element stays in place. For example, [1,2,3,4,5] becomes [2,1,4,3,5].
    functionSignature: func swapAllPairs(nums []int) []int
    testCases:
    - input: '[]int{10, 20, 30, 40}'
      output: '[20, 10, 40, 30]'
    - input: '[]int{1, 2, 3}'
      output: '[2, 1, 3]'
      note: last element stays
    hints:
    - title: Think about it
      content: |-
        Loop through pairs (i=0, 2, 4...) and swap each pair. Make sure to stop before going out of bounds on odd-length slices.
    - title: Hint
      content: |-
        Create a copy of nums. Loop with i += 2, and swap result[i] with result[i+1] if i+1 < len(result).
    - title: Pattern
      content: |-
        <pre>1. Create copy of nums
        2. For i = 0, 2, 4, ... (step by 2):
           - If i+1 exists:
             → swap result[i] with result[i+1]
        3. Return result</pre>
    solution: "func swapAllPairs(nums []int) []int {\n    result := make([]int, len(nums))\n\
      \    copy(result, nums)\n    \n    for i := 0; i < len(result)-1; i += 2 {\n\
      \        result[i], result[i+1] = result[i+1], result[i]\n    }\n    \n    return\
      \ result\n}"
    difficulty: 3
  - id: v12
    title: Bubble Sort One Pass
    description: |-
      Write <code>func bubbleSortOnePass(nums []int) []int</code> that performs one pass of bubble sort. Compare each pair of adjacent elements and swap if they're in wrong order. This makes the largest element "bubble" to the end.
    functionSignature: func bubbleSortOnePass(nums []int) []int
    testCases:
    - input: '[]int{3, 1, 4, 2}'
      output: '[1, 3, 2, 4]'
      note: after one pass, 4 bubbles to end
    - input: '[]int{5, 3, 8, 1}'
      output: '[3, 5, 1, 8]'
    hints:
    - title: Think about it
      content: |-
        Compare each adjacent pair. If left > right, swap them. After one full pass, the largest element will be at the end.
    - title: Hint
      content: |-
        Create a copy. Loop through i from 0 to len-2. For each i, if result[i] > result[i+1], swap them.
    - title: Pattern
      content: |-
        <pre>1. Create copy of nums
        2. For i from 0 to len-2:
           - result[i] > result[i+1]?
             → swap them
        3. Return result</pre>
    solution: "func bubbleSortOnePass(nums []int) []int {\n    result := make([]int,\
      \ len(nums))\n    copy(result, nums)\n    \n    for i := 0; i < len(result)-1;\
      \ i++ {\n        if result[i] > result[i+1] {\n            result[i], result[i+1]\
      \ = result[i+1], result[i]\n        }\n    }\n    \n    return result\n}"
    difficulty: 3
- id: challenge_14
  block: 2
  difficulty: 2
  concept: Element Comparison
  docLinks:
  - url: https://go.dev/ref/spec#For_statements
    title: 'Go Spec: For statements'
    note: iteration patterns
  patternPrimer:
    bruteForce: |-
      Compare adjacent elements or compare all to first element; early return on mismatch.
    bestApproach: Same approach - single pass with comparisons is already optimal.
    typical: Typically O(n) time, O(1) extra space
  variants:
  - id: v1
    title: Are Equal
    description: |-
      Write <code>func areEqual(nums []int) bool</code> that returns true if all elements are the same.
    functionSignature: func areEqual(nums []int) bool
    testCases:
    - input: '[]int{5, 5, 5}'
      output: 'true'
    - input: '[]int{5, 5, 6}'
      output: 'false'
    hints:
    - title: Think about it
      content: If all are equal, they all equal the first element.
    - title: Hint
      content: Compare each element to nums[0]. If any differs, return false.
    - title: Pattern
      content: |-
        <pre>1. For each num:
           - num != nums[0]? → return false
        2. Return true (all equal)</pre>
    solution: |-
      func areEqual(nums []int) bool {
          for _, n := range nums {
              if n != nums[0] { return false }
          }
          return true
      }
    difficulty: 1
  - id: v2
    title: Has Adjacent Equal
    description: |-
      Write <code>func hasAdjacentEqual(nums []int) bool</code> - true if any two adjacent elements are equal.
    functionSignature: func hasAdjacentEqual(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 2, 3}'
      output: 'true'
    - input: '[]int{1, 2, 3, 4}'
      output: 'false'
    hints:
    - title: Think about it
      content: Loop through, comparing each element to the next one.
    - title: Hint
      content: for i := 0; i < len(nums)-1; i++ - compare nums[i] to nums[i+1].
    - title: Pattern
      content: |-
        <pre>1. For i from 0 to len-2:
           - nums[i] == nums[i+1]? → return true
        2. Return false</pre>
    solution: |-
      func hasAdjacentEqual(nums []int) bool {
          for i := 0; i < len(nums)-1; i++ {
              if nums[i] == nums[i+1] { return true }
          }
          return false
      }
    difficulty: 2
  - id: v3
    title: Is Increasing
    description: |-
      Write <code>func isIncreasing(nums []int) bool</code> - true if each element is greater than the previous.
    functionSignature: func isIncreasing(nums []int) bool
    testCases:
    - input: '[]int{1, 2, 3, 4}'
      output: 'true'
    - input: '[]int{1, 3, 2, 4}'
      output: 'false'
    hints:
    - title: Think about it
      content: Compare adjacent elements - each should be > previous.
    - title: Hint
      content: If nums[i+1] <= nums[i], it's not strictly increasing.
    - title: Pattern
      content: |-
        <pre>1. For i from 0 to len-2:
           - nums[i+1] <= nums[i]? → return false
        2. Return true</pre>
    solution: |-
      func isIncreasing(nums []int) bool {
          for i := 0; i < len(nums)-1; i++ {
              if nums[i+1] <= nums[i] { return false }
          }
          return true
      }
    difficulty: 2
  - id: v4
    title: First Greater Index
    description: |-
      Write <code>func firstGreater(nums []int, threshold int) int</code> - index of first element > threshold, or -1.
    functionSignature: func firstGreater(nums []int, threshold int) int
    testCases:
    - input: '[]int{1, 3, 5, 7}, 4'
      output: '2'
      note: 5 is first > 4
    - input: '[]int{1, 2, 3}, 10'
      output: '-1'
    hints:
    - title: Think about it
      content: Loop through with index, return index when you find one > threshold.
    - title: Hint
      content: for i, n := range nums - if n > threshold return i.
    - title: Pattern
      content: |-
        <pre>1. For i, num:
           - num > threshold? → return i
        2. Return -1</pre>
    solution: |-
      func firstGreater(nums []int, threshold int) int {
          for i, n := range nums {
              if n > threshold { return i }
          }
          return -1
      }
    difficulty: 2
  - id: v5
    title: Starts With Same
    description: |-
      Write <code>func startsWithSame(nums []int, k int) bool</code> - true if first k elements are all equal.
    functionSignature: func startsWithSame(nums []int, k int) bool
    testCases:
    - input: '[]int{5, 5, 5, 7}, 3'
      output: 'true'
    - input: '[]int{5, 5, 6, 7}, 3'
      output: 'false'
    hints:
    - title: Think about it
      content: Check if first k elements all equal nums[0].
    - title: Hint
      content: Loop i from 0 to k-1, compare nums[i] to nums[0].
    - title: Pattern
      content: |-
        <pre>1. For i from 0 to k-1:
           - nums[i] != nums[0]? → return false
        2. Return true</pre>
    solution: |-
      func startsWithSame(nums []int, k int) bool {
          for i := 0; i < k; i++ {
              if nums[i] != nums[0] { return false }
          }
          return true
      }
    difficulty: 1
  - id: v6
    title: Longest Streak of Value
    description: |-
      Write <code>func longestStreak(nums []int, target int) int</code> - length of longest consecutive run of target.
    functionSignature: func longestStreak(nums []int, target int) int
    testCases:
    - input: '[]int{1, 2, 2, 2, 1, 2, 2}, 2'
      output: '3'
      note: three 2's in a row
    - input: '[]int{1, 1, 3, 1}, 1'
      output: '2'
    hints:
    - title: Think about it
      content: |-
        Track current streak and max streak. When you see target, increment current. When you don't, reset current.
    - title: Hint
      content: Keep current and max variables. Update max whenever current > max.
    - title: Pattern
      content: |-
        <pre>1. current, max := 0, 0
        2. For each num:
           - num == target? → current++, update max
           - else → current = 0
        3. Return max</pre>
    solution: |-
      func longestStreak(nums []int, target int) int {
          current, max := 0, 0
          for _, n := range nums {
              if n == target {
                  current++
                  if current > max { max = current }
              } else {
                  current = 0
              }
          }
          return max
      }
    difficulty: 3
  - id: v7
    title: All Positive
    description: |-
      Write <code>func allPositive(nums []int) bool</code> that returns true if all numbers are greater than 0.
    functionSignature: func allPositive(nums []int) bool
    testCases:
    - input: '[]int{1, 5, 10, 3}'
      output: 'true'
    - input: '[]int{1, 0, 5}'
      output: 'false'
    hints:
    - title: Think about it
      content: Check each number. If any is <= 0, return false immediately.
    - title: Hint
      content: 'Early return pattern: as soon as you find non-positive, return false.'
    - title: Pattern
      content: |-
        <pre>1. For each num:
           - num <= 0? → return false
        2. Return true</pre>
    solution: |-
      func allPositive(nums []int) bool {
          for _, n := range nums {
              if n <= 0 { return false }
          }
          return true
      }
    difficulty: 1
  - id: v8
    title: Price Drop Count
    description: |-
      Write <code>func priceDrops(prices []float64) int</code> that counts how many times price decreased from one day to next.
    functionSignature: func priceDrops(prices []float64) int
    testCases:
    - input: '[]float64{100.0, 95.0, 97.0, 90.0}'
      output: '2'
      note: 100→95 and 97→90
    - input: '[]float64{50.0, 55.0, 60.0}'
      output: '0'
    hints:
    - title: Think about it
      content: Compare adjacent prices. Count when prices[i+1] < prices[i].
    - title: Hint
      content: Loop through indices, increment counter when next price is lower than
        current.
    - title: Pattern
      content: |-
        <pre>1. count := 0
        2. For i from 0 to len-2:
           - prices[i+1] < prices[i]? → count++
        3. Return count</pre>
    solution: |-
      func priceDrops(prices []float64) int {
          count := 0
          for i := 0; i < len(prices)-1; i++ {
              if prices[i+1] < prices[i] { count++ }
          }
          return count
      }
    difficulty: 2
  - id: v9
    title: Length Matches Position
    description: |-
      Write <code>func lengthMatchesPos(words []string) bool</code> - true if each word's length equals its position+1.
    functionSignature: func lengthMatchesPos(words []string) bool
    testCases:
    - input: '[]string{"a", "hi", "cat", "dogs"}'
      output: 'true'
      note: 'lengths: 1,2,3,4'
    - input: '[]string{"a", "ab", "abc"}'
      output: 'false'
      note: |-
        position 1: "ab" has length 2, needs 2 ✓; position 2: "abc" has length 3, needs 3 ✓... wait this should be true!
    hints:
    - title: Think about it
      content: For each word at index i, check if len(word) == i+1.
    - title: Hint
      content: 'Loop with index: if len(words[i]) != i+1, return false.'
    - title: Pattern
      content: |-
        <pre>1. For i, word:
           - len(word) != i+1? → return false
        2. Return true</pre>
    solution: |-
      func lengthMatchesPos(words []string) bool {
          for i, word := range words {
              if len(word) != i+1 { return false }
          }
          return true
      }
    difficulty: 2
  - id: v10
    title: Find All Peaks
    description: |-
      Write <code>func findAllPeaks(nums []int) []int</code> that returns the indices where an element is greater than both its neighbors. First and last elements cannot be peaks.
    functionSignature: func findAllPeaks(nums []int) []int
    testCases:
    - input: '[]int{1, 3, 2, 4, 1}'
      output: '[1, 3]'
      note: nums[1]=3 > neighbors (1,2); nums[3]=4 > neighbors (2,1)
    - input: '[]int{1, 2, 3, 4}'
      output: '[]'
      note: monotonic increasing, no peaks
    hints:
    - title: Think about it
      content: |-
        A peak is at index i where nums[i] > nums[i-1] AND nums[i] > nums[i+1]. Loop from index 1 to len-2 (excluding first and last).
    - title: Hint
      content: |-
        Create empty result slice. Loop i from 1 to len(nums)-2. If nums[i] > nums[i-1] && nums[i] > nums[i+1], append i to result.
    - title: Pattern
      content: |-
        <pre>1. result := []int{}
        2. For i from 1 to len-2:
           - nums[i] > both neighbors?
             → append i to result
        3. Return result</pre>
    solution: "func findAllPeaks(nums []int) []int {\n    result := []int{}\n    \n\
      \    for i := 1; i < len(nums)-1; i++ {\n        if nums[i] > nums[i-1] && nums[i]\
      \ > nums[i+1] {\n            result = append(result, i)\n        }\n    }\n\
      \    \n    return result\n}"
    difficulty: 3
  - id: v11
    title: Longest Increasing Sequence
    description: |-
      Write <code>func longestIncreasingLength(nums []int) int</code> that finds the length of the longest consecutive increasing subsequence.
    functionSignature: func longestIncreasingLength(nums []int) int
    testCases:
    - input: '[]int{1, 2, 3, 1, 2, 3, 4, 5}'
      output: '5'
      note: sequence 1,2,3,4,5 at end
    - input: '[]int{5, 4, 3, 2, 1}'
      output: '1'
      note: all decreasing, max streak is 1
    hints:
    - title: Think about it
      content: |-
        Track the current streak length and the maximum streak seen so far. When nums[i] > nums[i-1], increment streak. Otherwise, reset streak to 1.
    - title: Hint
      content: |-
        currentStreak := 1, maxStreak := 1. For each i from 1 to end: if nums[i] > nums[i-1], currentStreak++, else currentStreak = 1. Update maxStreak if currentStreak is larger.
    - title: Pattern
      content: |-
        <pre>1. currentStreak = 1, maxStreak = 1
        2. For i from 1 to len:
           - Increasing? → currentStreak++
           - Not? → currentStreak = 1
           - Update maxStreak
        3. Return maxStreak</pre>
    solution: "func longestIncreasingLength(nums []int) int {\n    if len(nums) ==\
      \ 0 { return 0 }\n    \n    currentStreak := 1\n    maxStreak := 1\n    \n \
      \   for i := 1; i < len(nums); i++ {\n        if nums[i] > nums[i-1] {\n   \
      \         currentStreak++\n            if currentStreak > maxStreak {\n    \
      \            maxStreak = currentStreak\n            }\n        } else {\n  \
      \          currentStreak = 1\n        }\n    }\n    \n    return maxStreak\n\
      }"
    difficulty: 3
  - id: v12
    title: Count Direction Changes
    description: |-
      Write <code>func countDirectionChanges(nums []int) int</code> that counts how many times the sequence changes from increasing to decreasing or vice versa.
    functionSignature: func countDirectionChanges(nums []int) int
    testCases:
    - input: '[]int{1, 3, 2, 4, 3}'
      output: '3'
      note: up(1→3), down(3→2), up(2→4), down(4→3) = 3 changes
    - input: '[]int{1, 2, 3}'
      output: '0'
      note: monotonic increasing, no direction changes
    hints:
    - title: Think about it
      content: |-
        Track whether you're currently going up or down. When the direction switches, increment the change counter.
    - title: Hint
      content: |-
        Start with direction based on first two elements. For each next element, determine new direction. If it differs from previous direction, count a change.
    - title: Pattern
      content: |-
        <pre>1. Determine initial direction
        2. changes := 0
        3. For each next pair:
           - Determine new direction
           - Different from previous? → changes++
           - Update previous direction
        4. Return changes</pre>
    solution: "func countDirectionChanges(nums []int) int {\n    if len(nums) < 2\
      \ { return 0 }\n    \n    changes := 0\n    var prevDirection string\n    \n\
      \    for i := 1; i < len(nums); i++ {\n        var currentDirection string\n\
      \        if nums[i] > nums[i-1] {\n            currentDirection = \"up\"\n \
      \       } else if nums[i] < nums[i-1] {\n            currentDirection = \"down\"\
      \n        } else {\n            continue\n        }\n        \n        if prevDirection\
      \ != \"\" && currentDirection != prevDirection {\n            changes++\n  \
      \      }\n        prevDirection = currentDirection\n    }\n    \n    return\
      \ changes\n}"
    difficulty: 3
- id: challenge_15
  block: 2
  difficulty: 1
  concept: Recursion
  sharedContentRef: advanced_recursion
  docLinks:
  - url: https://go.dev/ref/spec#Function_declarations
    title: 'Go Spec: Function declarations'
    note: recursive functions
  - url: https://go.dev/ref/spec#If_statements
    title: 'Go Spec: If statements'
    note: base case conditions
  patternPrimer:
    bruteForce: Use loops to solve iteratively.
    bestApproach: |-
      Identify the base case and recursive case. Each recursive call should reduce the problem size toward the base case.
    typical: Time varies; space O(n) due to call stack
  variants:
  - id: v1
    title: Recursive Sum to N
    description: |-
      Write <code>func sumToN(n int) int</code> that returns the sum 1+2+...+n using recursion. sumToN(0) should return 0.
    functionSignature: func sumToN(n int) int
    difficulty: 1
    testCases:
    - input: '5'
      output: '15'
    - input: '0'
      output: '0'
    - input: '1'
      output: '1'
    - input: '10'
      output: '55'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        What is the simplest case? When n is 0, the sum is 0. For any other n, the sum is n plus the sum of everything before it.
    - title: í ½í²¡ Hint
      content: 'Base case: if n <= 0, return 0. Recursive case: return n + sumToN(n-1).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>func sumToN(n int) int {
            if n <= 0 { return 0 }  // base case
            return n + sumToN(n-1)  // recursive case
        }</pre>
    solution: |-
      func sumToN(n int) int {
          if n <= 0 {
              return 0
          }
          return n + sumToN(n-1)
      }
  - id: v2
    title: Recursive Factorial
    description: |-
      Write <code>func factorial(n int) int</code> that returns n! using recursion. 0! = 1.
    functionSignature: func factorial(n int) int
    difficulty: 1
    testCases:
    - input: '5'
      output: '120'
    - input: '0'
      output: '1'
    - input: '1'
      output: '1'
    - input: '7'
      output: '5040'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Factorial means n * (n-1) * (n-2) * ... * 1. What's the simplest factorial? 0! = 1.
    - title: í ½í²¡ Hint
      content: 'Base case: n <= 0 returns 1. Recursive case: n * factorial(n-1).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if n <= 0 { return 1 }
        return n * factorial(n-1)</pre>
    solution: |-
      func factorial(n int) int {
          if n <= 0 {
              return 1
          }
          return n * factorial(n-1)
      }
  - id: v3
    title: Recursive Power
    description: |-
      Write <code>func power(base, exp int) int</code> that returns base^exp using recursion. Assume exp >= 0.
    functionSignature: func power(base, exp int) int
    difficulty: 1
    testCases:
    - input: 2, 3
      output: '8'
    - input: 5, 0
      output: '1'
    - input: 3, 4
      output: '81'
    - input: 10, 2
      output: '100'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: base^0 = 1 for any base. base^exp = base * base^(exp-1).
    - title: í ½í²¡ Hint
      content: 'Base case: exp == 0 returns 1. Recursive case: base * power(base,
        exp-1).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if exp == 0 { return 1 }
        return base * power(base, exp-1)</pre>
    solution: |-
      func power(base, exp int) int {
          if exp == 0 {
              return 1
          }
          return base * power(base, exp-1)
      }
  - id: v4
    title: Recursive Count Digits
    description: |-
      Write <code>func countDigits(n int) int</code> that returns the number of digits in n using recursion. Treat negative numbers as positive. countDigits(0) = 1.
    functionSignature: func countDigits(n int) int
    difficulty: 1
    testCases:
    - input: '12345'
      output: '5'
    - input: '0'
      output: '1'
    - input: '9'
      output: '1'
    - input: '-42'
      output: '2'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        A single digit number (0-9) has 1 digit. For larger numbers, remove the last digit (n/10) and add 1.
    - title: í ½í²¡ Hint
      content: |-
        Handle negatives first (make positive). Base case: n < 10 returns 1. Recursive: 1 + countDigits(n/10).
    - title: í ½í´§ Pattern
      content: |-
        <pre>if n < 0 { n = -n }
        if n < 10 { return 1 }
        return 1 + countDigits(n/10)</pre>
    solution: |-
      func countDigits(n int) int {
          if n < 0 {
              n = -n
          }
          if n < 10 {
              return 1
          }
          return 1 + countDigits(n/10)
      }
  - id: v5
    title: Recursive Sum of Digits
    description: |-
      Write <code>func digitSum(n int) int</code> that returns the sum of digits of n using recursion. Treat negative numbers as positive.
    functionSignature: func digitSum(n int) int
    difficulty: 1
    testCases:
    - input: '123'
      output: '6'
    - input: '0'
      output: '0'
    - input: '999'
      output: '27'
    - input: '-45'
      output: '9'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: The last digit is n%10. The remaining digits are n/10. Sum them up
        recursively.
    - title: í ½í²¡ Hint
      content: |-
        Base case: n == 0 returns 0. Recursive: (n%10) + digitSum(n/10). Handle negatives first.
    - title: í ½í´§ Pattern
      content: |-
        <pre>if n < 0 { n = -n }
        if n == 0 { return 0 }
        return n%10 + digitSum(n/10)</pre>
    solution: |-
      func digitSum(n int) int {
          if n < 0 {
              n = -n
          }
          if n == 0 {
              return 0
          }
          return n%10 + digitSum(n/10)
      }
  - id: v6
    title: Recursive Fibonacci
    description: |-
      Write <code>func fib(n int) int</code> that returns the nth Fibonacci number. fib(0)=0, fib(1)=1, fib(n)=fib(n-1)+fib(n-2).
    functionSignature: func fib(n int) int
    difficulty: 1
    testCases:
    - input: '0'
      output: '0'
    - input: '1'
      output: '1'
    - input: '6'
      output: '8'
    - input: '10'
      output: '55'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Fibonacci has TWO base cases: fib(0)=0 and fib(1)=1. Every other value needs two recursive calls.
    - title: í ½í²¡ Hint
      content: 'Base cases: n==0 returns 0, n==1 returns 1. Recursive: fib(n-1) +
        fib(n-2).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if n <= 0 { return 0 }
        if n == 1 { return 1 }
        return fib(n-1) + fib(n-2)</pre>
    solution: |-
      func fib(n int) int {
          if n <= 0 {
              return 0
          }
          if n == 1 {
              return 1
          }
          return fib(n-1) + fib(n-2)
      }
  - id: v7
    title: Recursive String Length
    description: |-
      Write <code>func strLen(s string) int</code> that returns the length of a string using recursion (no len() allowed in recursive logic).
    functionSignature: func strLen(s string) int
    difficulty: 1
    testCases:
    - input: '"hello"'
      output: '5'
    - input: '""'
      output: '0'
    - input: '"a"'
      output: '1'
    - input: '"Go lang"'
      output: '7'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        An empty string has length 0. Otherwise, it's 1 + the length of the string without its first character.
    - title: í ½í²¡ Hint
      content: 'Base case: s == "" returns 0. Recursive: 1 + strLen(s[1:]).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if s == "" { return 0 }
        return 1 + strLen(s[1:])</pre>
    solution: |-
      func strLen(s string) int {
          if s == "" {
              return 0
          }
          return 1 + strLen(s[1:])
      }
  - id: v8
    title: Recursive Reverse String
    description: |-
      Write <code>func reverseStr(s string) string</code> that reverses a string using recursion.
    functionSignature: func reverseStr(s string) string
    difficulty: 2
    testCases:
    - input: '"hello"'
      output: '"olleh"'
    - input: '""'
      output: '""'
    - input: '"a"'
      output: '"a"'
    - input: '"abcd"'
      output: '"dcba"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: 'To reverse "hello": reverse "ello" to get "olle", then add "h" at
        the end.'
    - title: í ½í²¡ Hint
      content: 'Base case: len(s) <= 1 returns s. Recursive: reverseStr(s[1:]) + string(s[0]).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if len(s) <= 1 { return s }
        return reverseStr(s[1:]) + string(s[0])</pre>
    solution: |-
      func reverseStr(s string) string {
          if len(s) <= 1 {
              return s
          }
          return reverseStr(s[1:]) + string(s[0])
      }
  - id: v9
    title: Recursive GCD
    description: |-
      Write <code>func gcd(a, b int) int</code> that returns the greatest common divisor using Euclid's algorithm recursively. gcd(a, 0) = a.
    functionSignature: func gcd(a, b int) int
    difficulty: 2
    testCases:
    - input: 12, 8
      output: '4'
    - input: 7, 0
      output: '7'
    - input: 100, 75
      output: '25'
    - input: 17, 13
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: 'Euclid''s insight: gcd(a, b) = gcd(b, a%b). The base case is when
        b is 0.'
    - title: í ½í²¡ Hint
      content: 'Base case: b == 0 returns a. Recursive: gcd(b, a%b).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if b == 0 { return a }
        return gcd(b, a%b)</pre>
    solution: |-
      func gcd(a, b int) int {
          if b == 0 {
              return a
          }
          return gcd(b, a%b)
      }
  - id: v10
    title: Recursive Palindrome Check
    description: |-
      Write <code>func isPalindrome(s string) bool</code> that checks if a string is a palindrome using recursion.
    functionSignature: func isPalindrome(s string) bool
    difficulty: 2
    testCases:
    - input: '"racecar"'
      output: 'true'
    - input: '"hello"'
      output: 'false'
    - input: '"a"'
      output: 'true'
    - input: '"abba"'
      output: 'true'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        A palindrome reads the same forwards and backwards. Check if the first and last characters match, then check the middle.
    - title: í ½í²¡ Hint
      content: |-
        Base case: len(s) <= 1 returns true. If first != last, return false. Otherwise recurse on s[1:len(s)-1].
    - title: í ½í´§ Pattern
      content: |-
        <pre>if len(s) <= 1 { return true }
        if s[0] != s[len(s)-1] { return false }
        return isPalindrome(s[1:len(s)-1])</pre>
    solution: |-
      func isPalindrome(s string) bool {
          if len(s) <= 1 {
              return true
          }
          if s[0] != s[len(s)-1] {
              return false
          }
          return isPalindrome(s[1 : len(s)-1])
      }
  - id: v11
    title: Recursive Flatten
    description: |-
      Write <code>func flatten(nested [][]int) []int</code> that flattens a 2D slice into a 1D slice using recursion.
    functionSignature: func flatten(nested [][]int) []int
    difficulty: 2
    testCases:
    - input: '[][]int{{1,2},{3,4},{5}}'
      output: '[]int{1,2,3,4,5}'
    - input: '[][]int{}'
      output: '[]int{}'
    - input: '[][]int{{1}}'
      output: '[]int{1}'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Process the first sub-slice, then recursively flatten the rest and
        combine.
    - title: í ½í²¡ Hint
      content: |-
        Base case: empty outer slice returns empty. Recursive: append first sub-slice elements with flatten(nested[1:])...
    - title: í ½í´§ Pattern
      content: |-
        <pre>if len(nested) == 0 { return []int{} }
        return append(nested[0], flatten(nested[1:])...)</pre>
    solution: |-
      func flatten(nested [][]int) []int {
          if len(nested) == 0 {
              return []int{}
          }
          return append(nested[0], flatten(nested[1:])...)
      }
  - id: v12
    title: Recursive Binary Representation
    description: |-
      Write <code>func toBinary(n int) string</code> that returns the binary representation of a non-negative integer as a string using recursion. toBinary(0) = "0".
    functionSignature: func toBinary(n int) string
    difficulty: 3
    testCases:
    - input: '0'
      output: '"0"'
    - input: '5'
      output: '"101"'
    - input: '10'
      output: '"1010"'
    - input: '1'
      output: '"1"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Binary works by repeatedly dividing by 2. The remainder gives you the last digit, and the quotient gives you the remaining digits.
    - title: í ½í²¡ Hint
      content: |-
        Base case: n <= 0 returns "0", n == 1 returns "1". Recursive: toBinary(n/2) + last digit (n%2 as string).
    - title: í ½í´§ Pattern
      content: |-
        <pre>import "strconv"
        if n <= 0 { return "0" }
        if n == 1 { return "1" }
        return toBinary(n/2) + strconv.Itoa(n%2)</pre>
    solution: |-
      func toBinary(n int) string {
          if n <= 0 {
              return "0"
          }
          if n == 1 {
              return "1"
          }
          return toBinary(n/2) + strconv.Itoa(n%2)
      }
  - id: v13
    title: Recursive Permutation Count
    description: |-
      Write <code>func permutations(n, r int) int</code> that calculates P(n,r) = n!/(n-r)! using recursion. Use the identity P(n,r) = n * P(n-1, r-1) with base case P(n,0) = 1.
    functionSignature: func permutations(n, r int) int
    difficulty: 3
    testCases:
    - input: 5, 2
      output: '20'
    - input: 4, 0
      output: '1'
    - input: 6, 3
      output: '120'
    - input: 3, 3
      output: '6'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        P(n,r) picks r items from n in order. P(n,0) = 1 (one way to pick nothing). Otherwise, pick one of n, then pick r-1 from remaining n-1.
    - title: í ½í²¡ Hint
      content: 'Base case: r == 0 returns 1. Recursive: n * permutations(n-1, r-1).'
    - title: í ½í´§ Pattern
      content: |-
        <pre>if r == 0 { return 1 }
        return n * permutations(n-1, r-1)</pre>
    solution: |-
      func permutations(n, r int) int {
          if r == 0 {
              return 1
          }
          return n * permutations(n-1, r-1)
      }
  - id: v14
    title: Recursive Merge Sorted
    description: |-
      Write <code>func mergeSorted(a, b []int) []int</code> that merges two sorted slices into one sorted slice using recursion.
    functionSignature: func mergeSorted(a, b []int) []int
    difficulty: 3
    testCases:
    - input: '[]int{1,3,5}, []int{2,4,6}'
      output: '[]int{1,2,3,4,5,6}'
    - input: '[]int{}, []int{1,2}'
      output: '[]int{1,2}'
    - input: '[]int{1}, []int{}'
      output: '[]int{1}'
    - input: '[]int{1,1}, []int{1,1}'
      output: '[]int{1,1,1,1}'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        If either slice is empty, return the other. Otherwise, compare the first elements: take the smaller one and recurse with the rest.
    - title: í ½í²¡ Hint
      content: |-
        Base cases: a empty returns b, b empty returns a. Compare a[0] vs b[0]: take smaller, prepend to recursive merge of the rest.
    - title: í ½í´§ Pattern
      content: |-
        <pre>if len(a) == 0 { return b }
        if len(b) == 0 { return a }
        if a[0] <= b[0] {
            return append([]int{a[0]}, mergeSorted(a[1:], b)...)
        }
        return append([]int{b[0]}, mergeSorted(a, b[1:])...)</pre>
    solution: |-
      func mergeSorted(a, b []int) []int {
          if len(a) == 0 {
              return b
          }
          if len(b) == 0 {
              return a
          }
          if a[0] <= b[0] {
              return append([]int{a[0]}, mergeSorted(a[1:], b)...)
          }
          return append([]int{b[0]}, mergeSorted(a, b[1:])...)
      }
  - id: v15
    title: Recursive Subsets
    description: |-
      Write <code>func countSubsets(n, k int) int</code> that returns the number of ways to choose k items from n (combinations C(n,k)) using recursion. C(n,0)=1, C(n,n)=1, C(n,k)=C(n-1,k-1)+C(n-1,k).
    functionSignature: func countSubsets(n, k int) int
    difficulty: 3
    testCases:
    - input: 5, 2
      output: '10'
    - input: 4, 0
      output: '1'
    - input: 4, 4
      output: '1'
    - input: 6, 3
      output: '20'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Pascal's triangle! C(n,k) = C(n-1,k-1) + C(n-1,k). Base cases: choosing 0 items or all items gives 1 way.
    - title: í ½í²¡ Hint
      content: |-
        Base cases: k==0 or k==n returns 1. Recursive: countSubsets(n-1, k-1) + countSubsets(n-1, k).
    - title: í ½í´§ Pattern
      content: |-
        <pre>if k == 0 || k == n { return 1 }
        return countSubsets(n-1, k-1) + countSubsets(n-1, k)</pre>
    solution: |-
      func countSubsets(n, k int) int {
          if k == 0 || k == n {
              return 1
          }
          return countSubsets(n-1, k-1) + countSubsets(n-1, k)
      }
- id: challenge_16
  block: 3
  difficulty: 1
  concept: Binary Search
  sharedContentRef: advanced_binary_search
  docLinks:
  - url: https://go.dev/ref/spec#For_statements
    title: 'Go Spec: For statements'
    note: while-style loops
  - url: https://pkg.go.dev/sort
    title: Package sort
    note: Go's sort utilities
  patternPrimer:
    bruteForce: Linear scan through the entire array O(n).
    bestApproach: Binary search halves the search space each step O(log n). Requires
      sorted input.
    typical: O(log n) time, O(1) space
  variants:
  - id: v1
    title: Basic Binary Search
    description: |-
      Write <code>func binarySearch(nums []int, target int) int</code> that returns the index of target in a sorted slice, or -1 if not found.
    functionSignature: func binarySearch(nums []int, target int) int
    difficulty: 1
    testCases:
    - input: '[]int{1,3,5,7,9}, 5'
      output: '2'
    - input: '[]int{1,3,5,7,9}, 4'
      output: '-1'
    - input: '[]int{2,4,6,8}, 2'
      output: '0'
    - input: '[]int{2,4,6,8}, 8'
      output: '3'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        The array is sorted. If you check the middle element, you know which half the target must be in.
    - title: í ½í²¡ Hint
      content: |-
        Set low=0, high=len-1. Loop while low <= high. Calculate mid=(low+high)/2. Compare nums[mid] to target and adjust low or high.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target { return mid }
            else if nums[mid] < target { low = mid+1 }
            else { high = mid-1 }
        }
        return -1</pre>
    solution: |-
      func binarySearch(nums []int, target int) int {
          low, high := 0, len(nums)-1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  return mid
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return -1
      }
  - id: v2
    title: Search Insert Position
    description: |-
      Write <code>func searchInsert(nums []int, target int) int</code> that returns the index where target is found, or where it would be inserted to keep the slice sorted.
    functionSignature: func searchInsert(nums []int, target int) int
    difficulty: 1
    testCases:
    - input: '[]int{1,3,5,6}, 5'
      output: '2'
    - input: '[]int{1,3,5,6}, 2'
      output: '1'
    - input: '[]int{1,3,5,6}, 7'
      output: '4'
    - input: '[]int{1,3,5,6}, 0'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        This is like binary search, but instead of returning -1 when not found, return where it would go.
    - title: í ½í²¡ Hint
      content: |-
        Standard binary search, but when the loop ends (low > high), the insertion point is low.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target { return mid }
            else if nums[mid] < target { low = mid+1 }
            else { high = mid-1 }
        }
        return low  // insertion point</pre>
    solution: |-
      func searchInsert(nums []int, target int) int {
          low, high := 0, len(nums)-1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  return mid
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return low
      }
  - id: v3
    title: Binary Search Boolean
    description: |-
      Write <code>func exists(nums []int, target int) bool</code> that returns true if target exists in the sorted slice.
    functionSignature: func exists(nums []int, target int) bool
    difficulty: 1
    testCases:
    - input: '[]int{1,2,3,4,5}, 3'
      output: 'true'
    - input: '[]int{1,2,3,4,5}, 6'
      output: 'false'
    - input: '[]int{10,20,30}, 10'
      output: 'true'
    - input: '[]int{}, 1'
      output: 'false'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Same as basic binary search but return bool instead of index.
    - title: í ½í²¡ Hint
      content: Run binary search. If you find target, return true. If loop ends, return
        false.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target { return true }
            ...
        }
        return false</pre>
    solution: |-
      func exists(nums []int, target int) bool {
          low, high := 0, len(nums)-1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  return true
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return false
      }
  - id: v4
    title: Count Target Occurrences
    description: |-
      Write <code>func countTarget(nums []int, target int) int</code> that counts how many times target appears in a sorted slice. Use binary search to find it, then expand left and right.
    functionSignature: func countTarget(nums []int, target int) int
    difficulty: 1
    testCases:
    - input: '[]int{1,2,2,2,3,4}, 2'
      output: '3'
    - input: '[]int{1,1,1,1}, 1'
      output: '4'
    - input: '[]int{1,2,3}, 5'
      output: '0'
    - input: '[]int{}, 1'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Find any occurrence with binary search, then count outward in both directions since the array is sorted.
    - title: í ½í²¡ Hint
      content: |-
        Binary search to find one occurrence. Then use two loops: expand left while equal, expand right while equal. Count total.
    - title: í ½í´§ Pattern
      content: |-
        <pre>1. Binary search to find target at index mid
        2. If not found, return 0
        3. count = 1, expand left (mid-1, mid-2...) while equal
        4. Expand right (mid+1, mid+2...) while equal
        5. Return count</pre>
    solution: |-
      func countTarget(nums []int, target int) int {
          low, high := 0, len(nums)-1
          idx := -1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  idx = mid
                  break
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          if idx == -1 {
              return 0
          }
          count := 1
          for i := idx - 1; i >= 0 && nums[i] == target; i-- {
              count++
          }
          for i := idx + 1; i < len(nums) && nums[i] == target; i++ {
              count++
          }
          return count
      }
  - id: v5
    title: First Occurrence
    description: |-
      Write <code>func firstOccurrence(nums []int, target int) int</code> that returns the index of the first occurrence of target in a sorted slice, or -1 if not found.
    functionSignature: func firstOccurrence(nums []int, target int) int
    difficulty: 2
    testCases:
    - input: '[]int{1,2,2,2,3}, 2'
      output: '1'
    - input: '[]int{1,1,1}, 1'
      output: '0'
    - input: '[]int{1,2,3}, 4'
      output: '-1'
    - input: '[]int{5,5,5,5}, 5'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Standard binary search finds ANY occurrence. To find the FIRST, when you find target, don't stop - keep searching left.
    - title: í ½í²¡ Hint
      content: |-
        When nums[mid] == target, save result and set high = mid-1 to keep searching left for an earlier occurrence.
    - title: í ½í´§ Pattern
      content: |-
        <pre>result := -1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target {
                result = mid
                high = mid - 1  // keep looking left
            } else if nums[mid] < target {
                low = mid + 1
            } else {
                high = mid - 1
            }
        }
        return result</pre>
    solution: |-
      func firstOccurrence(nums []int, target int) int {
          low, high := 0, len(nums)-1
          result := -1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  result = mid
                  high = mid - 1
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return result
      }
  - id: v6
    title: Last Occurrence
    description: |-
      Write <code>func lastOccurrence(nums []int, target int) int</code> that returns the index of the last occurrence of target in a sorted slice, or -1 if not found.
    functionSignature: func lastOccurrence(nums []int, target int) int
    difficulty: 2
    testCases:
    - input: '[]int{1,2,2,2,3}, 2'
      output: '3'
    - input: '[]int{1,1,1}, 1'
      output: '2'
    - input: '[]int{1,2,3}, 4'
      output: '-1'
    - input: '[]int{5}, 5'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Mirror of first occurrence: when you find target, keep searching right instead of left.
    - title: í ½í²¡ Hint
      content: |-
        When nums[mid] == target, save result and set low = mid+1 to keep searching right.
    - title: í ½í´§ Pattern
      content: |-
        <pre>result := -1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target {
                result = mid
                low = mid + 1  // keep looking right
            } ...
        }
        return result</pre>
    solution: |-
      func lastOccurrence(nums []int, target int) int {
          low, high := 0, len(nums)-1
          result := -1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  result = mid
                  low = mid + 1
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return result
      }
  - id: v7
    title: Square Root (Integer)
    description: |-
      Write <code>func intSqrt(n int) int</code> that returns the integer square root of n (largest integer whose square is <= n). Assume n >= 0.
    functionSignature: func intSqrt(n int) int
    difficulty: 2
    testCases:
    - input: '16'
      output: '4'
    - input: '8'
      output: '2'
    - input: '0'
      output: '0'
    - input: '1'
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Binary search isn't just for arrays! Search the range [0, n] for the largest value whose square <= n.
    - title: í ½í²¡ Hint
      content: |-
        low=0, high=n. If mid*mid <= n, save mid as answer and search right (low=mid+1). If mid*mid > n, search left (high=mid-1).
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high, result := 0, n, 0
        for low <= high {
            mid := (low+high)/2
            if mid*mid <= n {
                result = mid
                low = mid + 1
            } else {
                high = mid - 1
            }
        }
        return result</pre>
    solution: |-
      func intSqrt(n int) int {
          low, high, result := 0, n, 0
          for low <= high {
              mid := (low + high) / 2
              if mid*mid <= n {
                  result = mid
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          return result
      }
  - id: v8
    title: Find Peak Element
    description: |-
      Write <code>func findPeak(nums []int) int</code> that returns the index of any peak element (an element greater than its neighbors). Assume nums has at least one element and nums[-1] = nums[n] = negative infinity.
    functionSignature: func findPeak(nums []int) int
    difficulty: 3
    testCases:
    - input: '[]int{1,3,2}'
      output: '1'
    - input: '[]int{1,2,3,1}'
      output: '2'
    - input: '[]int{5,4,3,2,1}'
      output: '0'
    - input: '[]int{1}'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        If the middle element is less than its right neighbor, a peak must exist on the right side. Why? Because values go up, and they must come down eventually (boundary is -infinity).
    - title: í ½í²¡ Hint
      content: |-
        Binary search: if nums[mid] < nums[mid+1], search right (low=mid+1). Otherwise search left (high=mid). When low==high, that's a peak.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low < high {
            mid := (low+high)/2
            if nums[mid] < nums[mid+1] {
                low = mid + 1
            } else {
                high = mid
            }
        }
        return low</pre>
    solution: |-
      func findPeak(nums []int) int {
          low, high := 0, len(nums)-1
          for low < high {
              mid := (low + high) / 2
              if nums[mid] < nums[mid+1] {
                  low = mid + 1
              } else {
                  high = mid
              }
          }
          return low
      }
  - id: v9
    title: Minimum in Rotated Sorted Array
    description: |-
      Write <code>func findMin(nums []int) int</code> that finds the minimum element in a sorted array that has been rotated. Example: [4,5,6,1,2,3] was [1,2,3,4,5,6] rotated. All elements are unique.
    functionSignature: func findMin(nums []int) int
    difficulty: 3
    testCases:
    - input: '[]int{4,5,6,1,2,3}'
      output: '1'
    - input: '[]int{3,1,2}'
      output: '1'
    - input: '[]int{1,2,3,4}'
      output: '1'
    - input: '[]int{2,1}'
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        In a rotated sorted array, the minimum is the 'rotation point'. Compare the middle element to the last element to determine which half the minimum is in.
    - title: í ½í²¡ Hint
      content: |-
        If nums[mid] > nums[high], the min is in the right half (low=mid+1). Otherwise it's in the left half including mid (high=mid).
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low < high {
            mid := (low+high)/2
            if nums[mid] > nums[high] {
                low = mid + 1
            } else {
                high = mid
            }
        }
        return nums[low]</pre>
    solution: |-
      func findMin(nums []int) int {
          low, high := 0, len(nums)-1
          for low < high {
              mid := (low + high) / 2
              if nums[mid] > nums[high] {
                  low = mid + 1
              } else {
                  high = mid
              }
          }
          return nums[low]
      }
  - id: v10
    title: Search in Rotated Array
    description: |-
      Write <code>func searchRotated(nums []int, target int) int</code> that searches for target in a rotated sorted array. Return index or -1. All elements are unique.
    functionSignature: func searchRotated(nums []int, target int) int
    difficulty: 4
    testCases:
    - input: '[]int{4,5,6,7,0,1,2}, 0'
      output: '4'
    - input: '[]int{4,5,6,7,0,1,2}, 3'
      output: '-1'
    - input: '[]int{1}, 1'
      output: '0'
    - input: '[]int{3,1}, 1'
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        One half of the array is always sorted. Determine which half is sorted, then check if target is in that sorted half.
    - title: í ½í²¡ Hint
      content: |-
        If left half is sorted (nums[low] <= nums[mid]): check if target is in [low, mid]. If right half is sorted: check if target is in [mid, high]. Narrow accordingly.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 0, len(nums)-1
        for low <= high {
            mid := (low+high)/2
            if nums[mid] == target { return mid }
            if nums[low] <= nums[mid] {  // left sorted
                if nums[low] <= target && target < nums[mid] {
                    high = mid-1
                } else { low = mid+1 }
            } else {  // right sorted
                if nums[mid] < target && target <= nums[high] {
                    low = mid+1
                } else { high = mid-1 }
            }
        }
        return -1</pre>
    solution: |-
      func searchRotated(nums []int, target int) int {
          low, high := 0, len(nums)-1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  return mid
              }
              if nums[low] <= nums[mid] {
                  if nums[low] <= target && target < nums[mid] {
                      high = mid - 1
                  } else {
                      low = mid + 1
                  }
              } else {
                  if nums[mid] < target && target <= nums[high] {
                      low = mid + 1
                  } else {
                      high = mid - 1
                  }
              }
          }
          return -1
      }
  - id: v11
    title: Find Closest Value
    description: |-
      Write <code>func findClosest(nums []int, target int) int</code> that returns the value in the sorted slice closest to target. If tie, return the smaller value.
    functionSignature: func findClosest(nums []int, target int) int
    difficulty: 2
    testCases:
    - input: '[]int{1,3,5,7,9}, 6'
      output: '5'
    - input: '[]int{1,3,5,7,9}, 5'
      output: '5'
    - input: '[]int{1,10}, 4'
      output: '1'
    - input: '[]int{1,10}, 6'
      output: '10'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Binary search narrows down to adjacent elements. Compare the target's distance to both.
    - title: í ½í²¡ Hint
      content: |-
        After binary search, low points to the insertion position. Compare nums[low] and nums[low-1] (if they exist) to find which is closer.
    - title: í ½í´§ Pattern
      content: |-
        <pre>1. Binary search for insert position
        2. Compare neighbors at pos and pos-1
        3. Return the closer one (smaller on tie)</pre>
    solution: |-
      func findClosest(nums []int, target int) int {
          low, high := 0, len(nums)-1
          for low <= high {
              mid := (low + high) / 2
              if nums[mid] == target {
                  return nums[mid]
              } else if nums[mid] < target {
                  low = mid + 1
              } else {
                  high = mid - 1
              }
          }
          if low >= len(nums) {
              return nums[len(nums)-1]
          }
          if low == 0 {
              return nums[0]
          }
          if target-nums[low-1] <= nums[low]-target {
              return nums[low-1]
          }
          return nums[low]
      }
  - id: v12
    title: First Bad Version
    description: |-
      Write <code>func firstBad(n int, isBad func(int) bool) int</code> that finds the first bad version in range [1, n]. The function isBad(v) returns true if version v is bad. Once a version is bad, all subsequent versions are bad.
    functionSignature: func firstBad(n int, isBad func(int) bool) int
    difficulty: 1
    testCases:
    - input: 5, isBad (bad=4)
      output: '4'
    - input: 1, isBad (bad=1)
      output: '1'
    - input: 10, isBad (bad=7)
      output: '7'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        This is binary search on a boolean condition. The transition from false to true happens at exactly one point.
    - title: í ½í²¡ Hint
      content: |-
        low=1, high=n. If isBad(mid), the first bad is at mid or before: high=mid. If !isBad(mid), first bad is after: low=mid+1.
    - title: í ½í´§ Pattern
      content: |-
        <pre>low, high := 1, n
        for low < high {
            mid := (low+high)/2
            if isBad(mid) {
                high = mid
            } else {
                low = mid + 1
            }
        }
        return low</pre>
    solution: |-
      func firstBad(n int, isBad func(int) bool) int {
          low, high := 1, n
          for low < high {
              mid := (low + high) / 2
              if isBad(mid) {
                  high = mid
              } else {
                  low = mid + 1
              }
          }
          return low
      }
- id: challenge_17
  block: 3
  difficulty: 1
  concept: Stack Pattern
  sharedContentRef: advanced_stack
  docLinks:
  - url: https://go.dev/ref/spec#Appending_and_copying_slices
    title: 'Go Spec: Appending slices'
    note: push with append
  - url: https://go.dev/ref/spec#Slice_expressions
    title: 'Go Spec: Slice expressions'
    note: pop with re-slicing
  patternPrimer:
    bruteForce: Nested loops or repeated scanning.
    bestApproach: |-
      Use a slice as a stack (LIFO): push with append, pop by re-slicing. Process elements in last-in-first-out order.
    typical: O(n) time, O(n) space
  variants:
  - id: v1
    title: Valid Parentheses
    description: |-
      Write <code>func isValid(s string) bool</code> that checks if a string of parentheses '(' and ')' is valid (every open has a matching close in correct order).
    functionSignature: func isValid(s string) bool
    difficulty: 1
    testCases:
    - input: '"(())"'
      output: 'true'
    - input: '"()()"'
      output: 'true'
    - input: '"(()"'
      output: 'false'
    - input: '")"'
      output: 'false'
    - input: '""'
      output: 'true'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        When you see '(', you expect a ')' later. When you see ')', you need to match the most recent unmatched '('. What data structure handles 'most recent first'?
    - title: í ½í²¡ Hint
      content: |-
        Use a counter or stack. For '(' increment/push, for ')' decrement/pop. If counter goes negative, invalid. At end, must be zero.
    - title: í ½í´§ Pattern
      content: |-
        <pre>count := 0
        for _, ch := range s {
            if ch == '(' { count++ }
            else { count-- }
            if count < 0 { return false }
        }
        return count == 0</pre>
    solution: |-
      func isValid(s string) bool {
          count := 0
          for _, ch := range s {
              if ch == '(' {
                  count++
              } else {
                  count--
              }
              if count < 0 {
                  return false
              }
          }
          return count == 0
      }
  - id: v2
    title: Valid Brackets
    description: |-
      Write <code>func validBrackets(s string) bool</code> that checks if a string containing '(', ')', '[', ']', '{', '}' has valid matching brackets.
    functionSignature: func validBrackets(s string) bool
    difficulty: 1
    testCases:
    - input: '"()[]{}"'
      output: 'true'
    - input: '"{[()]}"'
      output: 'true'
    - input: '"(]"'
      output: 'false'
    - input: '"([)]"'
      output: 'false'
    - input: '""'
      output: 'true'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        A simple counter won't work now because you have different bracket types. You need to remember WHICH bracket was opened.
    - title: í ½í²¡ Hint
      content: |-
        Push opening brackets onto a stack. When you see a closer, pop the stack and check it matches. Use a map to pair closers with their openers.
    - title: í ½í´§ Pattern
      content: |-
        <pre>1. Create stack ([]rune)
        2. For each char:
           - Opener? Push to stack
           - Closer? Pop from stack, check match
           - Empty stack when closing? Invalid
        3. Stack empty at end? Valid</pre>
    solution: |-
      func validBrackets(s string) bool {
          stack := []rune{}
          pairs := map[rune]rune{')': '(', ']': '[', '}': '{'}
          for _, ch := range s {
              switch ch {
              case '(', '[', '{':
                  stack = append(stack, ch)
              case ')', ']', '}':
                  if len(stack) == 0 || stack[len(stack)-1] != pairs[ch] {
                      return false
                  }
                  stack = stack[:len(stack)-1]
              }
          }
          return len(stack) == 0
      }
  - id: v3
    title: Reverse String with Stack
    description: |-
      Write <code>func reverseWithStack(s string) string</code> that reverses a string using a stack pattern (push all chars, then pop them all).
    functionSignature: func reverseWithStack(s string) string
    difficulty: 1
    testCases:
    - input: '"hello"'
      output: '"olleh"'
    - input: '""'
      output: '""'
    - input: '"a"'
      output: '"a"'
    - input: '"abcd"'
      output: '"dcba"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Push every character onto the stack. Then pop them all off. Since stacks are LIFO, you'll get them in reverse order!
    - title: í ½í²¡ Hint
      content: |-
        Push each byte/rune onto a slice. Then pop from the end and build the result string.
    - title: í ½í´§ Pattern
      content: |-
        <pre>stack := []byte{}
        for i := 0; i < len(s); i++ {
            stack = append(stack, s[i])  // push
        }
        result := ""
        for len(stack) > 0 {
            top := stack[len(stack)-1]   // pop
            stack = stack[:len(stack)-1]
            result += string(top)
        }
        return result</pre>
    solution: |-
      func reverseWithStack(s string) string {
          stack := []byte{}
          for i := 0; i < len(s); i++ {
              stack = append(stack, s[i])
          }
          result := ""
          for len(stack) > 0 {
              top := stack[len(stack)-1]
              stack = stack[:len(stack)-1]
              result += string(top)
          }
          return result
      }
  - id: v4
    title: Remove Adjacent Duplicates
    description: |-
      Write <code>func removeAdjacentDups(s string) string</code> that repeatedly removes pairs of adjacent duplicate characters. E.g., "abbaca" → remove "bb" → "aaca" → remove "aa" → "ca".
    functionSignature: func removeAdjacentDups(s string) string
    difficulty: 1
    testCases:
    - input: '"abbaca"'
      output: '"ca"'
    - input: '"azxxzy"'
      output: '"ay"'
    - input: '"abc"'
      output: '"abc"'
    - input: '"aaa"'
      output: '"a"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        If you push characters onto a stack, you can check if the next character matches the top. If it does, pop (removing the pair) instead of pushing.
    - title: í ½í²¡ Hint
      content: |-
        For each character: if stack is non-empty and top == current char, pop. Otherwise push. The stack contains the result.
    - title: í ½í´§ Pattern
      content: |-
        <pre>stack := []byte{}
        for i := 0; i < len(s); i++ {
            if len(stack) > 0 && stack[len(stack)-1] == s[i] {
                stack = stack[:len(stack)-1]  // pop pair
            } else {
                stack = append(stack, s[i])   // push
            }
        }
        return string(stack)</pre>
    solution: |-
      func removeAdjacentDups(s string) string {
          stack := []byte{}
          for i := 0; i < len(s); i++ {
              if len(stack) > 0 && stack[len(stack)-1] == s[i] {
                  stack = stack[:len(stack)-1]
              } else {
                  stack = append(stack, s[i])
              }
          }
          return string(stack)
      }
  - id: v5
    title: Baseball Game
    description: |-
      Write <code>func calPoints(ops []string) int</code>. Process operations: number=push score, "+"=push sum of last two, "D"=push double of last, "C"=pop last. Return total of all remaining scores.
    functionSignature: func calPoints(ops []string) int
    difficulty: 1
    testCases:
    - input: '[]string{"5","2","C","D","+"}'
      output: '30'
    - input: '[]string{"5","-2","4","C","D","9","+","+"}'
      output: '27'
    - input: '[]string{"1"}'
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        A stack perfectly models this: push scores, pop for 'C', peek at top elements for 'D' and '+'.
    - title: í ½í²¡ Hint
      content: |-
        Use strconv.Atoi for number strings. For '+': peek at last two. For 'D': peek at last one. For 'C': pop. Finally sum the stack.
    - title: í ½í´§ Pattern
      content: |-
        <pre>stack := []int{}
        for each op:
          number? push Atoi(op)
          "+"? push stack[-1] + stack[-2]
          "D"? push stack[-1] * 2
          "C"? pop
        return sum of stack</pre>
    solution: |-
      func calPoints(ops []string) int {
          stack := []int{}
          for _, op := range ops {
              switch op {
              case "+":
                  stack = append(stack, stack[len(stack)-1]+stack[len(stack)-2])
              case "D":
                  stack = append(stack, stack[len(stack)-1]*2)
              case "C":
                  stack = stack[:len(stack)-1]
              default:
                  n, _ := strconv.Atoi(op)
                  stack = append(stack, n)
              }
          }
          total := 0
          for _, v := range stack {
              total += v
          }
          return total
      }
  - id: v6
    title: Next Greater Element
    description: |-
      Write <code>func nextGreater(nums []int) []int</code> that for each element returns the next element that is greater. If none exists, use -1. E.g., [2,1,3] → [3,3,-1].
    functionSignature: func nextGreater(nums []int) []int
    difficulty: 2
    testCases:
    - input: '[]int{2,1,3}'
      output: '[]int{3,3,-1}'
    - input: '[]int{4,3,2,1}'
      output: '[]int{-1,-1,-1,-1}'
    - input: '[]int{1,2,3,4}'
      output: '[]int{2,3,4,-1}'
    - input: '[]int{1,3,2,4}'
      output: '[]int{3,4,4,-1}'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        For each element, you need to find the next larger one to its right. A stack of indices can track elements waiting for their 'next greater'.
    - title: í ½í²¡ Hint
      content: |-
        Traverse left to right. Stack holds indices of elements that haven't found their next greater. When current element is greater than top of stack, pop and assign current as the answer.
    - title: í ½í´§ Pattern
      content: |-
        <pre>result := make([]int, len(nums)) // fill with -1
        stack := []int{} // indices
        for i, num := range nums {
            for len(stack) > 0 && nums[stack[top]] < num {
                result[stack[top]] = num
                pop
            }
            push i
        }</pre>
    solution: |-
      func nextGreater(nums []int) []int {
          result := make([]int, len(nums))
          for i := range result {
              result[i] = -1
          }
          stack := []int{}
          for i, num := range nums {
              for len(stack) > 0 && nums[stack[len(stack)-1]] < num {
                  idx := stack[len(stack)-1]
                  stack = stack[:len(stack)-1]
                  result[idx] = num
              }
              stack = append(stack, i)
          }
          return result
      }
  - id: v7
    title: Daily Temperatures
    description: |-
      Write <code>func dailyTemps(temps []int) []int</code> that returns how many days you have to wait for a warmer temperature. If no warmer day, 0.
    functionSignature: func dailyTemps(temps []int) []int
    difficulty: 2
    testCases:
    - input: '[]int{73,74,75,71,69,72,76,73}'
      output: '[]int{1,1,4,2,1,1,0,0}'
    - input: '[]int{30,40,50,60}'
      output: '[]int{1,1,1,0}'
    - input: '[]int{60,50,40,30}'
      output: '[]int{0,0,0,0}'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Similar to next greater element, but instead of the value, you want the distance (difference in indices).
    - title: í ½í²¡ Hint
      content: |-
        Stack of indices. When current temp > temp at stack top, pop and compute distance: i - popped_index.
    - title: í ½í´§ Pattern
      content: |-
        <pre>result := make([]int, len(temps))
        stack := []int{}
        for i, t := range temps {
            for len(stack) > 0 && temps[stack[top]] < t {
                idx := pop
                result[idx] = i - idx
            }
            push i
        }</pre>
    solution: |-
      func dailyTemps(temps []int) []int {
          result := make([]int, len(temps))
          stack := []int{}
          for i, t := range temps {
              for len(stack) > 0 && temps[stack[len(stack)-1]] < t {
                  idx := stack[len(stack)-1]
                  stack = stack[:len(stack)-1]
                  result[idx] = i - idx
              }
              stack = append(stack, i)
          }
          return result
      }
  - id: v8
    title: Min Stack
    description: |-
      Write a MinStack with <code>Push(x int)</code>, <code>Pop()</code>, <code>Top() int</code>, and <code>GetMin() int</code>. All operations must be O(1). Use two slices: one for values, one for tracking minimums.
    functionSignature: type MinStack struct { ... }
    difficulty: 3
    testCases:
    - input: Push(-2), Push(0), Push(-3), GetMin(), Pop(), Top(), GetMin()
      output: -3, 0, -2
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        A regular stack can push/pop/top in O(1). But GetMin? You need to track the minimum at every level of the stack.
    - title: í ½í²¡ Hint
      content: |-
        Use a second stack that tracks the minimum at each depth. When pushing, also push the new min (min of x and current min) onto the min stack. When popping, pop from both.
    - title: í ½í´§ Pattern
      content: |-
        <pre>type MinStack struct {
            vals []int
            mins []int
        }
        Push: append to both (min of x and current min)
        Pop: pop from both
        Top: vals[last]
        GetMin: mins[last]</pre>
    solution: |-
      type MinStack struct {
          vals []int
          mins []int
      }

      func (s *MinStack) Push(x int) {
          s.vals = append(s.vals, x)
          if len(s.mins) == 0 || x <= s.mins[len(s.mins)-1] {
              s.mins = append(s.mins, x)
          } else {
              s.mins = append(s.mins, s.mins[len(s.mins)-1])
          }
      }

      func (s *MinStack) Pop() {
          s.vals = s.vals[:len(s.vals)-1]
          s.mins = s.mins[:len(s.mins)-1]
      }

      func (s *MinStack) Top() int {
          return s.vals[len(s.vals)-1]
      }

      func (s *MinStack) GetMin() int {
          return s.mins[len(s.mins)-1]
      }
  - id: v9
    title: Evaluate RPN
    description: |-
      Write <code>func evalRPN(tokens []string) int</code> that evaluates a Reverse Polish Notation expression. Operators: +, -, *, /. Division truncates toward zero.
    functionSignature: func evalRPN(tokens []string) int
    difficulty: 3
    testCases:
    - input: '[]string{"2","1","+","3","*"}'
      output: '9'
    - input: '[]string{"4","13","5","/","+"}'
      output: '6'
    - input: '[]string{"3","4","+"}'
      output: '7'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        RPN is naturally stack-based. Numbers get pushed. Operators pop two numbers, compute, and push the result.
    - title: í ½í²¡ Hint
      content: |-
        For each token: if it's a number, push. If it's an operator, pop two values (b first, then a), compute a op b, push result.
    - title: í ½í´§ Pattern
      content: |-
        <pre>stack := []int{}
        for each token:
            if operator:
                b, a := pop, pop
                push a op b
            else:
                push Atoi(token)
        return stack[0]</pre>
    solution: |-
      func evalRPN(tokens []string) int {
          stack := []int{}
          for _, token := range tokens {
              switch token {
              case "+", "-", "*", "/":
                  b := stack[len(stack)-1]
                  a := stack[len(stack)-2]
                  stack = stack[:len(stack)-2]
                  switch token {
                  case "+":
                      stack = append(stack, a+b)
                  case "-":
                      stack = append(stack, a-b)
                  case "*":
                      stack = append(stack, a*b)
                  case "/":
                      stack = append(stack, a/b)
                  }
              default:
                  n, _ := strconv.Atoi(token)
                  stack = append(stack, n)
              }
          }
          return stack[0]
      }
  - id: v10
    title: Decode String
    description: |-
      Write <code>func decodeString(s string) string</code> that decodes encoded strings like "3[a2[c]]" → "accaccacc". Format: k[encoded] means repeat encoded k times.
    functionSignature: func decodeString(s string) string
    difficulty: 4
    testCases:
    - input: '"3[a]2[bc]"'
      output: '"aaabcbc"'
    - input: '"3[a2[c]]"'
      output: '"accaccacc"'
    - input: '"2[abc]3[cd]ef"'
      output: '"abcabccdcdcdef"'
    - input: '"abc"'
      output: '"abc"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Brackets nest, so you need to handle inner brackets before outer ones. That's LIFO order — a stack!
    - title: í ½í²¡ Hint
      content: |-
        Use two stacks: one for repeat counts, one for strings being built. When you hit '[', push current string and count. When you hit ']', pop and repeat.
    - title: í ½í´§ Pattern
      content: |-
        <pre>countStack, strStack := []int{}, []string{}
        current, num := "", 0
        for each char:
            digit? build num
            '['? push num and current, reset both
            ']'? pop count and prev, current = prev + repeat(current, count)
            letter? current += char
        return current</pre>
    solution: |-
      func decodeString(s string) string {
          countStack := []int{}
          strStack := []string{}
          current := ""
          num := 0
          for _, ch := range s {
              if ch >= '0' && ch <= '9' {
                  num = num*10 + int(ch-'0')
              } else if ch == '[' {
                  countStack = append(countStack, num)
                  strStack = append(strStack, current)
                  current = ""
                  num = 0
              } else if ch == ']' {
                  count := countStack[len(countStack)-1]
                  countStack = countStack[:len(countStack)-1]
                  prev := strStack[len(strStack)-1]
                  strStack = strStack[:len(strStack)-1]
                  repeated := ""
                  for i := 0; i < count; i++ {
                      repeated += current
                  }
                  current = prev + repeated
              } else {
                  current += string(ch)
              }
          }
          return current
      }
  - id: v11
    title: Simplify Path
    description: |-
      Write <code>func simplifyPath(path string) string</code> that simplifies a Unix-style file path. Handle ".", "..", multiple slashes, trailing slashes.
    functionSignature: func simplifyPath(path string) string
    difficulty: 3
    testCases:
    - input: '"/home/"'
      output: '"/home"'
    - input: '"/../"'
      output: '"/"'
    - input: '"/home//foo/"'
      output: '"/home/foo"'
    - input: '"/a/./b/../../c/"'
      output: '"/c"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Split the path by '/'. Process each part: skip empty and '.', pop for '..', push otherwise. The stack represents the canonical path.
    - title: í ½í²¡ Hint
      content: |-
        Use strings.Split(path, "/"). Use a stack for directory names. Skip empty strings and ".". For "..", pop if stack non-empty. Join with "/" at the end.
    - title: í ½í´§ Pattern
      content: |-
        <pre>parts := strings.Split(path, "/")
        stack := []string{}
        for each part:
            ".." and stack not empty? pop
            "." or ""? skip
            else? push
        return "/" + strings.Join(stack, "/")</pre>
    solution: |-
      func simplifyPath(path string) string {
          parts := strings.Split(path, "/")
          stack := []string{}
          for _, part := range parts {
              switch part {
              case "", ".":
                  continue
              case "..":
                  if len(stack) > 0 {
                      stack = stack[:len(stack)-1]
                  }
              default:
                  stack = append(stack, part)
              }
          }
          return "/" + strings.Join(stack, "/")
      }
  - id: v12
    title: Asteroid Collision
    description: |-
      Write <code>func asteroidCollision(asteroids []int) []int</code>. Positive = moving right, negative = moving left. When two collide, smaller explodes. Equal = both explode. Same direction = no collision.
    functionSignature: func asteroidCollision(asteroids []int) []int
    difficulty: 4
    testCases:
    - input: '[]int{5,10,-5}'
      output: '[]int{5,10}'
    - input: '[]int{8,-8}'
      output: '[]int{}'
    - input: '[]int{10,2,-5}'
      output: '[]int{10}'
    - input: '[]int{-2,-1,1,2}'
      output: '[]int{-2,-1,1,2}'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Only right-moving (positive) followed by left-moving (negative) causes collision. Use a stack and check for collisions when pushing negative asteroids.
    - title: í ½í²¡ Hint
      content: |-
        Push positive asteroids. For negative: while stack top is positive and smaller, pop it (it explodes). If equal, pop both. If stack top is negative or empty, push.
    - title: í ½í´§ Pattern
      content: |-
        <pre>stack := []int{}
        for each asteroid:
            alive := true
            for alive && asteroid < 0 && stack not empty && stack[top] > 0:
                if stack[top] < -asteroid: pop (right explodes)
                else if stack[top] == -asteroid: pop, alive=false (both explode)
                else: alive = false (left explodes)
            if alive: push
        return stack</pre>
    solution: |-
      func asteroidCollision(asteroids []int) []int {
          stack := []int{}
          for _, a := range asteroids {
              alive := true
              for alive && a < 0 && len(stack) > 0 && stack[len(stack)-1] > 0 {
                  top := stack[len(stack)-1]
                  if top < -a {
                      stack = stack[:len(stack)-1]
                  } else if top == -a {
                      stack = stack[:len(stack)-1]
                      alive = false
                  } else {
                      alive = false
                  }
              }
              if alive {
                  stack = append(stack, a)
              }
          }
          return stack
      }
- id: challenge_18
  block: 2
  difficulty: 1
  concept: String Manipulation
  sharedContentRef: advanced_string_manipulation
  docLinks:
  - url: https://pkg.go.dev/strings
    title: Package strings
    note: string functions
  - url: https://go.dev/blog/strings
    title: 'Go Blog: Strings, bytes, runes'
    note: essential reading
  patternPrimer:
    bruteForce: Character-by-character processing with string concatenation.
    bestApproach: |-
      Use the strings package for common operations. For character-level work, iterate with range for rune support or index for bytes.
    typical: O(n) time, O(n) space for most string operations
  variants:
  - id: v1
    title: Count Vowels
    description: |-
      Write <code>func countVowels(s string) int</code> that counts the number of vowels (a, e, i, o, u, case-insensitive) in the string.
    functionSignature: func countVowels(s string) int
    difficulty: 1
    testCases:
    - input: '"hello"'
      output: '2'
    - input: '"AEIOU"'
      output: '5'
    - input: '"xyz"'
      output: '0'
    - input: '""'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Loop through each character. Check if it's a vowel. How can you handle both uppercase and lowercase?
    - title: í ½í²¡ Hint
      content: |-
        Convert to lowercase first with strings.ToLower, then check each character against 'a','e','i','o','u'. Or use strings.ContainsRune.
    - title: í ½í´§ Pattern
      content: |-
        <pre>count := 0
        for _, ch := range strings.ToLower(s) {
            if ch == 'a' || ch == 'e' || ... { count++ }
        }
        return count</pre>
    solution: |-
      func countVowels(s string) int {
          count := 0
          for _, ch := range strings.ToLower(s) {
              if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {
                  count++
              }
          }
          return count
      }
  - id: v2
    title: Reverse Words
    description: |-
      Write <code>func reverseWords(s string) string</code> that reverses the order of words in a string. Words are separated by spaces. Remove extra spaces.
    functionSignature: func reverseWords(s string) string
    difficulty: 1
    testCases:
    - input: '"hello world"'
      output: '"world hello"'
    - input: '"the sky is blue"'
      output: '"blue is sky the"'
    - input: '"  hello  world  "'
      output: '"world hello"'
    - input: '"a"'
      output: '"a"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Split into words, reverse the word array, join back together.
    - title: í ½í²¡ Hint
      content: |-
        Use strings.Fields(s) to split by whitespace (handles multiple spaces). Reverse the resulting slice. Join with strings.Join.
    - title: í ½í´§ Pattern
      content: |-
        <pre>words := strings.Fields(s)
        // reverse words slice
        for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
            words[i], words[j] = words[j], words[i]
        }
        return strings.Join(words, " ")</pre>
    solution: |-
      func reverseWords(s string) string {
          words := strings.Fields(s)
          for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
              words[i], words[j] = words[j], words[i]
          }
          return strings.Join(words, " ")
      }
  - id: v3
    title: Is Anagram
    description: |-
      Write <code>func isAnagram(s, t string) bool</code> that checks if t is an anagram of s (same characters, different order). Assume lowercase letters only.
    functionSignature: func isAnagram(s, t string) bool
    difficulty: 1
    testCases:
    - input: '"anagram", "nagaram"'
      output: 'true'
    - input: '"rat", "car"'
      output: 'false'
    - input: '"", ""'
      output: 'true'
    - input: '"ab", "a"'
      output: 'false'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Two strings are anagrams if they have exactly the same character frequencies.
    - title: í ½í²¡ Hint
      content: |-
        Count character frequencies for both strings using maps (or [26]int arrays). Compare the counts.
    - title: í ½í´§ Pattern
      content: |-
        <pre>if len(s) != len(t) { return false }
        counts := [26]int{}
        for each char in s: counts[ch-'a']++
        for each char in t: counts[ch-'a']--
        check all counts are 0</pre>
    solution: |-
      func isAnagram(s, t string) bool {
          if len(s) != len(t) {
              return false
          }
          counts := [26]int{}
          for _, ch := range s {
              counts[ch-'a']++
          }
          for _, ch := range t {
              counts[ch-'a']--
          }
          for _, c := range counts {
              if c != 0 {
                  return false
              }
          }
          return true
      }
  - id: v4
    title: Capitalize Words
    description: |-
      Write <code>func capitalizeWords(s string) string</code> that capitalizes the first letter of each word.
    functionSignature: func capitalizeWords(s string) string
    difficulty: 1
    testCases:
    - input: '"hello world"'
      output: '"Hello World"'
    - input: '"go is fun"'
      output: '"Go Is Fun"'
    - input: '"a"'
      output: '"A"'
    - input: '""'
      output: '""'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Split into words, capitalize first letter of each, join back.
    - title: í ½í²¡ Hint
      content: |-
        For each word, uppercase the first character and concatenate with the rest: strings.ToUpper(string(word[0])) + word[1:].
    - title: í ½í´§ Pattern
      content: |-
        <pre>words := strings.Fields(s)
        for i, word := range words {
            words[i] = strings.ToUpper(string(word[0])) + word[1:]
        }
        return strings.Join(words, " ")</pre>
    solution: |-
      func capitalizeWords(s string) string {
          if s == "" {
              return ""
          }
          words := strings.Fields(s)
          for i, word := range words {
              if len(word) > 0 {
                  words[i] = strings.ToUpper(string(word[0])) + word[1:]
              }
          }
          return strings.Join(words, " ")
      }
  - id: v5
    title: Remove Duplicates from String
    description: |-
      Write <code>func removeDuplicates(s string) string</code> that returns a string with duplicate characters removed, keeping only the first occurrence of each.
    functionSignature: func removeDuplicates(s string) string
    difficulty: 1
    testCases:
    - input: '"aabbcc"'
      output: '"abc"'
    - input: '"hello"'
      output: '"helo"'
    - input: '"abcabc"'
      output: '"abc"'
    - input: '""'
      output: '""'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: Use a set (map) to track which characters you've already seen.
    - title: í ½í²¡ Hint
      content: |-
        Create a map[rune]bool. For each character, if not seen, add to result and mark as seen.
    - title: í ½í´§ Pattern
      content: |-
        <pre>seen := map[rune]bool{}
        result := ""
        for _, ch := range s {
            if !seen[ch] {
                seen[ch] = true
                result += string(ch)
            }
        }
        return result</pre>
    solution: |-
      func removeDuplicates(s string) string {
          seen := map[rune]bool{}
          result := ""
          for _, ch := range s {
              if !seen[ch] {
                  seen[ch] = true
                  result += string(ch)
              }
          }
          return result
      }
  - id: v6
    title: Caesar Cipher
    description: |-
      Write <code>func caesarCipher(s string, shift int) string</code> that shifts each letter by shift positions (wrapping around). Only shift letters; leave other characters as-is. Handle both cases.
    functionSignature: func caesarCipher(s string, shift int) string
    difficulty: 2
    testCases:
    - input: '"abc", 1'
      output: '"bcd"'
    - input: '"xyz", 3'
      output: '"abc"'
    - input: '"Hello, World!", 13'
      output: '"Uryyb, Jbeyq!"'
    - input: '"abc", 0'
      output: '"abc"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        For each letter, shift it by the given amount, wrapping around z→a (or Z→A). Non-letters stay the same.
    - title: í ½í²¡ Hint
      content: |-
        For lowercase: shifted = (ch - 'a' + shift) % 26 + 'a'. Same idea for uppercase with 'A'. Use shift%26 to handle large shifts.
    - title: í ½í´§ Pattern
      content: |-
        <pre>shift = ((shift % 26) + 26) % 26  // normalize
        for each rune:
            if 'a'-'z': result += ('a' + (ch-'a'+shift)%26)
            if 'A'-'Z': result += ('A' + (ch-'A'+shift)%26)
            else: result += ch</pre>
    solution: |-
      func caesarCipher(s string, shift int) string {
          shift = ((shift % 26) + 26) % 26
          result := ""
          for _, ch := range s {
              if ch >= 'a' && ch <= 'z' {
                  result += string(rune('a' + (ch-'a'+rune(shift))%26))
              } else if ch >= 'A' && ch <= 'Z' {
                  result += string(rune('A' + (ch-'A'+rune(shift))%26))
              } else {
                  result += string(ch)
              }
          }
          return result
      }
  - id: v7
    title: Longest Common Prefix
    description: |-
      Write <code>func longestCommonPrefix(strs []string) string</code> that finds the longest common prefix string among an array of strings.
    functionSignature: func longestCommonPrefix(strs []string) string
    difficulty: 2
    testCases:
    - input: '[]string{"flower","flow","flight"}'
      output: '"fl"'
    - input: '[]string{"dog","racecar","car"}'
      output: '""'
    - input: '[]string{"abc"}'
      output: '"abc"'
    - input: '[]string{"a","a"}'
      output: '"a"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Start with the first string as the prefix. Compare with each subsequent string and shorten the prefix as needed.
    - title: í ½í²¡ Hint
      content: |-
        Take first string as prefix. For each other string, trim the prefix from the right until it matches the start of that string.
    - title: í ½í´§ Pattern
      content: |-
        <pre>prefix := strs[0]
        for _, s := range strs[1:] {
            for !strings.HasPrefix(s, prefix) {
                prefix = prefix[:len(prefix)-1]
                if prefix == "" { return "" }
            }
        }
        return prefix</pre>
    solution: |-
      func longestCommonPrefix(strs []string) string {
          if len(strs) == 0 {
              return ""
          }
          prefix := strs[0]
          for _, s := range strs[1:] {
              for !strings.HasPrefix(s, prefix) {
                  prefix = prefix[:len(prefix)-1]
                  if prefix == "" {
                      return ""
                  }
              }
          }
          return prefix
      }
  - id: v8
    title: String Compression
    description: |-
      Write <code>func compress(s string) string</code> that compresses consecutive duplicate characters: "aabcccccaaa" → "a2b1c5a3". If compressed is not shorter, return original.
    functionSignature: func compress(s string) string
    difficulty: 2
    testCases:
    - input: '"aabcccccaaa"'
      output: '"a2b1c5a3"'
    - input: '"abc"'
      output: '"abc"'
    - input: '"aaa"'
      output: '"a3"'
    - input: '""'
      output: '""'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Walk through the string counting consecutive characters. When the character changes, write the character and its count.
    - title: í ½í²¡ Hint
      content: |-
        Track current char and count. When char changes (or end of string), append char + count to result. Use strconv.Itoa for int to string.
    - title: í ½í´§ Pattern
      content: |-
        <pre>result := ""
        count := 1
        for i := 1; i <= len(s); i++ {
            if i < len(s) && s[i] == s[i-1] { count++ }
            else { result += string(s[i-1]) + Itoa(count); count = 1 }
        }
        if len(result) >= len(s) { return s }
        return result</pre>
    solution: |-
      func compress(s string) string {
          if len(s) == 0 {
              return s
          }
          result := ""
          count := 1
          for i := 1; i <= len(s); i++ {
              if i < len(s) && s[i] == s[i-1] {
                  count++
              } else {
                  result += string(s[i-1]) + strconv.Itoa(count)
                  count = 1
              }
          }
          if len(result) >= len(s) {
              return s
          }
          return result
      }
  - id: v9
    title: Valid Palindrome (Alphanumeric)
    description: |-
      Write <code>func isValidPalindrome(s string) bool</code> that checks if a string is a palindrome considering only alphanumeric characters and ignoring case.
    functionSignature: func isValidPalindrome(s string) bool
    difficulty: 2
    testCases:
    - input: '"A man, a plan, a canal: Panama"'
      output: 'true'
    - input: '"race a car"'
      output: 'false'
    - input: '" "'
      output: 'true'
    - input: '"0P"'
      output: 'false'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Use two pointers from both ends. Skip non-alphanumeric characters. Compare lowercase versions.
    - title: í ½í²¡ Hint
      content: |-
        Two pointers (left, right). Skip non-alphanumeric with unicode.IsLetter/IsDigit. Compare with unicode.ToLower. Move inward.
    - title: í ½í´§ Pattern
      content: |-
        <pre>left, right := 0, len(s)-1
        for left < right {
            skip non-alnum from left
            skip non-alnum from right
            if toLower(s[left]) != toLower(s[right]) { return false }
            left++; right--
        }
        return true</pre>
    solution: |-
      func isValidPalindrome(s string) bool {
          left, right := 0, len(s)-1
          for left < right {
              for left < right && !isAlnum(s[left]) {
                  left++
              }
              for left < right && !isAlnum(s[right]) {
                  right--
              }
              if toLower(s[left]) != toLower(s[right]) {
                  return false
              }
              left++
              right--
          }
          return true
      }

      func isAlnum(b byte) bool {
          return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || (b >= '0' && b <= '9')
      }

      func toLower(b byte) byte {
          if b >= 'A' && b <= 'Z' {
              return b + 32
          }
          return b
      }
  - id: v10
    title: Count Words
    description: |-
      Write <code>func countWords(s string) int</code> that counts the number of words in a string. Words are separated by whitespace. Handle multiple spaces and leading/trailing spaces.
    functionSignature: func countWords(s string) int
    difficulty: 1
    testCases:
    - input: '"hello world"'
      output: '2'
    - input: '"  hello   world  "'
      output: '2'
    - input: '""'
      output: '0'
    - input: '"one"'
      output: '1'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        strings.Fields splits on any whitespace and handles multiple spaces. Count the resulting slice.
    - title: í ½í²¡ Hint
      content: |-
        Use len(strings.Fields(s)). The Fields function handles all edge cases with whitespace.
    - title: í ½í´§ Pattern
      content: <pre>return len(strings.Fields(s))</pre>
    solution: |-
      func countWords(s string) int {
          return len(strings.Fields(s))
      }
  - id: v11
    title: Zigzag Conversion
    description: |-
      Write <code>func zigzag(s string, numRows int) string</code> that arranges text in a zigzag pattern with numRows rows, then reads line by line. E.g., "PAYPALISHIRING" with 3 rows: row0="PAHN", row1="APLSIIG", row2="YIR" → "PAHNAPLSIIGYIR".
    functionSignature: func zigzag(s string, numRows int) string
    difficulty: 3
    testCases:
    - input: '"PAYPALISHIRING", 3'
      output: '"PAHNAPLSIIGYIR"'
    - input: '"PAYPALISHIRING", 4'
      output: '"PINALSIGYAHRPI"'
    - input: '"A", 1'
      output: '"A"'
    - input: '"AB", 1'
      output: '"AB"'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Simulate the zigzag: move down through rows, then up, then down again. Assign each character to its row.
    - title: í ½í²¡ Hint
      content: |-
        Create numRows string builders. Track current row and direction. For each char, add to current row, change direction at top/bottom.
    - title: í ½í´§ Pattern
      content: |-
        <pre>rows := make([]string, numRows)
        curRow, goingDown := 0, false
        for each char:
            rows[curRow] += char
            if curRow == 0 || curRow == numRows-1: flip direction
            move curRow by direction
        return join all rows</pre>
    solution: |-
      func zigzag(s string, numRows int) string {
          if numRows == 1 || numRows >= len(s) {
              return s
          }
          rows := make([]string, numRows)
          curRow := 0
          goingDown := false
          for _, ch := range s {
              rows[curRow] += string(ch)
              if curRow == 0 || curRow == numRows-1 {
                  goingDown = !goingDown
              }
              if goingDown {
                  curRow++
              } else {
                  curRow--
              }
          }
          result := ""
          for _, row := range rows {
              result += row
          }
          return result
      }
  - id: v12
    title: Group Anagrams
    description: |-
      Write <code>func groupAnagrams(strs []string) [][]string</code> that groups words that are anagrams of each other.
    functionSignature: func groupAnagrams(strs []string) [][]string
    difficulty: 3
    testCases:
    - input: '[]string{"eat","tea","tan","ate","nat","bat"}'
      output: '[["eat","tea","ate"],["tan","nat"],["bat"]]'
    - input: '[]string{""}'
      output: '[[""]]'
    - input: '[]string{"a"}'
      output: '[["a"]]'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Anagrams have the same characters. If you sort the characters in each word, anagrams produce the same sorted string. Use that as a map key.
    - title: í ½í²¡ Hint
      content: |-
        For each string, sort its characters to create a key. Use a map[string][]string to group words with the same key. Return the map values.
    - title: í ½í´§ Pattern
      content: |-
        <pre>groups := map[string][]string{}
        for each word:
            key := sort characters of word
            groups[key] = append(groups[key], word)
        return all values from groups</pre>
    solution: |-
      func groupAnagrams(strs []string) [][]string {
          groups := map[string][]string{}
          for _, s := range strs {
              runes := []rune(s)
              sort.Slice(runes, func(i, j int) bool { return runes[i] < runes[j] })
              key := string(runes)
              groups[key] = append(groups[key], s)
          }
          result := [][]string{}
          for _, group := range groups {
              result = append(result, group)
          }
          return result
      }
  - id: v13
    title: Longest Substring Without Repeating
    description: |-
      Write <code>func lengthOfLongestSubstring(s string) int</code> that returns the length of the longest substring without repeating characters.
    functionSignature: func lengthOfLongestSubstring(s string) int
    difficulty: 3
    testCases:
    - input: '"abcabcbb"'
      output: '3'
    - input: '"bbbbb"'
      output: '1'
    - input: '"pwwkew"'
      output: '3'
    - input: '""'
      output: '0'
    hints:
    - title: "í ¾í´\x94 Think about it"
      content: |-
        Use a sliding window. Expand right to include new characters. When you hit a repeat, shrink from the left until no duplicates.
    - title: í ½í²¡ Hint
      content: |-
        Use a map to track the last index of each character. When a repeat is found, move the left pointer past the previous occurrence. Track max length.
    - title: í ½í´§ Pattern
      content: |-
        <pre>lastSeen := map[byte]int{}
        left, maxLen := 0, 0
        for right := 0; right < len(s); right++ {
            if idx, ok := lastSeen[s[right]]; ok && idx >= left {
                left = idx + 1
            }
            lastSeen[s[right]] = right
            if right-left+1 > maxLen { maxLen = right-left+1 }
        }
        return maxLen</pre>
    solution: |-
      func lengthOfLongestSubstring(s string) int {
          lastSeen := map[byte]int{}
          left, maxLen := 0, 0
          for right := 0; right < len(s); right++ {
              if idx, ok := lastSeen[s[right]]; ok && idx >= left {
                  left = idx + 1
              }
              lastSeen[s[right]] = right
              if right-left+1 > maxLen {
                  maxLen = right - left + 1
              }
          }
          return maxLen
      }

conceptLinks:
  For Loops: '#lesson-loops'
  If/Else: '#lesson-if'
  Slices & Range: '#lesson-slices'
  Maps: '#lesson-maps'
  make() Function: '#lesson-slices'
  Comma-Ok Pattern: '#lesson-comma-ok'
  Range with Index: '#lesson-loops'
  Building Slices: '#lesson-slices'
  Recursion: '#lesson-loops'
  Strings: '#lesson-slices'
  Switch: '#lesson-if'
  Binary Search: '#lesson-slices'
  Stack Pattern: '#lesson-slices'
  String Building: '#lesson-slices'
  Pointers: '#lesson-pointers'
  Structs: '#lesson-structs'
  Methods: '#lesson-methods'
  Interfaces: '#lesson-interfaces'
  Embedding: '#lesson-embedding'
sharedContent:
  advanced_1:
    preReading:
      title: 'Pre-reading: The "Have I Seen This?" Pattern'
      content: |-
        <strong>The Problem:</strong> How do you know if you've seen something before?<br><br>
                        <strong>Naive approach (slow):</strong><br>
                        For each element, check every other element to see if it matches ‚Üí O(n¬≤)<br>
                        For 1000 elements, that's 1,000,000 comparisons! üêå<br><br>
                        <strong>Smart approach (fast):</strong><br>
                        Use a map to remember what you've seen ‚Üí O(n)<br>
                        For 1000 elements, that's just 1000 operations! üöÄ<br><br>
                        <strong>The Pattern:</strong><br>
                        1. Create an empty map to track what you've seen<br>
                        2. For each element, check: "Have I seen this before?"<br>
                        3. If yes ‚Üí found a duplicate!<br>
                        4. If no ‚Üí remember it and continue
    hints:
    - title: Think about it
      content: |-
        As you go through the elements, how would you remember which ones you've already seen? What data structure gives you fast lookup to check "have I seen this before?"
    - title: Hint
      content: |-
        Use a map as your "memory" - the key is the element, and you just need to know it exists (what simple type represents yes/no?). For each element: first check if it's in your memory, then add it if not. If you make it through all elements without finding a duplicate, they must all be unique.
    - title: Pattern
      content: |-
        <pre>1. Create empty "seen" tracker
        2. For each element:
           - Already in tracker? ‚Üí found duplicate!
           - Not seen? ‚Üí add to tracker
        3. Finished loop? ‚Üí all unique</pre>
    docLinks:
    - url: https://go.dev/blog/maps
      title: 'Go Blog: Go maps in action'
      note: comprehensive guide to maps
    - url: https://go.dev/ref/spec#Map_types
      title: 'Go Spec: Map types'
      note: official language specification
    - url: https://go.dev/ref/spec#Making_slices_maps_and_channels
      title: 'Go Spec: make()'
      note: how make() initializes maps
  advanced_2:
    preReading:
      title: 'Pre-reading: The Slow/Fast Pointer Pattern'
      content: |-
        <strong>The Problem:</strong> Remove duplicates from a sorted collection in-place<br><br>
                        <strong>Key insight:</strong> The collection is <strong>sorted</strong>, so duplicates are next to each other!<br><br>
                        <strong>The Slow/Fast Pattern:</strong><br>
                        ‚Ä¢ <strong>Both pointers start at different positions</strong> (unlike i/j starting at opposite ends)<br>
                        ‚Ä¢ <strong>They move at different speeds</strong> (unlike i/j both moving every iteration)<br>
                        ‚Ä¢ One pointer <strong>reads</strong>, the other <strong>writes</strong><br><br>
                        <strong>Code structure pattern:</strong><br>
        <pre>slow := 0  // Initialize OUTSIDE loop (write position)

        for fast := 1; fast < len(items); fast++ {  // Initialize IN loop (read position)
            // Compare items[fast] with items[slow]
            // If different: move slow, write value
            // If same: do nothing
            // fast moves automatically every iteration
        }</pre>
    hints:
    - title: Think about it
      content: |-
        If the array is already sorted, where will duplicates be? If you're keeping track of the 'last unique' position, what do you do when you find a new unique value?
    - title: Hint
      content: |-
        Use two pointers: 'slow' marks where to write the next unique value, 'fast' scans ahead. When fast finds something different from what slow points to, you've found a new unique value - increment slow and copy it there.
    - title: Pattern
      content: |-
        <pre>1. slow = first position (write pointer)
        2. fast scans from second position (read pointer)
        3. For each fast position:
           - Different from slow? ‚Üí advance slow, copy value
           - Same? ‚Üí skip (fast moves on)
        4. Return slow + 1 (new length)</pre>
    docLinks:
    - url: https://go.dev/ref/spec#For_statements
      title: 'Go Spec: For statements'
      note: loop syntax and semantics
    - url: https://go.dev/ref/spec#Slice_types
      title: 'Go Spec: Slice types'
      note: understanding slices
    - url: https://go.dev/blog/slices-intro
      title: 'Go Blog: Arrays, slices, and strings'
      note: in-depth slice mechanics
  advanced_3:
    preReading:
      title: 'Pre-reading: Strings vs Runes in Go'
      content: "<strong>The Problem:</strong> In Go, a <code>string</code> is a sequence\
        \ of <strong>bytes</strong>, not characters!<br><br>\n                For\
        \ ASCII (a-z, 0-9), one character = one byte. Easy!<br>\n                But\
        \ for Unicode (emoji \U0001F389, Chinese ‰∏ñÁïå, etc.), one character can be 2-4\
        \ bytes.<br><br>\n                <strong>Example:</strong><br>\n        \
        \        <code>\"Hello\"</code> = 5 bytes = 5 characters √¢\x9C\N<br>\n   \
        \             <code>\"‰∏ñÁïå\"</code> = 6 bytes but only 2 characters! √¢\x9A¬†√Ø¬∏\x8F\
        <br>\n                <code>\"\U0001F389\"</code> = 4 bytes but only 1 character!\
        \ √¢\x9A¬†√Ø¬∏\x8F<br><br>\n                <strong>The Solution: Runes</strong><br>\n\
        \                A <code>rune</code> is Go's type for a Unicode character\
        \ (actually an <code>int32</code>).<br>\n                Converting to <code>[]rune</code>\
        \ splits the string into actual characters, not bytes."
    hints:
    - title: Think about it
      content: |-
        Why can't you just index a string directly with [i]? What's special about strings in Go when dealing with non-ASCII characters?
    - title: Hint
      content: |-
        Convert to []rune to handle Unicode properly. Then use the two-pointer swap pattern you learned - swap from both ends working inward.
    - title: Pattern
      content: |-
        <pre>1. Convert string to character array (runes)
        2. Two pointers: left at start, right at end
        3. While left < right:
           - Swap characters at left and right
           - Move pointers inward
        4. Convert back to string</pre>
    docLinks:
    - url: https://go.dev/blog/strings
      title: 'Go Blog: Strings, bytes, runes and characters'
      note: essential reading for Go strings
    - url: https://go.dev/ref/spec#Rune_literals
      title: 'Go Spec: Rune literals'
      note: what runes are
    - url: https://pkg.go.dev/unicode
      title: Package unicode
      note: unicode classification functions
  advanced_4:
    hints:
    - title: Think about it
      content: |-
        What's the pattern for counting things? What data structure lets you track 'how many of each thing' efficiently?
    - title: Hint
      content: |-
        First split the string into words (check the strings package for a function that splits on whitespace). Then use a map where keys are words and values are counts - what operation increases a map value?
    - title: Pattern
      content: |-
        <pre>1. Split string into words
        2. Create empty count tracker (map)
        3. For each word:
           - Increment its count
        4. Return the counts</pre>
    docLinks:
    - url: https://pkg.go.dev/strings
      title: Package strings
      note: Fields, Split, Join and more
    - url: https://go.dev/blog/maps
      title: 'Go Blog: Go maps in action'
      note: map operations including increment
    - url: https://pkg.go.dev/fmt
      title: Package fmt
      note: printing maps and formatted output
  advanced_5:
    preReading:
      title: 'Pre-reading: The Hash Map Complement Pattern'
      content: |-
        <strong>The Naive Approach (slow):</strong><br>
                        Check every pair of numbers - requires nested loops O(n¬≤)<br><br>
                        <strong>The Smart Approach (fast):</strong><br>
                        Use a map to remember what you've seen - only one loop O(n)<br><br>
                        <strong>The Key Insight:</strong><br>
                        If target = 9 and current number = 2, we need to find 7.<br>
                        Instead of searching the whole array for 7, just check: "Have I seen 7 before?"<br>
                        Maps make this lookup instant!
    hints:
    - title: Think about it
      content: |-
        For each number, what other number would you need to find to reach the target? Instead of searching the whole array for it, how could you instantly check if you've seen it?
    - title: Hint
      content: |-
        The complement is <code>target - current</code>. Use a map to remember numbers you've seen AND their indices (since you need to return indices). Check for the complement before adding the current number to your map.
    - title: Pattern
      content: |-
        <pre>1. Create tracker: number ‚Üí its index
        2. For each number at position i:
           - Calculate: complement = target - number
           - Complement in tracker? ‚Üí return [tracker[complement], i]
           - Not found? ‚Üí add number:i to tracker</pre>
    docLinks:
    - url: https://go.dev/blog/maps
      title: 'Go Blog: Go maps in action'
      note: storing values (indices) in maps
    - url: https://go.dev/ref/spec#Index_expressions
      title: 'Go Spec: Index expressions'
      note: the comma-ok idiom for map access
    - url: https://pkg.go.dev/sort
      title: Package sort
      note: for sorted-input variants
  advanced_6:
    preReading:
      title: 'Pre-reading: The Sliding Window Pattern'
      content: |-
        <strong>The Problem:</strong> Find something optimal in a contiguous subarray<br><br>
                        <strong>Naive approach (slow):</strong><br>
                        Check every possible subarray - O(n¬≤) or worse üêå<br><br>
                        <strong>Smart approach (fast):</strong><br>
                        Use a "window" that slides through the array - O(n) üöÄ<br><br>
                        <strong>Two Types of Sliding Windows:</strong><br>
                        <strong>1. Fixed-size window:</strong> Window size k stays constant<br>
                        ‚Ä¢ Add the new element entering on the right<br>
                        ‚Ä¢ Subtract the element leaving on the left<br><br>
                        <strong>2. Variable-size window:</strong> Window grows and shrinks<br>
                        ‚Ä¢ Expand (move right pointer) to include more elements<br>
                        ‚Ä¢ Shrink (move left pointer) when condition is violated or met
    hints:
    - title: Think about it
      content: |-
        If you've already calculated the sum for elements 0-3, do you really need to recalculate everything for elements 1-4? What operation can give you the new sum efficiently?
    - title: Hint
      content: |-
        For fixed windows: add the new element entering, subtract the element leaving. Think of it as the window 'sliding' right - one element comes in, one goes out. Track your max/min as you slide.
    - title: Pattern
      content: |-
        <pre>1. Calculate sum of first k elements
        2. Track this as current max
        3. Slide window: for each new position:
           - Add new element (entering window)
           - Subtract old element (leaving window)
           - Update max if current sum is larger</pre>
    docLinks:
    - url: https://go.dev/ref/spec#For_statements
      title: 'Go Spec: For statements'
      note: loop constructs
    - url: https://go.dev/blog/slices-intro
      title: 'Go Blog: Slices introduction'
      note: slice indexing and sub-slicing
    - url: https://pkg.go.dev/builtin#len
      title: Builtin len()
      note: getting slice length
  advanced_7:
    preReading:
      title: 'Pre-reading: The "Best So Far" Pattern'
      content: |-
        <strong>The Problem:</strong> Find the optimal result that depends on pairs of elements where order matters<br><br>
                        <strong>Example:</strong> Best Time to Buy/Sell Stock - you must buy BEFORE you sell<br><br>
                        <strong>Naive approach (slow):</strong><br>
                        Check every pair (i, j) where i < j - O(n¬≤) üêå<br><br>
                        <strong>Smart approach (fast):</strong><br>
                        Track the "best so far" as you scan - O(n) üöÄ<br><br>
                        <strong>The Pattern:</strong><br>
                        ‚Ä¢ Track the minimum (or maximum) seen so far<br>
                        ‚Ä¢ At each position, calculate the best result using that tracked value<br>
                        ‚Ä¢ Update your overall best if this result is better<br><br>
                        <strong>Key insight:</strong> You don't need to remember ALL previous values - just the one that matters (min or max)!
    hints:
    - title: Think about it
      content: |-
        To maximize profit, you want to buy low and sell high. As you scan through prices, what single value from the past do you need to remember to calculate the best possible profit at each day?
    - title: Hint
      content: |-
        Track the minimum price seen so far. At each day, the best profit you could make is: today's price - minimum so far. Keep track of the maximum profit across all days.
    - title: Pattern
      content: |-
        <pre>1. Initialize: minSoFar = first element, bestResult = 0
        2. For each element:
           - Calculate result using minSoFar
           - Update bestResult if this is better
           - Update minSoFar if current element is smaller
        3. Return bestResult</pre>
    docLinks:
    - url: https://go.dev/ref/spec#Comparison_operators
      title: 'Go Spec: Comparison operators'
      note: < > comparisons
    - url: https://go.dev/ref/spec#Arithmetic_operators
      title: 'Go Spec: Arithmetic operators'
      note: subtraction for differences
    - url: https://go.dev/ref/spec#If_statements
      title: 'Go Spec: If statements'
      note: conditional updates
  advanced_recursion:
    preReading:
      title: "√≠¬†¬Ω√≠¬≥\x96 Pre-reading: The Recursion Pattern"
      content: |-
        <strong>The Core Idea:</strong> A function that calls itself to solve smaller sub-problems.<br><br>Think of recursion like infiltrating a Palace in the Metaverse ‚Äî you go deeper level by level, and you <strong>always need an escape route (base case)</strong> to get back out.<br><br><strong>Every recursive function needs two things:</strong><br>‚Ä¢ <strong>Base case:</strong> The simplest version of the problem (stop recursing!)<br>‚Ä¢ <strong>Recursive case:</strong> Break the problem down and call yourself with a smaller input<br><br><strong>Example pattern:</strong><br><pre>func solve(n int) int {
            if n == 0 {          // base case - escape route!
                return 0
            }
            return n + solve(n-1) // recursive case - go deeper
        }</pre><br><strong>Key insight:</strong> Trust that the recursive call works correctly for the smaller problem. Like trusting your Phantom Thief teammates ‚Äî focus on your part, trust the rest will handle theirs.
    hints:
    - title: "√≠¬†¬æ√≠¬¥\x94 Think about it"
      content: |-
        What is the simplest possible input where you already know the answer? That's your base case. For everything else, can you express the answer in terms of a slightly smaller version of the same problem?
    - title: √≠¬†¬Ω√≠¬≤¬° Hint
      content: |-
        Write the base case first (the 'escape route'). Then write the recursive case: call the same function with a smaller input and combine the result. Make sure every recursive call moves toward the base case!
    - title: √≠¬†¬Ω√≠¬¥¬ß Pattern
      content: |-
        <pre>1. Base case: simplest input ‚Üí return known answer
        2. Recursive case:
           - Do one small piece of work
           - Call yourself with smaller input
           - Combine and return</pre>
    docLinks:
    - url: https://go.dev/ref/spec#Function_declarations
      title: 'Go Spec: Function declarations'
      note: defining functions
    - url: https://go.dev/ref/spec#Calls
      title: 'Go Spec: Calls'
      note: function call syntax
    - url: https://go.dev/ref/spec#If_statements
      title: 'Go Spec: If statements'
      note: base case conditions
  advanced_binary_search:
    preReading:
      title: "√≠¬†¬Ω√≠¬≥\x96 Pre-reading: Binary Search ‚Äî Halving the Search Space"
      content: |-
        <strong>The Problem:</strong> Find a target in a sorted collection<br><br>Imagine searching for a Shadow in Mementos. You could check every floor one by one (linear search, O(n)), or you could be smart: check the middle floor. Is the Shadow above or below? Now you've eliminated <strong>half</strong> the floors in one move!<br><br><strong>Linear search:</strong> Check every element ‚Üí O(n)<br><strong>Binary search:</strong> Halve the space each step ‚Üí O(log n)<br><br>For 1,000,000 elements: linear = 1,000,000 checks, binary = ~20 checks!<br><br><strong>The Pattern:</strong><br><pre>low, high := 0, len(items)-1
        for low <= high {
            mid := (low + high) / 2
            if items[mid] == target {
                return mid       // Found it!
            } else if items[mid] < target {
                low = mid + 1    // Search right half
            } else {
                high = mid - 1   // Search left half
            }
        }
        return -1 // Not found</pre><br><strong>Requirement:</strong> The data MUST be sorted! Like a well-organized Phantom Thief filing system.
    hints:
    - title: "√≠¬†¬æ√≠¬¥\x94 Think about it"
      content: |-
        If the array is sorted and you check the middle element, what does comparing it to your target tell you about which half to search next?
    - title: √≠¬†¬Ω√≠¬≤¬° Hint
      content: |-
        Maintain two pointers: low and high. Calculate mid = (low + high) / 2. Compare the middle element to target: equal means found, less means search right half (low = mid+1), greater means search left half (high = mid-1).
    - title: √≠¬†¬Ω√≠¬¥¬ß Pattern
      content: |-
        <pre>1. Set low = 0, high = len-1
        2. While low <= high:
           - mid = (low + high) / 2
           - Found target? ‚Üí return mid
           - Target larger? ‚Üí low = mid + 1
           - Target smaller? ‚Üí high = mid - 1
        3. Return -1 (not found)</pre>
    docLinks:
    - url: https://go.dev/ref/spec#For_statements
      title: 'Go Spec: For statements'
      note: while-style loops
    - url: https://go.dev/ref/spec#Comparison_operators
      title: 'Go Spec: Comparison operators'
      note: comparing elements
    - url: https://pkg.go.dev/sort#SearchInts
      title: 'Package sort: SearchInts'
      note: Go's built-in binary search
  advanced_stack:
    preReading:
      title: "√≠¬†¬Ω√≠¬≥\x96 Pre-reading: The Stack Pattern (LIFO)"
      content: |-
        <strong>The Core Idea:</strong> Last In, First Out ‚Äî like a stack of calling cards<br><br>Picture the Phantom Thieves' calling cards stacked on a desk. The last card placed on top is the first one you pick up. That's a stack!<br><br><strong>In Go, use a slice as a stack:</strong><br>‚Ä¢ <strong>Push:</strong> <code>stack = append(stack, item)</code><br>‚Ä¢ <strong>Pop:</strong> <code>top = stack[len(stack)-1]; stack = stack[:len(stack)-1]</code><br>‚Ä¢ <strong>Peek:</strong> <code>stack[len(stack)-1]</code> (look without removing)<br>‚Ä¢ <strong>Empty?:</strong> <code>len(stack) == 0</code><br><br><strong>Common uses:</strong><br>‚Ä¢ Matching brackets/parentheses<br>‚Ä¢ Reversing things<br>‚Ä¢ Tracking nested structures<br>‚Ä¢ Undo operations<br><br><strong>Key insight:</strong> When you need to match things that nest (like parentheses), push opening symbols and pop when you find closing ones. If they match, you're golden!
    hints:
    - title: "√≠¬†¬æ√≠¬¥\x94 Think about it"
      content: |-
        When you encounter an opening bracket, you need to remember it for later. When you encounter a closing bracket, you need to check the most recent opening bracket. What data structure handles 'most recent first'?
    - title: √≠¬†¬Ω√≠¬≤¬° Hint
      content: |-
        Use a slice as a stack: append to push, slice off the end to pop. For matching problems: push openers, pop and compare when you see closers. At the end, the stack should be empty if everything matched.
    - title: √≠¬†¬Ω√≠¬¥¬ß Pattern
      content: |-
        <pre>1. Create empty stack (slice)
        2. For each element:
           - Is it an 'opener'? ‚Üí push onto stack
           - Is it a 'closer'? ‚Üí pop from stack, check match
        3. Stack empty at end? ‚Üí all matched!</pre>
    docLinks:
    - url: https://go.dev/ref/spec#Appending_and_copying_slices
      title: 'Go Spec: Appending slices'
      note: push with append
    - url: https://go.dev/ref/spec#Slice_expressions
      title: 'Go Spec: Slice expressions'
      note: pop with re-slicing
    - url: https://go.dev/blog/slices-intro
      title: 'Go Blog: Slices introduction'
      note: slice mechanics
  advanced_string_manipulation:
    preReading:
      title: "√≠¬†¬Ω√≠¬≥\x96 Pre-reading: String Building Patterns in Go"
      content: |-
        <strong>Strings in Go are immutable</strong> ‚Äî every concatenation creates a new string!<br><br>Think of it like writing a calling card message. You can't erase and rewrite ‚Äî you have to write a whole new card each time you change something.<br><br><strong>Common patterns:</strong><br>‚Ä¢ <strong>Byte-by-byte building:</strong> Loop through characters, build result<br>‚Ä¢ <strong>strings.Builder:</strong> Efficient way to build strings piece by piece<br>‚Ä¢ <strong>[]byte conversion:</strong> Convert to mutable byte slice, modify, convert back<br><br><strong>Useful packages:</strong><br>‚Ä¢ <code>strings</code> ‚Äî Contains, Replace, Split, Join, ToUpper, ToLower, etc.<br>‚Ä¢ <code>unicode</code> ‚Äî IsLetter, IsDigit, IsUpper, IsLower, etc.<br>‚Ä¢ <code>strconv</code> ‚Äî Itoa (int to string), Atoi (string to int)<br><br><strong>Key insight:</strong> For simple cases, <code>result += char</code> is fine. For building long strings in loops, use <code>strings.Builder</code> for performance.
    hints:
    - title: "√≠¬†¬æ√≠¬¥\x94 Think about it"
      content: |-
        Do you need to examine each character individually? Consider whether you can use a function from the strings package, or if you need to iterate character by character.
    - title: √≠¬†¬Ω√≠¬≤¬° Hint
      content: |-
        For character-level work: range over the string to get runes. Build results with string concatenation or strings.Builder. Check the strings and unicode packages for helper functions before writing everything from scratch.
    - title: √≠¬†¬Ω√≠¬¥¬ß Pattern
      content: |-
        <pre>1. Choose approach:
           - strings package function? (simplest)
           - Loop through characters? (flexible)
           - Convert to []byte/[]rune? (mutable)
        2. Process each character/word
        3. Build and return result</pre>
    docLinks:
    - url: https://pkg.go.dev/strings
      title: Package strings
      note: string manipulation functions
    - url: https://pkg.go.dev/unicode
      title: Package unicode
      note: character classification
    - url: https://go.dev/blog/strings
      title: 'Go Blog: Strings, bytes, runes'
      note: essential reading
